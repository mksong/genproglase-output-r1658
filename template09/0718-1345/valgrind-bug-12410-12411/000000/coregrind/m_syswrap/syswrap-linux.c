typedef unsigned char UChar;
typedef signed char Char;
typedef char HChar;
typedef unsigned short UShort;
typedef short Short;
typedef unsigned int UInt;
typedef int Int;
typedef unsigned long long ULong;
typedef long long Long;
typedef UInt U128[4];
union __anonunion_V128_1 {
   UChar w8[16] ;
   UShort w16[8] ;
   UInt w32[4] ;
   ULong w64[2] ;
};
typedef union __anonunion_V128_1 V128;
typedef float Float;
typedef double Double;
typedef unsigned char Bool;
typedef UInt Addr32;
typedef ULong Addr64;
typedef unsigned long HWord;
typedef __builtin_va_list __gnuc_va_list;
typedef __gnuc_va_list va_list;
typedef unsigned long UWord;
typedef long Word;
typedef UWord Addr;
typedef UWord AddrH;
typedef UWord SizeT;
typedef Word SSizeT;
typedef Word PtrdiffT;
typedef Word OffT;
typedef Long Off64T;
struct __anonstruct_UWordPair_2 {
   UWord uw1 ;
   UWord uw2 ;
};
typedef struct __anonstruct_UWordPair_2 UWordPair;
typedef UInt ThreadId;
struct __anonstruct_SysRes_3 {
   UWord _val ;
   Bool _isError ;
};
typedef struct __anonstruct_SysRes_3 SysRes;
enum __anonenum_IRType_4 {
    Ity_INVALID = 69632,
    Ity_I1 = 69633,
    Ity_I8 = 69634,
    Ity_I16 = 69635,
    Ity_I32 = 69636,
    Ity_I64 = 69637,
    Ity_I128 = 69638,
    Ity_F32 = 69639,
    Ity_F64 = 69640,
    Ity_F128 = 69641,
    Ity_V128 = 69642
} ;
typedef enum __anonenum_IRType_4 IRType;
enum __anonenum_IREndness_5 {
    Iend_LE = 73728,
    Iend_BE = 73729
} ;
typedef enum __anonenum_IREndness_5 IREndness;
enum __anonenum_IRConstTag_6 {
    Ico_U1 = 77824,
    Ico_U8 = 77825,
    Ico_U16 = 77826,
    Ico_U32 = 77827,
    Ico_U64 = 77828,
    Ico_F32 = 77829,
    Ico_F32i = 77830,
    Ico_F64 = 77831,
    Ico_F64i = 77832,
    Ico_V128 = 77833
} ;
typedef enum __anonenum_IRConstTag_6 IRConstTag;
union __anonunion_Ico_7 {
   Bool U1 ;
   UChar U8 ;
   UShort U16 ;
   UInt U32 ;
   ULong U64 ;
   Float F32 ;
   UInt F32i ;
   Double F64 ;
   ULong F64i ;
   UShort V128 ;
};
struct _IRConst {
   IRConstTag tag ;
   union __anonunion_Ico_7 Ico ;
};
typedef struct _IRConst IRConst;
struct __anonstruct_IRCallee_8 {
   Int regparms ;
   HChar *name ;
   void *addr ;
   UInt mcx_mask ;
};
typedef struct __anonstruct_IRCallee_8 IRCallee;
struct __anonstruct_IRRegArray_9 {
   Int base ;
   IRType elemTy ;
   Int nElems ;
};
typedef struct __anonstruct_IRRegArray_9 IRRegArray;
typedef UInt IRTemp;
enum __anonenum_IROp_10 {
    Iop_INVALID = 81920,
    Iop_Add8 = 81921,
    Iop_Add16 = 81922,
    Iop_Add32 = 81923,
    Iop_Add64 = 81924,
    Iop_Sub8 = 81925,
    Iop_Sub16 = 81926,
    Iop_Sub32 = 81927,
    Iop_Sub64 = 81928,
    Iop_Mul8 = 81929,
    Iop_Mul16 = 81930,
    Iop_Mul32 = 81931,
    Iop_Mul64 = 81932,
    Iop_Or8 = 81933,
    Iop_Or16 = 81934,
    Iop_Or32 = 81935,
    Iop_Or64 = 81936,
    Iop_And8 = 81937,
    Iop_And16 = 81938,
    Iop_And32 = 81939,
    Iop_And64 = 81940,
    Iop_Xor8 = 81941,
    Iop_Xor16 = 81942,
    Iop_Xor32 = 81943,
    Iop_Xor64 = 81944,
    Iop_Shl8 = 81945,
    Iop_Shl16 = 81946,
    Iop_Shl32 = 81947,
    Iop_Shl64 = 81948,
    Iop_Shr8 = 81949,
    Iop_Shr16 = 81950,
    Iop_Shr32 = 81951,
    Iop_Shr64 = 81952,
    Iop_Sar8 = 81953,
    Iop_Sar16 = 81954,
    Iop_Sar32 = 81955,
    Iop_Sar64 = 81956,
    Iop_CmpEQ8 = 81957,
    Iop_CmpEQ16 = 81958,
    Iop_CmpEQ32 = 81959,
    Iop_CmpEQ64 = 81960,
    Iop_CmpNE8 = 81961,
    Iop_CmpNE16 = 81962,
    Iop_CmpNE32 = 81963,
    Iop_CmpNE64 = 81964,
    Iop_Not8 = 81965,
    Iop_Not16 = 81966,
    Iop_Not32 = 81967,
    Iop_Not64 = 81968,
    Iop_CasCmpEQ8 = 81969,
    Iop_CasCmpEQ16 = 81970,
    Iop_CasCmpEQ32 = 81971,
    Iop_CasCmpEQ64 = 81972,
    Iop_CasCmpNE8 = 81973,
    Iop_CasCmpNE16 = 81974,
    Iop_CasCmpNE32 = 81975,
    Iop_CasCmpNE64 = 81976,
    Iop_MullS8 = 81977,
    Iop_MullS16 = 81978,
    Iop_MullS32 = 81979,
    Iop_MullS64 = 81980,
    Iop_MullU8 = 81981,
    Iop_MullU16 = 81982,
    Iop_MullU32 = 81983,
    Iop_MullU64 = 81984,
    Iop_Clz64 = 81985,
    Iop_Clz32 = 81986,
    Iop_Ctz64 = 81987,
    Iop_Ctz32 = 81988,
    Iop_CmpLT32S = 81989,
    Iop_CmpLT64S = 81990,
    Iop_CmpLE32S = 81991,
    Iop_CmpLE64S = 81992,
    Iop_CmpLT32U = 81993,
    Iop_CmpLT64U = 81994,
    Iop_CmpLE32U = 81995,
    Iop_CmpLE64U = 81996,
    Iop_CmpNEZ8 = 81997,
    Iop_CmpNEZ16 = 81998,
    Iop_CmpNEZ32 = 81999,
    Iop_CmpNEZ64 = 82000,
    Iop_CmpwNEZ32 = 82001,
    Iop_CmpwNEZ64 = 82002,
    Iop_Left8 = 82003,
    Iop_Left16 = 82004,
    Iop_Left32 = 82005,
    Iop_Left64 = 82006,
    Iop_Max32U = 82007,
    Iop_CmpORD32U = 82008,
    Iop_CmpORD64U = 82009,
    Iop_CmpORD32S = 82010,
    Iop_CmpORD64S = 82011,
    Iop_DivU32 = 82012,
    Iop_DivS32 = 82013,
    Iop_DivU64 = 82014,
    Iop_DivS64 = 82015,
    Iop_DivU64E = 82016,
    Iop_DivS64E = 82017,
    Iop_DivU32E = 82018,
    Iop_DivS32E = 82019,
    Iop_DivModU64to32 = 82020,
    Iop_DivModS64to32 = 82021,
    Iop_DivModU128to64 = 82022,
    Iop_DivModS128to64 = 82023,
    Iop_DivModS64to64 = 82024,
    Iop_8Uto16 = 82025,
    Iop_8Uto32 = 82026,
    Iop_8Uto64 = 82027,
    Iop_16Uto32 = 82028,
    Iop_16Uto64 = 82029,
    Iop_32Uto64 = 82030,
    Iop_8Sto16 = 82031,
    Iop_8Sto32 = 82032,
    Iop_8Sto64 = 82033,
    Iop_16Sto32 = 82034,
    Iop_16Sto64 = 82035,
    Iop_32Sto64 = 82036,
    Iop_64to8 = 82037,
    Iop_32to8 = 82038,
    Iop_64to16 = 82039,
    Iop_16to8 = 82040,
    Iop_16HIto8 = 82041,
    Iop_8HLto16 = 82042,
    Iop_32to16 = 82043,
    Iop_32HIto16 = 82044,
    Iop_16HLto32 = 82045,
    Iop_64to32 = 82046,
    Iop_64HIto32 = 82047,
    Iop_32HLto64 = 82048,
    Iop_128to64 = 82049,
    Iop_128HIto64 = 82050,
    Iop_64HLto128 = 82051,
    Iop_Not1 = 82052,
    Iop_32to1 = 82053,
    Iop_64to1 = 82054,
    Iop_1Uto8 = 82055,
    Iop_1Uto32 = 82056,
    Iop_1Uto64 = 82057,
    Iop_1Sto8 = 82058,
    Iop_1Sto16 = 82059,
    Iop_1Sto32 = 82060,
    Iop_1Sto64 = 82061,
    Iop_AddF64 = 82062,
    Iop_SubF64 = 82063,
    Iop_MulF64 = 82064,
    Iop_DivF64 = 82065,
    Iop_AddF32 = 82066,
    Iop_SubF32 = 82067,
    Iop_MulF32 = 82068,
    Iop_DivF32 = 82069,
    Iop_AddF64r32 = 82070,
    Iop_SubF64r32 = 82071,
    Iop_MulF64r32 = 82072,
    Iop_DivF64r32 = 82073,
    Iop_NegF64 = 82074,
    Iop_AbsF64 = 82075,
    Iop_NegF32 = 82076,
    Iop_AbsF32 = 82077,
    Iop_SqrtF64 = 82078,
    Iop_SqrtF64r32 = 82079,
    Iop_SqrtF32 = 82080,
    Iop_CmpF64 = 82081,
    Iop_CmpF32 = 82082,
    Iop_CmpF128 = 82083,
    Iop_F64toI16S = 82084,
    Iop_F64toI32S = 82085,
    Iop_F64toI64S = 82086,
    Iop_F64toI64U = 82087,
    Iop_F64toI32U = 82088,
    Iop_I16StoF64 = 82089,
    Iop_I32StoF64 = 82090,
    Iop_I64StoF64 = 82091,
    Iop_I64UtoF64 = 82092,
    Iop_I64UtoF32 = 82093,
    Iop_I32UtoF64 = 82094,
    Iop_F32toI16S = 82095,
    Iop_F32toI32S = 82096,
    Iop_F32toI64S = 82097,
    Iop_I16StoF32 = 82098,
    Iop_I32StoF32 = 82099,
    Iop_I64StoF32 = 82100,
    Iop_F32toF64 = 82101,
    Iop_F64toF32 = 82102,
    Iop_ReinterpF64asI64 = 82103,
    Iop_ReinterpI64asF64 = 82104,
    Iop_ReinterpF32asI32 = 82105,
    Iop_ReinterpI32asF32 = 82106,
    Iop_F64HLtoF128 = 82107,
    Iop_F128HItoF64 = 82108,
    Iop_F128LOtoF64 = 82109,
    Iop_AddF128 = 82110,
    Iop_SubF128 = 82111,
    Iop_MulF128 = 82112,
    Iop_DivF128 = 82113,
    Iop_NegF128 = 82114,
    Iop_AbsF128 = 82115,
    Iop_SqrtF128 = 82116,
    Iop_I32StoF128 = 82117,
    Iop_I64StoF128 = 82118,
    Iop_F32toF128 = 82119,
    Iop_F64toF128 = 82120,
    Iop_F128toI32S = 82121,
    Iop_F128toI64S = 82122,
    Iop_F128toF64 = 82123,
    Iop_F128toF32 = 82124,
    Iop_AtanF64 = 82125,
    Iop_Yl2xF64 = 82126,
    Iop_Yl2xp1F64 = 82127,
    Iop_PRemF64 = 82128,
    Iop_PRemC3210F64 = 82129,
    Iop_PRem1F64 = 82130,
    Iop_PRem1C3210F64 = 82131,
    Iop_ScaleF64 = 82132,
    Iop_SinF64 = 82133,
    Iop_CosF64 = 82134,
    Iop_TanF64 = 82135,
    Iop_2xm1F64 = 82136,
    Iop_RoundF64toInt = 82137,
    Iop_RoundF32toInt = 82138,
    Iop_MAddF32 = 82139,
    Iop_MSubF32 = 82140,
    Iop_MAddF64 = 82141,
    Iop_MSubF64 = 82142,
    Iop_MAddF64r32 = 82143,
    Iop_MSubF64r32 = 82144,
    Iop_Est5FRSqrt = 82145,
    Iop_RoundF64toF64_NEAREST = 82146,
    Iop_RoundF64toF64_NegINF = 82147,
    Iop_RoundF64toF64_PosINF = 82148,
    Iop_RoundF64toF64_ZERO = 82149,
    Iop_TruncF64asF32 = 82150,
    Iop_RoundF64toF32 = 82151,
    Iop_CalcFPRF = 82152,
    Iop_Add16x2 = 82153,
    Iop_Sub16x2 = 82154,
    Iop_QAdd16Sx2 = 82155,
    Iop_QAdd16Ux2 = 82156,
    Iop_QSub16Sx2 = 82157,
    Iop_QSub16Ux2 = 82158,
    Iop_HAdd16Ux2 = 82159,
    Iop_HAdd16Sx2 = 82160,
    Iop_HSub16Ux2 = 82161,
    Iop_HSub16Sx2 = 82162,
    Iop_Add8x4 = 82163,
    Iop_Sub8x4 = 82164,
    Iop_QAdd8Sx4 = 82165,
    Iop_QAdd8Ux4 = 82166,
    Iop_QSub8Sx4 = 82167,
    Iop_QSub8Ux4 = 82168,
    Iop_HAdd8Ux4 = 82169,
    Iop_HAdd8Sx4 = 82170,
    Iop_HSub8Ux4 = 82171,
    Iop_HSub8Sx4 = 82172,
    Iop_Sad8Ux4 = 82173,
    Iop_CmpNEZ16x2 = 82174,
    Iop_CmpNEZ8x4 = 82175,
    Iop_I32UtoFx2 = 82176,
    Iop_I32StoFx2 = 82177,
    Iop_FtoI32Ux2_RZ = 82178,
    Iop_FtoI32Sx2_RZ = 82179,
    Iop_F32ToFixed32Ux2_RZ = 82180,
    Iop_F32ToFixed32Sx2_RZ = 82181,
    Iop_Fixed32UToF32x2_RN = 82182,
    Iop_Fixed32SToF32x2_RN = 82183,
    Iop_Max32Fx2 = 82184,
    Iop_Min32Fx2 = 82185,
    Iop_PwMax32Fx2 = 82186,
    Iop_PwMin32Fx2 = 82187,
    Iop_CmpEQ32Fx2 = 82188,
    Iop_CmpGT32Fx2 = 82189,
    Iop_CmpGE32Fx2 = 82190,
    Iop_Recip32Fx2 = 82191,
    Iop_Recps32Fx2 = 82192,
    Iop_Rsqrte32Fx2 = 82193,
    Iop_Rsqrts32Fx2 = 82194,
    Iop_Neg32Fx2 = 82195,
    Iop_Abs32Fx2 = 82196,
    Iop_CmpNEZ8x8 = 82197,
    Iop_CmpNEZ16x4 = 82198,
    Iop_CmpNEZ32x2 = 82199,
    Iop_Add8x8 = 82200,
    Iop_Add16x4 = 82201,
    Iop_Add32x2 = 82202,
    Iop_QAdd8Ux8 = 82203,
    Iop_QAdd16Ux4 = 82204,
    Iop_QAdd32Ux2 = 82205,
    Iop_QAdd64Ux1 = 82206,
    Iop_QAdd8Sx8 = 82207,
    Iop_QAdd16Sx4 = 82208,
    Iop_QAdd32Sx2 = 82209,
    Iop_QAdd64Sx1 = 82210,
    Iop_PwAdd8x8 = 82211,
    Iop_PwAdd16x4 = 82212,
    Iop_PwAdd32x2 = 82213,
    Iop_PwMax8Sx8 = 82214,
    Iop_PwMax16Sx4 = 82215,
    Iop_PwMax32Sx2 = 82216,
    Iop_PwMax8Ux8 = 82217,
    Iop_PwMax16Ux4 = 82218,
    Iop_PwMax32Ux2 = 82219,
    Iop_PwMin8Sx8 = 82220,
    Iop_PwMin16Sx4 = 82221,
    Iop_PwMin32Sx2 = 82222,
    Iop_PwMin8Ux8 = 82223,
    Iop_PwMin16Ux4 = 82224,
    Iop_PwMin32Ux2 = 82225,
    Iop_PwAddL8Ux8 = 82226,
    Iop_PwAddL16Ux4 = 82227,
    Iop_PwAddL32Ux2 = 82228,
    Iop_PwAddL8Sx8 = 82229,
    Iop_PwAddL16Sx4 = 82230,
    Iop_PwAddL32Sx2 = 82231,
    Iop_Sub8x8 = 82232,
    Iop_Sub16x4 = 82233,
    Iop_Sub32x2 = 82234,
    Iop_QSub8Ux8 = 82235,
    Iop_QSub16Ux4 = 82236,
    Iop_QSub32Ux2 = 82237,
    Iop_QSub64Ux1 = 82238,
    Iop_QSub8Sx8 = 82239,
    Iop_QSub16Sx4 = 82240,
    Iop_QSub32Sx2 = 82241,
    Iop_QSub64Sx1 = 82242,
    Iop_Abs8x8 = 82243,
    Iop_Abs16x4 = 82244,
    Iop_Abs32x2 = 82245,
    Iop_Mul8x8 = 82246,
    Iop_Mul16x4 = 82247,
    Iop_Mul32x2 = 82248,
    Iop_Mul32Fx2 = 82249,
    Iop_MulHi16Ux4 = 82250,
    Iop_MulHi16Sx4 = 82251,
    Iop_PolynomialMul8x8 = 82252,
    Iop_QDMulHi16Sx4 = 82253,
    Iop_QDMulHi32Sx2 = 82254,
    Iop_QRDMulHi16Sx4 = 82255,
    Iop_QRDMulHi32Sx2 = 82256,
    Iop_Avg8Ux8 = 82257,
    Iop_Avg16Ux4 = 82258,
    Iop_Max8Sx8 = 82259,
    Iop_Max16Sx4 = 82260,
    Iop_Max32Sx2 = 82261,
    Iop_Max8Ux8 = 82262,
    Iop_Max16Ux4 = 82263,
    Iop_Max32Ux2 = 82264,
    Iop_Min8Sx8 = 82265,
    Iop_Min16Sx4 = 82266,
    Iop_Min32Sx2 = 82267,
    Iop_Min8Ux8 = 82268,
    Iop_Min16Ux4 = 82269,
    Iop_Min32Ux2 = 82270,
    Iop_CmpEQ8x8 = 82271,
    Iop_CmpEQ16x4 = 82272,
    Iop_CmpEQ32x2 = 82273,
    Iop_CmpGT8Ux8 = 82274,
    Iop_CmpGT16Ux4 = 82275,
    Iop_CmpGT32Ux2 = 82276,
    Iop_CmpGT8Sx8 = 82277,
    Iop_CmpGT16Sx4 = 82278,
    Iop_CmpGT32Sx2 = 82279,
    Iop_Cnt8x8 = 82280,
    Iop_Clz8Sx8 = 82281,
    Iop_Clz16Sx4 = 82282,
    Iop_Clz32Sx2 = 82283,
    Iop_Cls8Sx8 = 82284,
    Iop_Cls16Sx4 = 82285,
    Iop_Cls32Sx2 = 82286,
    Iop_Shl8x8 = 82287,
    Iop_Shl16x4 = 82288,
    Iop_Shl32x2 = 82289,
    Iop_Shr8x8 = 82290,
    Iop_Shr16x4 = 82291,
    Iop_Shr32x2 = 82292,
    Iop_Sar8x8 = 82293,
    Iop_Sar16x4 = 82294,
    Iop_Sar32x2 = 82295,
    Iop_Sal8x8 = 82296,
    Iop_Sal16x4 = 82297,
    Iop_Sal32x2 = 82298,
    Iop_Sal64x1 = 82299,
    Iop_ShlN8x8 = 82300,
    Iop_ShlN16x4 = 82301,
    Iop_ShlN32x2 = 82302,
    Iop_ShrN8x8 = 82303,
    Iop_ShrN16x4 = 82304,
    Iop_ShrN32x2 = 82305,
    Iop_SarN8x8 = 82306,
    Iop_SarN16x4 = 82307,
    Iop_SarN32x2 = 82308,
    Iop_QShl8x8 = 82309,
    Iop_QShl16x4 = 82310,
    Iop_QShl32x2 = 82311,
    Iop_QShl64x1 = 82312,
    Iop_QSal8x8 = 82313,
    Iop_QSal16x4 = 82314,
    Iop_QSal32x2 = 82315,
    Iop_QSal64x1 = 82316,
    Iop_QShlN8Sx8 = 82317,
    Iop_QShlN16Sx4 = 82318,
    Iop_QShlN32Sx2 = 82319,
    Iop_QShlN64Sx1 = 82320,
    Iop_QShlN8x8 = 82321,
    Iop_QShlN16x4 = 82322,
    Iop_QShlN32x2 = 82323,
    Iop_QShlN64x1 = 82324,
    Iop_QSalN8x8 = 82325,
    Iop_QSalN16x4 = 82326,
    Iop_QSalN32x2 = 82327,
    Iop_QSalN64x1 = 82328,
    Iop_QNarrowBin16Sto8Ux8 = 82329,
    Iop_QNarrowBin16Sto8Sx8 = 82330,
    Iop_QNarrowBin32Sto16Sx4 = 82331,
    Iop_NarrowBin16to8x8 = 82332,
    Iop_NarrowBin32to16x4 = 82333,
    Iop_InterleaveHI8x8 = 82334,
    Iop_InterleaveHI16x4 = 82335,
    Iop_InterleaveHI32x2 = 82336,
    Iop_InterleaveLO8x8 = 82337,
    Iop_InterleaveLO16x4 = 82338,
    Iop_InterleaveLO32x2 = 82339,
    Iop_InterleaveOddLanes8x8 = 82340,
    Iop_InterleaveEvenLanes8x8 = 82341,
    Iop_InterleaveOddLanes16x4 = 82342,
    Iop_InterleaveEvenLanes16x4 = 82343,
    Iop_CatOddLanes8x8 = 82344,
    Iop_CatOddLanes16x4 = 82345,
    Iop_CatEvenLanes8x8 = 82346,
    Iop_CatEvenLanes16x4 = 82347,
    Iop_GetElem8x8 = 82348,
    Iop_GetElem16x4 = 82349,
    Iop_GetElem32x2 = 82350,
    Iop_SetElem8x8 = 82351,
    Iop_SetElem16x4 = 82352,
    Iop_SetElem32x2 = 82353,
    Iop_Dup8x8 = 82354,
    Iop_Dup16x4 = 82355,
    Iop_Dup32x2 = 82356,
    Iop_Extract64 = 82357,
    Iop_Reverse16_8x8 = 82358,
    Iop_Reverse32_8x8 = 82359,
    Iop_Reverse32_16x4 = 82360,
    Iop_Reverse64_8x8 = 82361,
    Iop_Reverse64_16x4 = 82362,
    Iop_Reverse64_32x2 = 82363,
    Iop_Perm8x8 = 82364,
    Iop_Recip32x2 = 82365,
    Iop_Rsqrte32x2 = 82366,
    Iop_Add32Fx4 = 82367,
    Iop_Sub32Fx4 = 82368,
    Iop_Mul32Fx4 = 82369,
    Iop_Div32Fx4 = 82370,
    Iop_Max32Fx4 = 82371,
    Iop_Min32Fx4 = 82372,
    Iop_Add32Fx2 = 82373,
    Iop_Sub32Fx2 = 82374,
    Iop_CmpEQ32Fx4 = 82375,
    Iop_CmpLT32Fx4 = 82376,
    Iop_CmpLE32Fx4 = 82377,
    Iop_CmpUN32Fx4 = 82378,
    Iop_CmpGT32Fx4 = 82379,
    Iop_CmpGE32Fx4 = 82380,
    Iop_Abs32Fx4 = 82381,
    Iop_PwMax32Fx4 = 82382,
    Iop_PwMin32Fx4 = 82383,
    Iop_Sqrt32Fx4 = 82384,
    Iop_RSqrt32Fx4 = 82385,
    Iop_Neg32Fx4 = 82386,
    Iop_Recip32Fx4 = 82387,
    Iop_Recps32Fx4 = 82388,
    Iop_Rsqrte32Fx4 = 82389,
    Iop_Rsqrts32Fx4 = 82390,
    Iop_I32UtoFx4 = 82391,
    Iop_I32StoFx4 = 82392,
    Iop_FtoI32Ux4_RZ = 82393,
    Iop_FtoI32Sx4_RZ = 82394,
    Iop_QFtoI32Ux4_RZ = 82395,
    Iop_QFtoI32Sx4_RZ = 82396,
    Iop_RoundF32x4_RM = 82397,
    Iop_RoundF32x4_RP = 82398,
    Iop_RoundF32x4_RN = 82399,
    Iop_RoundF32x4_RZ = 82400,
    Iop_F32ToFixed32Ux4_RZ = 82401,
    Iop_F32ToFixed32Sx4_RZ = 82402,
    Iop_Fixed32UToF32x4_RN = 82403,
    Iop_Fixed32SToF32x4_RN = 82404,
    Iop_F32toF16x4 = 82405,
    Iop_F16toF32x4 = 82406,
    Iop_Add32F0x4 = 82407,
    Iop_Sub32F0x4 = 82408,
    Iop_Mul32F0x4 = 82409,
    Iop_Div32F0x4 = 82410,
    Iop_Max32F0x4 = 82411,
    Iop_Min32F0x4 = 82412,
    Iop_CmpEQ32F0x4 = 82413,
    Iop_CmpLT32F0x4 = 82414,
    Iop_CmpLE32F0x4 = 82415,
    Iop_CmpUN32F0x4 = 82416,
    Iop_Recip32F0x4 = 82417,
    Iop_Sqrt32F0x4 = 82418,
    Iop_RSqrt32F0x4 = 82419,
    Iop_Add64Fx2 = 82420,
    Iop_Sub64Fx2 = 82421,
    Iop_Mul64Fx2 = 82422,
    Iop_Div64Fx2 = 82423,
    Iop_Max64Fx2 = 82424,
    Iop_Min64Fx2 = 82425,
    Iop_CmpEQ64Fx2 = 82426,
    Iop_CmpLT64Fx2 = 82427,
    Iop_CmpLE64Fx2 = 82428,
    Iop_CmpUN64Fx2 = 82429,
    Iop_Recip64Fx2 = 82430,
    Iop_Sqrt64Fx2 = 82431,
    Iop_RSqrt64Fx2 = 82432,
    Iop_Add64F0x2 = 82433,
    Iop_Sub64F0x2 = 82434,
    Iop_Mul64F0x2 = 82435,
    Iop_Div64F0x2 = 82436,
    Iop_Max64F0x2 = 82437,
    Iop_Min64F0x2 = 82438,
    Iop_CmpEQ64F0x2 = 82439,
    Iop_CmpLT64F0x2 = 82440,
    Iop_CmpLE64F0x2 = 82441,
    Iop_CmpUN64F0x2 = 82442,
    Iop_Recip64F0x2 = 82443,
    Iop_Sqrt64F0x2 = 82444,
    Iop_RSqrt64F0x2 = 82445,
    Iop_V128to64 = 82446,
    Iop_V128HIto64 = 82447,
    Iop_64HLtoV128 = 82448,
    Iop_64UtoV128 = 82449,
    Iop_SetV128lo64 = 82450,
    Iop_32UtoV128 = 82451,
    Iop_V128to32 = 82452,
    Iop_SetV128lo32 = 82453,
    Iop_NotV128 = 82454,
    Iop_AndV128 = 82455,
    Iop_OrV128 = 82456,
    Iop_XorV128 = 82457,
    Iop_ShlV128 = 82458,
    Iop_ShrV128 = 82459,
    Iop_CmpNEZ8x16 = 82460,
    Iop_CmpNEZ16x8 = 82461,
    Iop_CmpNEZ32x4 = 82462,
    Iop_CmpNEZ64x2 = 82463,
    Iop_Add8x16 = 82464,
    Iop_Add16x8 = 82465,
    Iop_Add32x4 = 82466,
    Iop_Add64x2 = 82467,
    Iop_QAdd8Ux16 = 82468,
    Iop_QAdd16Ux8 = 82469,
    Iop_QAdd32Ux4 = 82470,
    Iop_QAdd64Ux2 = 82471,
    Iop_QAdd8Sx16 = 82472,
    Iop_QAdd16Sx8 = 82473,
    Iop_QAdd32Sx4 = 82474,
    Iop_QAdd64Sx2 = 82475,
    Iop_Sub8x16 = 82476,
    Iop_Sub16x8 = 82477,
    Iop_Sub32x4 = 82478,
    Iop_Sub64x2 = 82479,
    Iop_QSub8Ux16 = 82480,
    Iop_QSub16Ux8 = 82481,
    Iop_QSub32Ux4 = 82482,
    Iop_QSub64Ux2 = 82483,
    Iop_QSub8Sx16 = 82484,
    Iop_QSub16Sx8 = 82485,
    Iop_QSub32Sx4 = 82486,
    Iop_QSub64Sx2 = 82487,
    Iop_Mul8x16 = 82488,
    Iop_Mul16x8 = 82489,
    Iop_Mul32x4 = 82490,
    Iop_MulHi16Ux8 = 82491,
    Iop_MulHi32Ux4 = 82492,
    Iop_MulHi16Sx8 = 82493,
    Iop_MulHi32Sx4 = 82494,
    Iop_MullEven8Ux16 = 82495,
    Iop_MullEven16Ux8 = 82496,
    Iop_MullEven8Sx16 = 82497,
    Iop_MullEven16Sx8 = 82498,
    Iop_Mull8Ux8 = 82499,
    Iop_Mull8Sx8 = 82500,
    Iop_Mull16Ux4 = 82501,
    Iop_Mull16Sx4 = 82502,
    Iop_Mull32Ux2 = 82503,
    Iop_Mull32Sx2 = 82504,
    Iop_QDMulHi16Sx8 = 82505,
    Iop_QDMulHi32Sx4 = 82506,
    Iop_QRDMulHi16Sx8 = 82507,
    Iop_QRDMulHi32Sx4 = 82508,
    Iop_QDMulLong16Sx4 = 82509,
    Iop_QDMulLong32Sx2 = 82510,
    Iop_PolynomialMul8x16 = 82511,
    Iop_PolynomialMull8x8 = 82512,
    Iop_PwAdd8x16 = 82513,
    Iop_PwAdd16x8 = 82514,
    Iop_PwAdd32x4 = 82515,
    Iop_PwAdd32Fx2 = 82516,
    Iop_PwAddL8Ux16 = 82517,
    Iop_PwAddL16Ux8 = 82518,
    Iop_PwAddL32Ux4 = 82519,
    Iop_PwAddL8Sx16 = 82520,
    Iop_PwAddL16Sx8 = 82521,
    Iop_PwAddL32Sx4 = 82522,
    Iop_Abs8x16 = 82523,
    Iop_Abs16x8 = 82524,
    Iop_Abs32x4 = 82525,
    Iop_Avg8Ux16 = 82526,
    Iop_Avg16Ux8 = 82527,
    Iop_Avg32Ux4 = 82528,
    Iop_Avg8Sx16 = 82529,
    Iop_Avg16Sx8 = 82530,
    Iop_Avg32Sx4 = 82531,
    Iop_Max8Sx16 = 82532,
    Iop_Max16Sx8 = 82533,
    Iop_Max32Sx4 = 82534,
    Iop_Max8Ux16 = 82535,
    Iop_Max16Ux8 = 82536,
    Iop_Max32Ux4 = 82537,
    Iop_Min8Sx16 = 82538,
    Iop_Min16Sx8 = 82539,
    Iop_Min32Sx4 = 82540,
    Iop_Min8Ux16 = 82541,
    Iop_Min16Ux8 = 82542,
    Iop_Min32Ux4 = 82543,
    Iop_CmpEQ8x16 = 82544,
    Iop_CmpEQ16x8 = 82545,
    Iop_CmpEQ32x4 = 82546,
    Iop_CmpEQ64x2 = 82547,
    Iop_CmpGT8Sx16 = 82548,
    Iop_CmpGT16Sx8 = 82549,
    Iop_CmpGT32Sx4 = 82550,
    Iop_CmpGT64Sx2 = 82551,
    Iop_CmpGT8Ux16 = 82552,
    Iop_CmpGT16Ux8 = 82553,
    Iop_CmpGT32Ux4 = 82554,
    Iop_Cnt8x16 = 82555,
    Iop_Clz8Sx16 = 82556,
    Iop_Clz16Sx8 = 82557,
    Iop_Clz32Sx4 = 82558,
    Iop_Cls8Sx16 = 82559,
    Iop_Cls16Sx8 = 82560,
    Iop_Cls32Sx4 = 82561,
    Iop_ShlN8x16 = 82562,
    Iop_ShlN16x8 = 82563,
    Iop_ShlN32x4 = 82564,
    Iop_ShlN64x2 = 82565,
    Iop_ShrN8x16 = 82566,
    Iop_ShrN16x8 = 82567,
    Iop_ShrN32x4 = 82568,
    Iop_ShrN64x2 = 82569,
    Iop_SarN8x16 = 82570,
    Iop_SarN16x8 = 82571,
    Iop_SarN32x4 = 82572,
    Iop_SarN64x2 = 82573,
    Iop_Shl8x16 = 82574,
    Iop_Shl16x8 = 82575,
    Iop_Shl32x4 = 82576,
    Iop_Shl64x2 = 82577,
    Iop_Shr8x16 = 82578,
    Iop_Shr16x8 = 82579,
    Iop_Shr32x4 = 82580,
    Iop_Shr64x2 = 82581,
    Iop_Sar8x16 = 82582,
    Iop_Sar16x8 = 82583,
    Iop_Sar32x4 = 82584,
    Iop_Sar64x2 = 82585,
    Iop_Sal8x16 = 82586,
    Iop_Sal16x8 = 82587,
    Iop_Sal32x4 = 82588,
    Iop_Sal64x2 = 82589,
    Iop_Rol8x16 = 82590,
    Iop_Rol16x8 = 82591,
    Iop_Rol32x4 = 82592,
    Iop_QShl8x16 = 82593,
    Iop_QShl16x8 = 82594,
    Iop_QShl32x4 = 82595,
    Iop_QShl64x2 = 82596,
    Iop_QSal8x16 = 82597,
    Iop_QSal16x8 = 82598,
    Iop_QSal32x4 = 82599,
    Iop_QSal64x2 = 82600,
    Iop_QShlN8Sx16 = 82601,
    Iop_QShlN16Sx8 = 82602,
    Iop_QShlN32Sx4 = 82603,
    Iop_QShlN64Sx2 = 82604,
    Iop_QShlN8x16 = 82605,
    Iop_QShlN16x8 = 82606,
    Iop_QShlN32x4 = 82607,
    Iop_QShlN64x2 = 82608,
    Iop_QSalN8x16 = 82609,
    Iop_QSalN16x8 = 82610,
    Iop_QSalN32x4 = 82611,
    Iop_QSalN64x2 = 82612,
    Iop_QNarrowBin16Sto8Ux16 = 82613,
    Iop_QNarrowBin32Sto16Ux8 = 82614,
    Iop_QNarrowBin16Sto8Sx16 = 82615,
    Iop_QNarrowBin32Sto16Sx8 = 82616,
    Iop_QNarrowBin16Uto8Ux16 = 82617,
    Iop_QNarrowBin32Uto16Ux8 = 82618,
    Iop_NarrowBin16to8x16 = 82619,
    Iop_NarrowBin32to16x8 = 82620,
    Iop_NarrowUn16to8x8 = 82621,
    Iop_NarrowUn32to16x4 = 82622,
    Iop_NarrowUn64to32x2 = 82623,
    Iop_QNarrowUn16Sto8Sx8 = 82624,
    Iop_QNarrowUn32Sto16Sx4 = 82625,
    Iop_QNarrowUn64Sto32Sx2 = 82626,
    Iop_QNarrowUn16Sto8Ux8 = 82627,
    Iop_QNarrowUn32Sto16Ux4 = 82628,
    Iop_QNarrowUn64Sto32Ux2 = 82629,
    Iop_QNarrowUn16Uto8Ux8 = 82630,
    Iop_QNarrowUn32Uto16Ux4 = 82631,
    Iop_QNarrowUn64Uto32Ux2 = 82632,
    Iop_Widen8Uto16x8 = 82633,
    Iop_Widen16Uto32x4 = 82634,
    Iop_Widen32Uto64x2 = 82635,
    Iop_Widen8Sto16x8 = 82636,
    Iop_Widen16Sto32x4 = 82637,
    Iop_Widen32Sto64x2 = 82638,
    Iop_InterleaveHI8x16 = 82639,
    Iop_InterleaveHI16x8 = 82640,
    Iop_InterleaveHI32x4 = 82641,
    Iop_InterleaveHI64x2 = 82642,
    Iop_InterleaveLO8x16 = 82643,
    Iop_InterleaveLO16x8 = 82644,
    Iop_InterleaveLO32x4 = 82645,
    Iop_InterleaveLO64x2 = 82646,
    Iop_InterleaveOddLanes8x16 = 82647,
    Iop_InterleaveEvenLanes8x16 = 82648,
    Iop_InterleaveOddLanes16x8 = 82649,
    Iop_InterleaveEvenLanes16x8 = 82650,
    Iop_InterleaveOddLanes32x4 = 82651,
    Iop_InterleaveEvenLanes32x4 = 82652,
    Iop_CatOddLanes8x16 = 82653,
    Iop_CatOddLanes16x8 = 82654,
    Iop_CatOddLanes32x4 = 82655,
    Iop_CatEvenLanes8x16 = 82656,
    Iop_CatEvenLanes16x8 = 82657,
    Iop_CatEvenLanes32x4 = 82658,
    Iop_GetElem8x16 = 82659,
    Iop_GetElem16x8 = 82660,
    Iop_GetElem32x4 = 82661,
    Iop_GetElem64x2 = 82662,
    Iop_Dup8x16 = 82663,
    Iop_Dup16x8 = 82664,
    Iop_Dup32x4 = 82665,
    Iop_ExtractV128 = 82666,
    Iop_Reverse16_8x16 = 82667,
    Iop_Reverse32_8x16 = 82668,
    Iop_Reverse32_16x8 = 82669,
    Iop_Reverse64_8x16 = 82670,
    Iop_Reverse64_16x8 = 82671,
    Iop_Reverse64_32x4 = 82672,
    Iop_Perm8x16 = 82673,
    Iop_Recip32x4 = 82674,
    Iop_Rsqrte32x4 = 82675
} ;
typedef enum __anonenum_IROp_10 IROp;
enum __anonenum_IRRoundingMode_11 {
    Irrm_NEAREST = 0,
    Irrm_NegINF = 1,
    Irrm_PosINF = 2,
    Irrm_ZERO = 3
} ;
typedef enum __anonenum_IRRoundingMode_11 IRRoundingMode;
enum __anonenum_IRCmpF64Result_12 {
    Ircr_UN = 69,
    Ircr_LT = 1,
    Ircr_GT = 0,
    Ircr_EQ = 64
} ;
typedef enum __anonenum_IRCmpF64Result_12 IRCmpF64Result;
typedef IRCmpF64Result IRCmpF32Result;
typedef IRCmpF64Result IRCmpF128Result;
enum __anonenum_IRExprTag_13 {
    Iex_Binder = 86016,
    Iex_Get = 86017,
    Iex_GetI = 86018,
    Iex_RdTmp = 86019,
    Iex_Qop = 86020,
    Iex_Triop = 86021,
    Iex_Binop = 86022,
    Iex_Unop = 86023,
    Iex_Load = 86024,
    Iex_Const = 86025,
    Iex_Mux0X = 86026,
    Iex_CCall = 86027
} ;
typedef enum __anonenum_IRExprTag_13 IRExprTag;
struct _IRExpr;
typedef struct _IRExpr IRExpr;
struct __anonstruct_Binder_15 {
   Int binder ;
};
struct __anonstruct_Get_16 {
   Int offset ;
   IRType ty ;
};
struct __anonstruct_GetI_17 {
   IRRegArray *descr ;
   IRExpr *ix ;
   Int bias ;
};
struct __anonstruct_RdTmp_18 {
   IRTemp tmp ;
};
struct __anonstruct_Qop_19 {
   IROp op ;
   IRExpr *arg1 ;
   IRExpr *arg2 ;
   IRExpr *arg3 ;
   IRExpr *arg4 ;
};
struct __anonstruct_Triop_20 {
   IROp op ;
   IRExpr *arg1 ;
   IRExpr *arg2 ;
   IRExpr *arg3 ;
};
struct __anonstruct_Binop_21 {
   IROp op ;
   IRExpr *arg1 ;
   IRExpr *arg2 ;
};
struct __anonstruct_Unop_22 {
   IROp op ;
   IRExpr *arg ;
};
struct __anonstruct_Load_23 {
   IREndness end ;
   IRType ty ;
   IRExpr *addr ;
};
struct __anonstruct_Const_24 {
   IRConst *con ;
};
struct __anonstruct_CCall_25 {
   IRCallee *cee ;
   IRType retty ;
   IRExpr **args ;
};
struct __anonstruct_Mux0X_26 {
   IRExpr *cond ;
   IRExpr *expr0 ;
   IRExpr *exprX ;
};
union __anonunion_Iex_14 {
   struct __anonstruct_Binder_15 Binder ;
   struct __anonstruct_Get_16 Get ;
   struct __anonstruct_GetI_17 GetI ;
   struct __anonstruct_RdTmp_18 RdTmp ;
   struct __anonstruct_Qop_19 Qop ;
   struct __anonstruct_Triop_20 Triop ;
   struct __anonstruct_Binop_21 Binop ;
   struct __anonstruct_Unop_22 Unop ;
   struct __anonstruct_Load_23 Load ;
   struct __anonstruct_Const_24 Const ;
   struct __anonstruct_CCall_25 CCall ;
   struct __anonstruct_Mux0X_26 Mux0X ;
};
struct _IRExpr {
   IRExprTag tag ;
   union __anonunion_Iex_14 Iex ;
};
enum __anonenum_IRJumpKind_27 {
    Ijk_Boring = 90112,
    Ijk_Call = 90113,
    Ijk_Ret = 90114,
    Ijk_ClientReq = 90115,
    Ijk_Yield = 90116,
    Ijk_EmWarn = 90117,
    Ijk_EmFail = 90118,
    Ijk_NoDecode = 90119,
    Ijk_MapFail = 90120,
    Ijk_TInval = 90121,
    Ijk_NoRedir = 90122,
    Ijk_SigTRAP = 90123,
    Ijk_SigSEGV = 90124,
    Ijk_SigBUS = 90125,
    Ijk_Sys_syscall = 90126,
    Ijk_Sys_int32 = 90127,
    Ijk_Sys_int128 = 90128,
    Ijk_Sys_int129 = 90129,
    Ijk_Sys_int130 = 90130,
    Ijk_Sys_sysenter = 90131
} ;
typedef enum __anonenum_IRJumpKind_27 IRJumpKind;
enum __anonenum_IREffect_28 {
    Ifx_None = 94208,
    Ifx_Read = 94209,
    Ifx_Write = 94210,
    Ifx_Modify = 94211
} ;
typedef enum __anonenum_IREffect_28 IREffect;
struct __anonstruct_fxState_30 {
   IREffect fx ;
   Int offset ;
   Int size ;
};
struct __anonstruct_IRDirty_29 {
   IRCallee *cee ;
   IRExpr *guard ;
   IRExpr **args ;
   IRTemp tmp ;
   IREffect mFx ;
   IRExpr *mAddr ;
   Int mSize ;
   Bool needsBBP ;
   Int nFxState ;
   struct __anonstruct_fxState_30 fxState[7] ;
};
typedef struct __anonstruct_IRDirty_29 IRDirty;
enum __anonenum_IRMBusEvent_31 {
    Imbe_Fence = 98304,
    Imbe_CancelReservation = 98305
} ;
typedef enum __anonenum_IRMBusEvent_31 IRMBusEvent;
struct __anonstruct_IRCAS_32 {
   IRTemp oldHi ;
   IRTemp oldLo ;
   IREndness end ;
   IRExpr *addr ;
   IRExpr *expdHi ;
   IRExpr *expdLo ;
   IRExpr *dataHi ;
   IRExpr *dataLo ;
};
typedef struct __anonstruct_IRCAS_32 IRCAS;
enum __anonenum_IRStmtTag_33 {
    Ist_NoOp = 102400,
    Ist_IMark = 102401,
    Ist_AbiHint = 102402,
    Ist_Put = 102403,
    Ist_PutI = 102404,
    Ist_WrTmp = 102405,
    Ist_Store = 102406,
    Ist_CAS = 102407,
    Ist_LLSC = 102408,
    Ist_Dirty = 102409,
    Ist_MBE = 102410,
    Ist_Exit = 102411
} ;
typedef enum __anonenum_IRStmtTag_33 IRStmtTag;
struct __anonstruct_NoOp_35 {

};
struct __anonstruct_IMark_36 {
   Addr64 addr ;
   Int len ;
   UChar delta ;
};
struct __anonstruct_AbiHint_37 {
   IRExpr *base ;
   Int len ;
   IRExpr *nia ;
};
struct __anonstruct_Put_38 {
   Int offset ;
   IRExpr *data ;
};
struct __anonstruct_PutI_39 {
   IRRegArray *descr ;
   IRExpr *ix ;
   Int bias ;
   IRExpr *data ;
};
struct __anonstruct_WrTmp_40 {
   IRTemp tmp ;
   IRExpr *data ;
};
struct __anonstruct_Store_41 {
   IREndness end ;
   IRExpr *addr ;
   IRExpr *data ;
};
struct __anonstruct_CAS_42 {
   IRCAS *details ;
};
struct __anonstruct_LLSC_43 {
   IREndness end ;
   IRTemp result ;
   IRExpr *addr ;
   IRExpr *storedata ;
};
struct __anonstruct_Dirty_44 {
   IRDirty *details ;
};
struct __anonstruct_MBE_45 {
   IRMBusEvent event ;
};
struct __anonstruct_Exit_46 {
   IRExpr *guard ;
   IRJumpKind jk ;
   IRConst *dst ;
};
union __anonunion_Ist_34 {
   struct __anonstruct_NoOp_35 NoOp ;
   struct __anonstruct_IMark_36 IMark ;
   struct __anonstruct_AbiHint_37 AbiHint ;
   struct __anonstruct_Put_38 Put ;
   struct __anonstruct_PutI_39 PutI ;
   struct __anonstruct_WrTmp_40 WrTmp ;
   struct __anonstruct_Store_41 Store ;
   struct __anonstruct_CAS_42 CAS ;
   struct __anonstruct_LLSC_43 LLSC ;
   struct __anonstruct_Dirty_44 Dirty ;
   struct __anonstruct_MBE_45 MBE ;
   struct __anonstruct_Exit_46 Exit ;
};
struct _IRStmt {
   IRStmtTag tag ;
   union __anonunion_Ist_34 Ist ;
};
typedef struct _IRStmt IRStmt;
struct __anonstruct_IRTypeEnv_47 {
   IRType *types ;
   Int types_size ;
   Int types_used ;
};
typedef struct __anonstruct_IRTypeEnv_47 IRTypeEnv;
struct __anonstruct_IRSB_48 {
   IRTypeEnv *tyenv ;
   IRStmt **stmts ;
   Int stmts_size ;
   Int stmts_used ;
   IRExpr *next ;
   IRJumpKind jumpkind ;
};
typedef struct __anonstruct_IRSB_48 IRSB;
enum __anonenum_VexArch_49 {
    VexArch_INVALID = 0,
    VexArchX86 = 1,
    VexArchAMD64 = 2,
    VexArchARM = 3,
    VexArchPPC32 = 4,
    VexArchPPC64 = 5,
    VexArchS390X = 6
} ;
typedef enum __anonenum_VexArch_49 VexArch;
struct __anonstruct_VexArchInfo_50 {
   UInt hwcaps ;
   Int ppc_cache_line_szB ;
   UInt ppc_dcbz_szB ;
   UInt ppc_dcbzl_szB ;
};
typedef struct __anonstruct_VexArchInfo_50 VexArchInfo;
struct __anonstruct_VexAbiInfo_51 {
   Int guest_stack_redzone_size ;
   Bool guest_amd64_assume_fs_is_zero ;
   Bool guest_amd64_assume_gs_is_0x60 ;
   Bool guest_ppc_zap_RZ_at_blr ;
   Bool (*guest_ppc_zap_RZ_at_bl)(Addr64  ) ;
   Bool guest_ppc_sc_continues_at_LR ;
   Bool host_ppc_calls_use_fndescrs ;
   Bool host_ppc32_regalign_int64_args ;
};
typedef struct __anonstruct_VexAbiInfo_51 VexAbiInfo;
struct __anonstruct_VexControl_52 {
   Int iropt_verbosity ;
   Int iropt_level ;
   Bool iropt_precise_memory_exns ;
   Int iropt_unroll_thresh ;
   Int guest_max_insns ;
   Int guest_chase_thresh ;
   Bool guest_chase_cond ;
};
typedef struct __anonstruct_VexControl_52 VexControl;
union __anonunion_x_53 {
   char c ;
   short s ;
   int i ;
   long l ;
   long long ll ;
   float f ;
   double d ;
   void *pto ;
   void (*ptf)(void) ;
};
struct align {
   char c ;
   union __anonunion_x_53 x ;
};
struct __anonstruct_alwaysDefd_55 {
   Int offset ;
   Int size ;
};
struct __anonstruct_VexGuestLayout_54 {
   Int total_sizeB ;
   Int offset_SP ;
   Int sizeof_SP ;
   Int offset_FP ;
   Int sizeof_FP ;
   Int offset_IP ;
   Int sizeof_IP ;
   Int n_alwaysDefd ;
   struct __anonstruct_alwaysDefd_55 alwaysDefd[24] ;
};
typedef struct __anonstruct_VexGuestLayout_54 VexGuestLayout;
enum __anonenum_status_57 {
    VexTransOK = 0,
    VexTransAccessFail = 1,
    VexTransOutputFull = 2
} ;
struct __anonstruct_VexTranslateResult_56 {
   enum __anonenum_status_57 status ;
   UInt n_sc_extents ;
};
typedef struct __anonstruct_VexTranslateResult_56 VexTranslateResult;
struct __anonstruct_VexGuestExtents_58 {
   Addr64 base[3] ;
   UShort len[3] ;
   UShort n_used ;
};
typedef struct __anonstruct_VexGuestExtents_58 VexGuestExtents;
struct __anonstruct_VexTranslateArgs_59 {
   VexArch arch_guest ;
   VexArchInfo archinfo_guest ;
   VexArch arch_host ;
   VexArchInfo archinfo_host ;
   VexAbiInfo abiinfo_both ;
   void *callback_opaque ;
   UChar *guest_bytes ;
   Addr64 guest_bytes_addr ;
   Bool (*chase_into_ok)(void * , Addr64  ) ;
   VexGuestExtents *guest_extents ;
   UChar *host_bytes ;
   Int host_bytes_size ;
   Int *host_bytes_used ;
   IRSB *(*instrument1)(void * , IRSB * , VexGuestLayout * , VexGuestExtents * ,
                        IRType gWordTy , IRType hWordTy ) ;
   IRSB *(*instrument2)(void * , IRSB * , VexGuestLayout * , VexGuestExtents * ,
                        IRType gWordTy , IRType hWordTy ) ;
   IRSB *(*finaltidy)(IRSB * ) ;
   UInt (*needs_self_check)(void * , VexGuestExtents * ) ;
   Bool (*preamble_function)(void * , IRSB * ) ;
   Int traceflags ;
   void *dispatch_unassisted ;
   void *dispatch_assisted ;
};
typedef struct __anonstruct_VexTranslateArgs_59 VexTranslateArgs;
enum __anonenum_VexEmWarn_60 {
    EmWarn_NONE = 0,
    EmWarn_X86_x87exns = 1,
    EmWarn_X86_x87precision = 2,
    EmWarn_X86_sseExns = 3,
    EmWarn_X86_fz = 4,
    EmWarn_X86_daz = 5,
    EmWarn_X86_acFlag = 6,
    EmWarn_PPCexns = 7,
    EmWarn_PPC64_redir_overflow = 8,
    EmWarn_PPC64_redir_underflow = 9,
    EmWarn_NUMBER = 10
} ;
typedef enum __anonenum_VexEmWarn_60 VexEmWarn;
struct __anonstruct_VexGuestX86State_61 {
   UInt guest_EAX ;
   UInt guest_ECX ;
   UInt guest_EDX ;
   UInt guest_EBX ;
   UInt guest_ESP ;
   UInt guest_EBP ;
   UInt guest_ESI ;
   UInt guest_EDI ;
   UInt guest_CC_OP ;
   UInt guest_CC_DEP1 ;
   UInt guest_CC_DEP2 ;
   UInt guest_CC_NDEP ;
   UInt guest_DFLAG ;
   UInt guest_IDFLAG ;
   UInt guest_ACFLAG ;
   UInt guest_EIP ;
   ULong guest_FPREG[8] ;
   UChar guest_FPTAG[8] ;
   UInt guest_FPROUND ;
   UInt guest_FC3210 ;
   UInt guest_FTOP ;
   UInt guest_SSEROUND ;
   U128 guest_XMM0 ;
   U128 guest_XMM1 ;
   U128 guest_XMM2 ;
   U128 guest_XMM3 ;
   U128 guest_XMM4 ;
   U128 guest_XMM5 ;
   U128 guest_XMM6 ;
   U128 guest_XMM7 ;
   UShort guest_CS ;
   UShort guest_DS ;
   UShort guest_ES ;
   UShort guest_FS ;
   UShort guest_GS ;
   UShort guest_SS ;
   HWord guest_LDT ;
   HWord guest_GDT ;
   UInt guest_EMWARN ;
   UInt guest_TISTART ;
   UInt guest_TILEN ;
   UInt guest_NRADDR ;
   UInt guest_SC_CLASS ;
   UInt guest_IP_AT_SYSCALL ;
   UInt padding1 ;
   UInt padding2 ;
   UInt padding3 ;
};
typedef struct __anonstruct_VexGuestX86State_61 VexGuestX86State;
struct __anonstruct_Bits_64 {
   UShort LimitLow ;
   UShort BaseLow ;
   UInt BaseMid : 8 ;
   UInt Type : 5 ;
   UInt Dpl : 2 ;
   UInt Pres : 1 ;
   UInt LimitHi : 4 ;
   UInt Sys : 1 ;
   UInt Reserved_0 : 1 ;
   UInt Default_Big : 1 ;
   UInt Granularity : 1 ;
   UInt BaseHi : 8 ;
};
struct __anonstruct_Words_65 {
   UInt word1 ;
   UInt word2 ;
};
union __anonunion_LdtEnt_63 {
   struct __anonstruct_Bits_64 Bits ;
   struct __anonstruct_Words_65 Words ;
};
struct __anonstruct_VexGuestX86SegDescr_62 {
   union __anonunion_LdtEnt_63 LdtEnt ;
};
typedef struct __anonstruct_VexGuestX86SegDescr_62 VexGuestX86SegDescr;
struct __anonstruct_X86_68 {
   UInt r_ebp ;
};
struct __anonstruct_AMD64_69 {
   ULong r_rbp ;
};
struct __anonstruct_PPC32_70 {
   UInt r_lr ;
};
struct __anonstruct_PPC64_71 {
   ULong r_lr ;
};
struct __anonstruct_ARM_72 {
   UInt r14 ;
   UInt r12 ;
   UInt r11 ;
   UInt r7 ;
};
struct __anonstruct_S390X_73 {
   ULong r_fp ;
   ULong r_lr ;
};
union __anonunion_misc_67 {
   struct __anonstruct_X86_68 X86 ;
   struct __anonstruct_AMD64_69 AMD64 ;
   struct __anonstruct_PPC32_70 PPC32 ;
   struct __anonstruct_PPC64_71 PPC64 ;
   struct __anonstruct_ARM_72 ARM ;
   struct __anonstruct_S390X_73 S390X ;
};
struct __anonstruct_UnwindStartRegs_66 {
   ULong r_pc ;
   ULong r_sp ;
   union __anonunion_misc_67 misc ;
};
typedef struct __anonstruct_UnwindStartRegs_66 UnwindStartRegs;
typedef unsigned short __vki_kernel_mode_t;
typedef long __vki_kernel_off_t;
typedef int __vki_kernel_pid_t;
typedef unsigned short __vki_kernel_ipc_pid_t;
typedef unsigned short __vki_kernel_uid_t;
typedef unsigned short __vki_kernel_gid_t;
typedef unsigned int __vki_kernel_size_t;
typedef long __vki_kernel_time_t;
typedef long __vki_kernel_suseconds_t;
typedef long __vki_kernel_clock_t;
typedef int __vki_kernel_timer_t;
typedef int __vki_kernel_clockid_t;
typedef char *__vki_kernel_caddr_t;
typedef unsigned int __vki_kernel_uid32_t;
typedef unsigned int __vki_kernel_gid32_t;
typedef unsigned short __vki_kernel_old_uid_t;
typedef unsigned short __vki_kernel_old_gid_t;
typedef long long __vki_kernel_loff_t;
struct __anonstruct___vki_kernel_fsid_t_74 {
   int val[2] ;
};
typedef struct __anonstruct___vki_kernel_fsid_t_74 __vki_kernel_fsid_t;
struct __anonstruct___vki_kernel_fd_set_75 {
   unsigned long fds_bits[1024U / (8U * sizeof(unsigned long ))] ;
};
typedef struct __anonstruct___vki_kernel_fd_set_75 __vki_kernel_fd_set;
typedef int __vki_kernel_key_t;
typedef int __vki_kernel_mqd_t;
typedef __vki_kernel_fd_set vki_fd_set;
typedef __vki_kernel_mode_t vki_mode_t;
typedef __vki_kernel_off_t vki_off_t;
typedef __vki_kernel_pid_t vki_pid_t;
typedef __vki_kernel_key_t vki_key_t;
typedef __vki_kernel_suseconds_t vki_suseconds_t;
typedef __vki_kernel_timer_t vki_timer_t;
typedef __vki_kernel_clockid_t vki_clockid_t;
typedef __vki_kernel_mqd_t vki_mqd_t;
typedef __vki_kernel_uid32_t vki_uid_t;
typedef __vki_kernel_gid32_t vki_gid_t;
typedef __vki_kernel_old_uid_t vki_old_uid_t;
typedef __vki_kernel_old_gid_t vki_old_gid_t;
typedef __vki_kernel_loff_t vki_loff_t;
typedef __vki_kernel_size_t vki_size_t;
typedef __vki_kernel_time_t vki_time_t;
typedef __vki_kernel_clock_t vki_clock_t;
typedef __vki_kernel_caddr_t vki_caddr_t;
typedef unsigned long vki_u_long;
typedef unsigned int vki_uint;
typedef unsigned char __vki_u8;
typedef short __vki_s16;
typedef unsigned short __vki_u16;
typedef int __vki_s32;
typedef unsigned int __vki_u32;
typedef long long __vki_s64;
typedef unsigned long long __vki_u64;
typedef unsigned short vki_u16;
typedef unsigned int vki_u32;
typedef void __vki_signalfn_t(int  );
typedef __vki_signalfn_t *__vki_sighandler_t;
typedef void __vki_restorefn_t(void);
typedef __vki_restorefn_t *__vki_sigrestore_t;
typedef unsigned long vki_old_sigset_t;
struct __anonstruct_vki_sigset_t_76 {
   unsigned long sig[2] ;
};
typedef struct __anonstruct_vki_sigset_t_76 vki_sigset_t;
struct vki_old_sigaction {
   __vki_sighandler_t ksa_handler ;
   vki_old_sigset_t sa_mask ;
   unsigned long sa_flags ;
   __vki_sigrestore_t sa_restorer ;
};
struct vki_sigaction_base {
   __vki_sighandler_t ksa_handler ;
   unsigned long sa_flags ;
   __vki_sigrestore_t sa_restorer ;
   vki_sigset_t sa_mask ;
};
typedef struct vki_sigaction_base vki_sigaction_toK_t;
typedef struct vki_sigaction_base vki_sigaction_fromK_t;
struct vki_sigaltstack {
   void *ss_sp ;
   int ss_flags ;
   vki_size_t ss_size ;
};
typedef struct vki_sigaltstack vki_stack_t;
struct _vki_fpreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
};
struct _vki_fpxreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
   unsigned short padding[3] ;
};
struct _vki_xmmreg {
   unsigned long element[4] ;
};
struct _vki_fpstate {
   unsigned long cw ;
   unsigned long sw ;
   unsigned long tag ;
   unsigned long ipoff ;
   unsigned long cssel ;
   unsigned long dataoff ;
   unsigned long datasel ;
   struct _vki_fpreg _st[8] ;
   unsigned short status ;
   unsigned short magic ;
   unsigned long _fxsr_env[6] ;
   unsigned long mxcsr ;
   unsigned long reserved ;
   struct _vki_fpxreg _fxsr_st[8] ;
   struct _vki_xmmreg _xmm[8] ;
   unsigned long padding[56] ;
};
struct vki_sigcontext {
   unsigned short gs ;
   unsigned short __gsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned long edi ;
   unsigned long esi ;
   unsigned long ebp ;
   unsigned long esp ;
   unsigned long ebx ;
   unsigned long edx ;
   unsigned long ecx ;
   unsigned long eax ;
   unsigned long trapno ;
   unsigned long err ;
   unsigned long eip ;
   unsigned short cs ;
   unsigned short __csh ;
   unsigned long eflags ;
   unsigned long esp_at_signal ;
   unsigned short ss ;
   unsigned short __ssh ;
   struct _vki_fpstate *fpstate ;
   unsigned long oldmask ;
   unsigned long cr2 ;
};
struct vki_f_owner_ex {
   int type ;
   __vki_kernel_pid_t pid ;
};
struct vki_stat {
   unsigned long st_dev ;
   unsigned long st_ino ;
   unsigned short st_mode ;
   unsigned short st_nlink ;
   unsigned short st_uid ;
   unsigned short st_gid ;
   unsigned long st_rdev ;
   unsigned long st_size ;
   unsigned long st_blksize ;
   unsigned long st_blocks ;
   unsigned long st_atime ;
   unsigned long st_atime_nsec ;
   unsigned long st_mtime ;
   unsigned long st_mtime_nsec ;
   unsigned long st_ctime ;
   unsigned long st_ctime_nsec ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
struct vki_stat64 {
   unsigned long long st_dev ;
   unsigned char __pad0[4] ;
   unsigned long __st_ino ;
   unsigned int st_mode ;
   unsigned int st_nlink ;
   unsigned long st_uid ;
   unsigned long st_gid ;
   unsigned long long st_rdev ;
   unsigned char __pad3[4] ;
   long long st_size ;
   unsigned long st_blksize ;
   unsigned long st_blocks ;
   unsigned long __pad4 ;
   unsigned long st_atime ;
   unsigned long st_atime_nsec ;
   unsigned long st_mtime ;
   unsigned int st_mtime_nsec ;
   unsigned long st_ctime ;
   unsigned long st_ctime_nsec ;
   unsigned long long st_ino ;
};
struct vki_statfs {
   __vki_u32 f_type ;
   __vki_u32 f_bsize ;
   __vki_u32 f_blocks ;
   __vki_u32 f_bfree ;
   __vki_u32 f_bavail ;
   __vki_u32 f_files ;
   __vki_u32 f_ffree ;
   __vki_kernel_fsid_t f_fsid ;
   __vki_u32 f_namelen ;
   __vki_u32 f_frsize ;
   __vki_u32 f_spare[5] ;
};
struct vki_winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
struct vki_termio {
   unsigned short c_iflag ;
   unsigned short c_oflag ;
   unsigned short c_cflag ;
   unsigned short c_lflag ;
   unsigned char c_line ;
   unsigned char c_cc[8] ;
};
typedef unsigned char vki_cc_t;
typedef unsigned int vki_tcflag_t;
struct vki_termios {
   vki_tcflag_t c_iflag ;
   vki_tcflag_t c_oflag ;
   vki_tcflag_t c_cflag ;
   vki_tcflag_t c_lflag ;
   vki_cc_t c_line ;
   vki_cc_t c_cc[19] ;
};
struct vki_pollfd {
   int fd ;
   short events ;
   short revents ;
};
struct vki_user_i387_struct {
   long cwd ;
   long swd ;
   long twd ;
   long fip ;
   long fcs ;
   long foo ;
   long fos ;
   long st_space[20] ;
};
struct vki_user_fxsr_struct {
   unsigned short cwd ;
   unsigned short swd ;
   unsigned short twd ;
   unsigned short fop ;
   long fip ;
   long fcs ;
   long foo ;
   long fos ;
   long mxcsr ;
   long reserved ;
   long st_space[32] ;
   long xmm_space[32] ;
   long padding[56] ;
};
struct vki_user_regs_struct {
   long ebx ;
   long ecx ;
   long edx ;
   long esi ;
   long edi ;
   long ebp ;
   long eax ;
   unsigned short ds ;
   unsigned short __ds ;
   unsigned short es ;
   unsigned short __es ;
   unsigned short fs ;
   unsigned short __fs ;
   unsigned short gs ;
   unsigned short __gs ;
   long orig_eax ;
   long eip ;
   unsigned short cs ;
   unsigned short __cs ;
   long eflags ;
   long esp ;
   unsigned short ss ;
   unsigned short __ss ;
};
typedef unsigned long vki_elf_greg_t;
typedef vki_elf_greg_t vki_elf_gregset_t[sizeof(struct vki_user_regs_struct ) / sizeof(vki_elf_greg_t )];
typedef struct vki_user_i387_struct vki_elf_fpregset_t;
typedef struct vki_user_fxsr_struct vki_elf_fpxregset_t;
struct vki_ucontext {
   unsigned long uc_flags ;
   struct vki_ucontext *uc_link ;
   vki_stack_t uc_stack ;
   struct vki_sigcontext uc_mcontext ;
   vki_sigset_t uc_sigmask ;
};
struct vki_user_desc {
   unsigned int entry_number ;
   unsigned long base_addr ;
   unsigned int limit ;
   unsigned int seg_32bit : 1 ;
   unsigned int contents : 2 ;
   unsigned int read_exec_only : 1 ;
   unsigned int limit_in_pages : 1 ;
   unsigned int seg_not_present : 1 ;
   unsigned int useable : 1 ;
   unsigned int reserved : 25 ;
};
typedef struct vki_user_desc vki_modify_ldt_t;
struct vki_ipc64_perm {
   __vki_kernel_key_t key ;
   __vki_kernel_uid32_t uid ;
   __vki_kernel_gid32_t gid ;
   __vki_kernel_uid32_t cuid ;
   __vki_kernel_gid32_t cgid ;
   __vki_kernel_mode_t mode ;
   unsigned short __pad1 ;
   unsigned short seq ;
   unsigned short __pad2 ;
   unsigned long __unused1 ;
   unsigned long __unused2 ;
};
struct vki_semid64_ds {
   struct vki_ipc64_perm sem_perm ;
   __vki_kernel_time_t sem_otime ;
   unsigned long __unused1 ;
   __vki_kernel_time_t sem_ctime ;
   unsigned long __unused2 ;
   unsigned long sem_nsems ;
   unsigned long __unused3 ;
   unsigned long __unused4 ;
};
struct vki_msqid64_ds {
   struct vki_ipc64_perm msg_perm ;
   __vki_kernel_time_t msg_stime ;
   unsigned long __unused1 ;
   __vki_kernel_time_t msg_rtime ;
   unsigned long __unused2 ;
   __vki_kernel_time_t msg_ctime ;
   unsigned long __unused3 ;
   unsigned long msg_cbytes ;
   unsigned long msg_qnum ;
   unsigned long msg_qbytes ;
   __vki_kernel_pid_t msg_lspid ;
   __vki_kernel_pid_t msg_lrpid ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
struct vki_msgbuf;
struct vki_ipc_kludge {
   struct vki_msgbuf *msgp ;
   long msgtyp ;
};
struct vki_shmid64_ds {
   struct vki_ipc64_perm shm_perm ;
   vki_size_t shm_segsz ;
   __vki_kernel_time_t shm_atime ;
   unsigned long __unused1 ;
   __vki_kernel_time_t shm_dtime ;
   unsigned long __unused2 ;
   __vki_kernel_time_t shm_ctime ;
   unsigned long __unused3 ;
   __vki_kernel_pid_t shm_cpid ;
   __vki_kernel_pid_t shm_lpid ;
   unsigned long shm_nattch ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
struct vki_shminfo64 {
   unsigned long shmmax ;
   unsigned long shmmin ;
   unsigned long shmmni ;
   unsigned long shmseg ;
   unsigned long shmall ;
   unsigned long __unused1 ;
   unsigned long __unused2 ;
   unsigned long __unused3 ;
   unsigned long __unused4 ;
};
struct vki_vm86_regs {
   long ebx ;
   long ecx ;
   long edx ;
   long esi ;
   long edi ;
   long ebp ;
   long eax ;
   long __null_ds ;
   long __null_es ;
   long __null_fs ;
   long __null_gs ;
   long orig_eax ;
   long eip ;
   unsigned short cs ;
   unsigned short __csh ;
   long eflags ;
   long esp ;
   unsigned short ss ;
   unsigned short __ssh ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
struct vki_revectored_struct {
   unsigned long __map[8] ;
};
struct vki_vm86_struct {
   struct vki_vm86_regs regs ;
   unsigned long flags ;
   unsigned long screen_bitmap ;
   unsigned long cpu_type ;
   struct vki_revectored_struct int_revectored ;
   struct vki_revectored_struct int21_revectored ;
};
struct vki_vm86plus_info_struct {
   unsigned long force_return_for_pic : 1 ;
   unsigned long vm86dbg_active : 1 ;
   unsigned long vm86dbg_TFpendig : 1 ;
   unsigned long unused : 28 ;
   unsigned long is_vm86pus : 1 ;
   unsigned char vm86dbg_intxxtab[32] ;
};
struct vki_vm86plus_struct {
   struct vki_vm86_regs regs ;
   unsigned long flags ;
   unsigned long screen_bitmap ;
   unsigned long cpu_type ;
   struct vki_revectored_struct int_revectored ;
   struct vki_revectored_struct int21_revectored ;
   struct vki_vm86plus_info_struct vm86plus ;
};
typedef __vki_s32 vki_int32_t;
typedef __vki_s64 vki_int64_t;
typedef __vki_u8 vki_uint8_t;
typedef __vki_u16 vki_uint16_t;
typedef __vki_u32 vki_uint32_t;
struct vki_sysinfo {
   long uptime ;
   unsigned long loads[3] ;
   unsigned long totalram ;
   unsigned long freeram ;
   unsigned long sharedram ;
   unsigned long bufferram ;
   unsigned long totalswap ;
   unsigned long freeswap ;
   unsigned short procs ;
   unsigned short pad ;
   unsigned long totalhigh ;
   unsigned long freehigh ;
   unsigned int mem_unit ;
   char _f[(20U - 2U * sizeof(long )) - sizeof(int )] ;
};
struct vki_timespec {
   vki_time_t tv_sec ;
   long tv_nsec ;
};
struct vki_timeval {
   vki_time_t tv_sec ;
   vki_suseconds_t tv_usec ;
};
struct vki_timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
struct vki_itimerspec {
   struct vki_timespec it_interval ;
   struct vki_timespec it_value ;
};
struct vki_itimerval {
   struct vki_timeval it_interval ;
   struct vki_timeval it_value ;
};
struct vki_timex {
   unsigned int modes ;
   long offset ;
   long freq ;
   long maxerror ;
   long esterror ;
   int status ;
   long constant ;
   long precision ;
   long tolerance ;
   struct vki_timeval time ;
   long tick ;
   long ppsfreq ;
   long jitter ;
   int shift ;
   long stabil ;
   long jitcnt ;
   long calcnt ;
   long errcnt ;
   long stbcnt ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
   int  : 32 ;
};
struct vki_tms {
   vki_clock_t tms_utime ;
   vki_clock_t tms_stime ;
   vki_clock_t tms_cutime ;
   vki_clock_t tms_cstime ;
};
struct vki_utimbuf {
   vki_time_t actime ;
   vki_time_t modtime ;
};
struct vki_sched_param {
   int sched_priority ;
};
union vki_sigval {
   int sival_int ;
   void *sival_ptr ;
};
typedef union vki_sigval vki_sigval_t;
struct __anonstruct__kill_78 {
   vki_pid_t _pid ;
   vki_uid_t _uid ;
};
struct __anonstruct__timer_79 {
   vki_timer_t _tid ;
   int _overrun ;
   char _pad[sizeof(vki_uid_t ) - sizeof(int )] ;
   vki_sigval_t _sigval ;
   int _sys_private ;
};
struct __anonstruct__rt_80 {
   vki_pid_t _pid ;
   vki_uid_t _uid ;
   vki_sigval_t _sigval ;
};
struct __anonstruct__sigchld_81 {
   vki_pid_t _pid ;
   vki_uid_t _uid ;
   int _status ;
   vki_clock_t _utime ;
   vki_clock_t _stime ;
};
struct __anonstruct__sigfault_82 {
   void *_addr ;
};
struct __anonstruct__sigpoll_83 {
   long _band ;
   int _fd ;
};
union __anonunion__sifields_77 {
   int _pad[(128U - 3U * sizeof(int )) / sizeof(int )] ;
   struct __anonstruct__kill_78 _kill ;
   struct __anonstruct__timer_79 _timer ;
   struct __anonstruct__rt_80 _rt ;
   struct __anonstruct__sigchld_81 _sigchld ;
   struct __anonstruct__sigfault_82 _sigfault ;
   struct __anonstruct__sigpoll_83 _sigpoll ;
};
struct vki_siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_77 _sifields ;
};
typedef struct vki_siginfo vki_siginfo_t;
struct __anonstruct__sigev_thread_85 {
   void (*_function)(vki_sigval_t  ) ;
   void *_attribute ;
};
union __anonunion__sigev_un_84 {
   int _pad[(64U - (sizeof(int ) * 2U + sizeof(vki_sigval_t ))) / sizeof(int )] ;
   int _tid ;
   struct __anonstruct__sigev_thread_85 _sigev_thread ;
};
struct vki_sigevent {
   vki_sigval_t sigev_value ;
   int sigev_signo ;
   int sigev_notify ;
   union __anonunion__sigev_un_84 _sigev_un ;
};
typedef struct vki_sigevent vki_sigevent_t;
enum vki_sock_type {
    VKI_SOCK_STREAM = 1
} ;
struct vki_iovec {
   void *iov_base ;
   __vki_kernel_size_t iov_len ;
};
typedef unsigned short vki_sa_family_t;
struct vki_sockaddr {
   vki_sa_family_t sa_family ;
   char sa_data[14] ;
};
struct vki_msghdr {
   void *msg_name ;
   int msg_namelen ;
   struct vki_iovec *msg_iov ;
   __vki_kernel_size_t msg_iovlen ;
   void *msg_control ;
   __vki_kernel_size_t msg_controllen ;
   unsigned int msg_flags ;
};
struct vki_mmsghdr {
   struct vki_msghdr msg_hdr ;
   unsigned int msg_len ;
};
struct vki_cmsghdr {
   __vki_kernel_size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
};
struct vki_in_addr {
   __vki_u32 s_addr ;
};
struct vki_sockaddr_in {
   vki_sa_family_t sin_family ;
   unsigned short sin_port ;
   struct vki_in_addr sin_addr ;
   unsigned char __pad[((16U - sizeof(short )) - sizeof(unsigned short )) - sizeof(struct vki_in_addr )] ;
};
union __anonunion_vki_in6_u_86 {
   __vki_u8 u6_addr8[16] ;
   __vki_u16 u6_addr16[8] ;
   __vki_u32 u6_addr32[4] ;
};
struct vki_in6_addr {
   union __anonunion_vki_in6_u_86 vki_in6_u ;
};
struct vki_sockaddr_in6 {
   unsigned short sin6_family ;
   __vki_u16 sin6_port ;
   __vki_u32 sin6_flowinfo ;
   struct vki_in6_addr sin6_addr ;
   __vki_u32 sin6_scope_id ;
};
struct vki_sockaddr_un {
   vki_sa_family_t sun_family ;
   char sun_path[108] ;
};
struct vki_ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
union __anonunion_ifs_ifsu_87 {
   void *raw_hdlc ;
   void *cisco ;
   void *fr ;
   void *fr_pvc ;
   void *fr_pvc_info ;
   void *sync ;
   void *te1 ;
};
struct vki_if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_87 ifs_ifsu ;
};
union __anonunion_ifr_ifrn_88 {
   char ifrn_name[16] ;
};
union __anonunion_ifr_ifru_89 {
   struct vki_sockaddr ifru_addr ;
   struct vki_sockaddr ifru_dstaddr ;
   struct vki_sockaddr ifru_broadaddr ;
   struct vki_sockaddr ifru_netmask ;
   struct vki_sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct vki_ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   void *ifru_data ;
   struct vki_if_settings ifru_settings ;
};
struct vki_ifreq {
   union __anonunion_ifr_ifrn_88 ifr_ifrn ;
   union __anonunion_ifr_ifru_89 ifr_ifru ;
};
union __anonunion_ifc_ifcu_90 {
   char *ifcu_buf ;
   struct vki_ifreq *ifcu_req ;
};
struct vki_ifconf {
   int ifc_len ;
   union __anonunion_ifc_ifcu_90 ifc_ifcu ;
};
struct vki_arpreq {
   struct vki_sockaddr arp_pa ;
   struct vki_sockaddr arp_ha ;
   int arp_flags ;
   struct vki_sockaddr arp_netmask ;
   char arp_dev[16] ;
};
struct vki_rtentry {
   unsigned long rt_pad1 ;
   struct vki_sockaddr rt_dst ;
   struct vki_sockaddr rt_gateway ;
   struct vki_sockaddr rt_genmask ;
   unsigned short rt_flags ;
   short rt_pad2 ;
   unsigned long rt_pad3 ;
   void *rt_pad4 ;
   short rt_metric ;
   char *rt_dev ;
   unsigned long rt_mtu ;
   unsigned long rt_window ;
   unsigned short rt_irtt ;
};
typedef __vki_s32 vki_sctp_assoc_t;
enum vki_sctp_optname {
    VKI_SCTP_RTOINFO = 0,
    VKI_SCTP_ASSOCINFO = 1,
    VKI_SCTP_INITMSG = 2,
    VKI_SCTP_NODELAY = 3,
    VKI_SCTP_AUTOCLOSE = 4,
    VKI_SCTP_SET_PEER_PRIMARY_ADDR = 5,
    VKI_SCTP_PRIMARY_ADDR = 6,
    VKI_SCTP_ADAPTION_LAYER = 7,
    VKI_SCTP_DISABLE_FRAGMENTS = 8,
    VKI_SCTP_PEER_ADDR_PARAMS = 9,
    VKI_SCTP_DEFAULT_SEND_PARAM = 10,
    VKI_SCTP_EVENTS = 11,
    VKI_SCTP_I_WANT_MAPPED_V4_ADDR = 12,
    VKI_SCTP_MAXSEG = 13,
    VKI_SCTP_STATUS = 14,
    VKI_SCTP_GET_PEER_ADDR_INFO = 15,
    VKI_SCTP_SOCKOPT_BINDX_ADD = 100,
    VKI_SCTP_SOCKOPT_BINDX_REM = 101,
    VKI_SCTP_SOCKOPT_PEELOFF = 102,
    VKI_SCTP_GET_PEER_ADDRS_NUM = 103,
    VKI_SCTP_GET_PEER_ADDRS = 104,
    VKI_SCTP_GET_LOCAL_ADDRS_NUM = 105,
    VKI_SCTP_GET_LOCAL_ADDRS = 106,
    VKI_SCTP_SOCKOPT_CONNECTX = 107
} ;
struct vki_sctp_getaddrs {
   vki_sctp_assoc_t assoc_id ;
   int addr_num ;
   struct vki_sockaddr *addrs ;
};
struct vki_rusage {
   struct vki_timeval ru_utime ;
   struct vki_timeval ru_stime ;
   long ru_maxrss ;
   long ru_ixrss ;
   long ru_idrss ;
   long ru_isrss ;
   long ru_minflt ;
   long ru_majflt ;
   long ru_nswap ;
   long ru_inblock ;
   long ru_oublock ;
   long ru_msgsnd ;
   long ru_msgrcv ;
   long ru_nsignals ;
   long ru_nvcsw ;
   long ru_nivcsw ;
};
struct vki_rlimit {
   unsigned long rlim_cur ;
   unsigned long rlim_max ;
};
struct vki_rlimit64 {
   __vki_u64 rlim_cur ;
   __vki_u64 rlim_max ;
};
struct vki_elf_siginfo {
   int si_signo ;
   int si_code ;
   int si_errno ;
};
struct vki_elf_prstatus {
   struct vki_elf_siginfo pr_info ;
   short pr_cursig ;
   unsigned long pr_sigpend ;
   unsigned long pr_sighold ;
   vki_pid_t pr_pid ;
   vki_pid_t pr_ppid ;
   vki_pid_t pr_pgrp ;
   vki_pid_t pr_sid ;
   struct vki_timeval pr_utime ;
   struct vki_timeval pr_stime ;
   struct vki_timeval pr_cutime ;
   struct vki_timeval pr_cstime ;
   vki_elf_gregset_t pr_reg ;
   int pr_fpvalid ;
};
struct vki_elf_prpsinfo {
   char pr_state ;
   char pr_sname ;
   char pr_zomb ;
   char pr_nice ;
   unsigned long pr_flag ;
   __vki_kernel_uid_t pr_uid ;
   __vki_kernel_gid_t pr_gid ;
   vki_pid_t pr_pid ;
   vki_pid_t pr_ppid ;
   vki_pid_t pr_pgrp ;
   vki_pid_t pr_sid ;
   char pr_fname[16] ;
   char pr_psargs[80] ;
};
struct vki_epoll_event {
   __vki_u32 events ;
   __vki_u64 data ;
};
struct vki_mq_attr {
   long mq_flags ;
   long mq_maxmsg ;
   long mq_msgsize ;
   long mq_curmsgs ;
   long __reserved[4] ;
};
struct vki_new_utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
   char domainname[65] ;
};
struct vki_mii_ioctl_data {
   vki_u16 phy_id ;
   vki_u16 reg_num ;
   vki_u16 val_in ;
   vki_u16 val_out ;
};
struct __vki_user_cap_header_struct {
   __vki_u32 version ;
   int pid ;
};
typedef struct __vki_user_cap_header_struct *vki_cap_user_header_t;
struct __vki_user_cap_data_struct {
   __vki_u32 effective ;
   __vki_u32 permitted ;
   __vki_u32 inheritable ;
};
typedef struct __vki_user_cap_data_struct *vki_cap_user_data_t;
struct vki_ipc_perm {
   __vki_kernel_key_t key ;
   __vki_kernel_uid_t uid ;
   __vki_kernel_gid_t gid ;
   __vki_kernel_uid_t cuid ;
   __vki_kernel_gid_t cgid ;
   __vki_kernel_mode_t mode ;
   unsigned short seq ;
};
struct vki_semid_ds {
   struct vki_ipc_perm sem_perm ;
   __vki_kernel_time_t sem_otime ;
   __vki_kernel_time_t sem_ctime ;
   void *sem_base ;
   void *sem_pending ;
   void **sem_pending_last ;
   void *undo ;
   unsigned short sem_nsems ;
};
struct vki_sembuf {
   unsigned short sem_num ;
   short sem_op ;
   short sem_flg ;
};
struct vki_seminfo;
union vki_semun {
   int val ;
   struct vki_semid_ds *buf ;
   unsigned short *array ;
   struct vki_seminfo *__buf ;
   void *__pad ;
};
struct vki_seminfo {
   int semmap ;
   int semmni ;
   int semmns ;
   int semmnu ;
   int semmsl ;
   int semopm ;
   int semume ;
   int semusz ;
   int semvmx ;
   int semaem ;
};
struct vki_robust_list {
   struct vki_robust_list *next ;
};
struct vki_robust_list_head {
   struct vki_robust_list list ;
   long futex_offset ;
   struct vki_robust_list *list_op_pending ;
};
struct vki_dirent {
   long d_ino ;
   __vki_kernel_off_t d_off ;
   unsigned short d_reclen ;
   char d_name[256] ;
};
struct __vki_sysctl_args {
   int *name ;
   int nlen ;
   void *oldval ;
   vki_size_t *oldlenp ;
   void *newval ;
   vki_size_t newlen ;
   unsigned long __unused[4] ;
};
typedef unsigned long vki_aio_context_t;
enum __anonenum_91 {
    VKI_IOCB_CMD_PREAD = 0,
    VKI_IOCB_CMD_PWRITE = 1,
    VKI_IOCB_CMD_FSYNC = 2,
    VKI_IOCB_CMD_FDSYNC = 3,
    VKI_IOCB_CMD_PREADV = 7,
    VKI_IOCB_CMD_PWRITEV = 8
} ;
struct vki_io_event {
   __vki_u64 data ;
   __vki_u64 obj ;
   __vki_s64 result ;
   __vki_s64 result2 ;
};
struct vki_iocb {
   __vki_u64 aio_data ;
   __vki_u32 aio_key ;
   __vki_u32 aio_reserved1 ;
   __vki_u16 aio_lio_opcode ;
   __vki_s16 aio_reqprio ;
   __vki_u32 aio_fildes ;
   __vki_u64 aio_buf ;
   __vki_u64 aio_nbytes ;
   __vki_s64 aio_offset ;
   __vki_u64 aio_reserved2 ;
   __vki_u64 aio_reserved3 ;
};
struct vki_aio_ring {
   unsigned int id ;
   unsigned int nr ;
   unsigned int head ;
   unsigned int tail ;
   unsigned int magic ;
   unsigned int compat_features ;
   unsigned int incompat_features ;
   unsigned int header_length ;
   struct vki_io_event io_events[0] ;
};
struct vki_msg;
struct vki_msqid_ds {
   struct vki_ipc_perm msg_perm ;
   struct vki_msg *msg_first ;
   struct vki_msg *msg_last ;
   __vki_kernel_time_t msg_stime ;
   __vki_kernel_time_t msg_rtime ;
   __vki_kernel_time_t msg_ctime ;
   unsigned long msg_lcbytes ;
   unsigned long msg_lqbytes ;
   unsigned short msg_cbytes ;
   unsigned short msg_qnum ;
   unsigned short msg_qbytes ;
   __vki_kernel_ipc_pid_t msg_lspid ;
   __vki_kernel_ipc_pid_t msg_lrpid ;
};
struct vki_msgbuf {
   long mtype ;
   char mtext[1] ;
};
struct vki_msginfo {
   int msgpool ;
   int msgmap ;
   int msgmax ;
   int msgmnb ;
   int msgmni ;
   int msgssz ;
   int msgtql ;
   unsigned short msgseg ;
};
struct vki_shmid_ds {
   struct vki_ipc_perm shm_perm ;
   int shm_segsz ;
   __vki_kernel_time_t shm_atime ;
   __vki_kernel_time_t shm_dtime ;
   __vki_kernel_time_t shm_ctime ;
   __vki_kernel_ipc_pid_t shm_cpid ;
   __vki_kernel_ipc_pid_t shm_lpid ;
   unsigned short shm_nattch ;
   unsigned short shm_unused ;
   void *shm_unused2 ;
   void *shm_unused3 ;
};
struct vki_shminfo {
   int shmmax ;
   int shmmin ;
   int shmmni ;
   int shmseg ;
   int shmall ;
};
struct vki_shm_info {
   int used_ids ;
   unsigned long shm_tot ;
   unsigned long shm_rss ;
   unsigned long shm_swp ;
   unsigned long swap_attempts ;
   unsigned long swap_successes ;
};
struct vki_rtc_time {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
};
struct __anonstruct_vki_isdn_net_ioctl_phone_92 {
   char name[10] ;
   char phone[32] ;
   int outgoing ;
};
typedef struct __anonstruct_vki_isdn_net_ioctl_phone_92 vki_isdn_net_ioctl_phone;
struct vki_ppdev_frob_struct {
   unsigned char mask ;
   unsigned char val ;
};
struct vki_sg_io_hdr {
   int interface_id ;
   int dxfer_direction ;
   unsigned char cmd_len ;
   unsigned char mx_sb_len ;
   unsigned short iovec_count ;
   unsigned int dxfer_len ;
   void *dxferp ;
   unsigned char *cmdp ;
   void *sbp ;
   unsigned int timeout ;
   unsigned int flags ;
   int pack_id ;
   void *usr_ptr ;
   unsigned char status ;
   unsigned char masked_status ;
   unsigned char msg_status ;
   unsigned char sb_len_wr ;
   unsigned short host_status ;
   unsigned short driver_status ;
   int resid ;
   unsigned int duration ;
   unsigned int info ;
};
typedef struct vki_sg_io_hdr vki_sg_io_hdr_t;
struct vki_sg_scsi_id {
   int host_no ;
   int channel ;
   int scsi_id ;
   int lun ;
   int scsi_type ;
   short h_cmd_per_lun ;
   short d_queue_depth ;
   int unused[2] ;
};
typedef struct vki_sg_scsi_id vki_sg_scsi_id_t;
struct vki_scsi_idlun {
   __vki_u32 dev_id ;
   __vki_u32 host_unique_id ;
};
struct vki_cdrom_msf0 {
   __vki_u8 minute ;
   __vki_u8 second ;
   __vki_u8 frame ;
};
union vki_cdrom_addr {
   struct vki_cdrom_msf0 msf ;
   int lba ;
};
struct vki_cdrom_msf {
   __vki_u8 cdmsf_min0 ;
   __vki_u8 cdmsf_sec0 ;
   __vki_u8 cdmsf_frame0 ;
   __vki_u8 cdmsf_min1 ;
   __vki_u8 cdmsf_sec1 ;
   __vki_u8 cdmsf_frame1 ;
};
struct vki_cdrom_tochdr {
   __vki_u8 cdth_trk0 ;
   __vki_u8 cdth_trk1 ;
};
struct vki_cdrom_volctrl {
   __vki_u8 channel0 ;
   __vki_u8 channel1 ;
   __vki_u8 channel2 ;
   __vki_u8 channel3 ;
};
struct vki_cdrom_subchnl {
   __vki_u8 cdsc_format ;
   __vki_u8 cdsc_audiostatus ;
   __vki_u8 cdsc_adr : 4 ;
   __vki_u8 cdsc_ctrl : 4 ;
   __vki_u8 cdsc_trk ;
   __vki_u8 cdsc_ind ;
   union vki_cdrom_addr cdsc_absaddr ;
   union vki_cdrom_addr cdsc_reladdr ;
};
struct vki_cdrom_tocentry {
   __vki_u8 cdte_track ;
   __vki_u8 cdte_adr : 4 ;
   __vki_u8 cdte_ctrl : 4 ;
   __vki_u8 cdte_format ;
   union vki_cdrom_addr cdte_addr ;
   __vki_u8 cdte_datamode ;
};
struct vki_cdrom_read {
   int cdread_lba ;
   char *cdread_bufaddr ;
   int cdread_buflen ;
};
struct vki_cdrom_read_audio {
   union vki_cdrom_addr addr ;
   __vki_u8 addr_format ;
   int nframes ;
   __vki_u8 *buf ;
};
struct vki_cdrom_multisession {
   union vki_cdrom_addr addr ;
   __vki_u8 xa_flag ;
   __vki_u8 addr_format ;
};
struct vki_cdrom_mcn {
   __vki_u8 medium_catalog_number[14] ;
};
struct vki_cdrom_generic_command {
   unsigned char cmd[12] ;
   unsigned char *buffer ;
   unsigned int buflen ;
   int stat ;
   void *sense ;
   unsigned char data_direction ;
   int quiet ;
   int timeout ;
   void *reserved[1] ;
};
struct vki_audio_buf_info {
   int fragments ;
   int fragstotal ;
   int fragsize ;
   int bytes ;
};
typedef struct vki_audio_buf_info vki_audio_buf_info;
struct vki_hd_geometry {
   unsigned char heads ;
   unsigned char sectors ;
   unsigned short cylinders ;
   unsigned long start ;
};
struct vki_fb_fix_screeninfo {
   char id[16] ;
   unsigned long smem_start ;
   __vki_u32 smem_len ;
   __vki_u32 type ;
   __vki_u32 type_aux ;
   __vki_u32 visual ;
   __vki_u16 xpanstep ;
   __vki_u16 ypanstep ;
   __vki_u16 ywrapstep ;
   __vki_u32 line_length ;
   unsigned long mmio_start ;
   __vki_u32 mmio_len ;
   __vki_u32 accel ;
   __vki_u16 reserved[3] ;
};
struct vki_fb_bitfield {
   __vki_u32 offset ;
   __vki_u32 length ;
   __vki_u32 msb_right ;
};
struct vki_fb_var_screeninfo {
   __vki_u32 xres ;
   __vki_u32 yres ;
   __vki_u32 xres_virtual ;
   __vki_u32 yres_virtual ;
   __vki_u32 xoffset ;
   __vki_u32 yoffset ;
   __vki_u32 bits_per_pixel ;
   __vki_u32 grayscale ;
   struct vki_fb_bitfield red ;
   struct vki_fb_bitfield green ;
   struct vki_fb_bitfield blue ;
   struct vki_fb_bitfield transp ;
   __vki_u32 nonstd ;
   __vki_u32 activate ;
   __vki_u32 height ;
   __vki_u32 width ;
   __vki_u32 accel_flags ;
   __vki_u32 pixclock ;
   __vki_u32 left_margin ;
   __vki_u32 right_margin ;
   __vki_u32 upper_margin ;
   __vki_u32 lower_margin ;
   __vki_u32 hsync_len ;
   __vki_u32 vsync_len ;
   __vki_u32 sync ;
   __vki_u32 vmode ;
   __vki_u32 rotate ;
   __vki_u32 reserved[5] ;
};
struct vki_consolefontdesc {
   unsigned short charcount ;
   unsigned short charheight ;
   char *chardata ;
};
struct vki_unipair {
   unsigned short unicode ;
   unsigned short fontpos ;
};
struct vki_unimapdesc {
   unsigned short entry_ct ;
   struct vki_unipair *entries ;
};
struct vki_unimapinit {
   unsigned short advised_hashsize ;
   unsigned short advised_hashstep ;
   unsigned short advised_hashlevel ;
};
struct vki_kbentry {
   unsigned char kb_table ;
   unsigned char kb_index ;
   unsigned short kb_value ;
};
struct vki_kbsentry {
   unsigned char kb_func ;
   unsigned char kb_string[512] ;
};
struct vki_kbdiacr {
   unsigned char diacr ;
   unsigned char base ;
   unsigned char result ;
};
struct vki_kbdiacrs {
   unsigned int kb_cnt ;
   struct vki_kbdiacr kbdiacr[256] ;
};
struct vki_kbkeycode {
   unsigned int scancode ;
   unsigned int keycode ;
};
struct vki_kbd_repeat {
   int delay ;
   int period ;
};
struct vki_console_font_op {
   unsigned int op ;
   unsigned int flags ;
   unsigned int width ;
   unsigned int height ;
   unsigned int charcount ;
   unsigned char *data ;
};
typedef __vki_kernel_uid32_t vki_qid_t;
struct __anonstruct_94 {
   int  : 0 ;
};
struct __anonstruct_95 {
   int  : 0 ;
};
enum __anonenum_93 {
    VKI_SNDRV_PCM_IOCTL_HW_FREE = 16658,
    VKI_SNDRV_PCM_IOCTL_HWSYNC = 16674,
    VKI_SNDRV_PCM_IOCTL_PREPARE = 16704,
    VKI_SNDRV_PCM_IOCTL_RESET = 16705,
    VKI_SNDRV_PCM_IOCTL_START = 16706,
    VKI_SNDRV_PCM_IOCTL_DROP = 16707,
    VKI_SNDRV_PCM_IOCTL_DRAIN = 16708,
    VKI_SNDRV_PCM_IOCTL_PAUSE = 1074020677,
    VKI_SNDRV_PCM_IOCTL_RESUME = 16711,
    VKI_SNDRV_PCM_IOCTL_XRUN = 16712,
    VKI_SNDRV_PCM_IOCTL_LINK = 1074020704,
    VKI_SNDRV_PCM_IOCTL_UNLINK = 16737
} ;
enum __anonenum_96 {
    VKI_SNDRV_TIMER_IOCTL_START = 21664,
    VKI_SNDRV_TIMER_IOCTL_STOP = 21665,
    VKI_SNDRV_TIMER_IOCTL_CONTINUE = 21666,
    VKI_SNDRV_TIMER_IOCTL_PAUSE = 21667
} ;
struct vki_serial_icounter_struct {
   int cts ;
   int dsr ;
   int rng ;
   int dcd ;
   int rx ;
   int tx ;
   int frame ;
   int overrun ;
   int parity ;
   int brk ;
   int buf_overrun ;
   int reserved[9] ;
};
struct vki_vt_mode {
   char mode ;
   char waitv ;
   short relsig ;
   short acqsig ;
   short frsig ;
};
struct vki_vt_stat {
   unsigned short v_active ;
   unsigned short v_signal ;
   unsigned short v_state ;
};
struct vki_vt_sizes {
   unsigned short v_rows ;
   unsigned short v_cols ;
   unsigned short v_scrollsize ;
};
struct vki_vt_consize {
   unsigned short v_rows ;
   unsigned short v_cols ;
   unsigned short v_vlin ;
   unsigned short v_clin ;
   unsigned short v_vcol ;
   unsigned short v_ccol ;
};
struct vki_usbdevfs_ctrltransfer {
   __vki_u8 bRequestType ;
   __vki_u8 bRequest ;
   __vki_u16 wValue ;
   __vki_u16 wIndex ;
   __vki_u16 wLength ;
   __vki_u32 timeout ;
   void *data ;
};
struct vki_usbdevfs_bulktransfer {
   unsigned int ep ;
   unsigned int len ;
   unsigned int timeout ;
   void *data ;
};
struct vki_usbdevfs_getdriver {
   unsigned int interface ;
   char driver[256] ;
};
struct vki_usbdevfs_connectinfo {
   unsigned int devnum ;
   unsigned char slow ;
};
struct vki_usbdevfs_iso_packet_desc {
   unsigned int length ;
   unsigned int actual_length ;
   unsigned int status ;
};
struct vki_usbdevfs_urb {
   unsigned char type ;
   unsigned char endpoint ;
   int status ;
   unsigned int flags ;
   void *buffer ;
   int buffer_length ;
   int actual_length ;
   int start_frame ;
   int number_of_packets ;
   int error_count ;
   unsigned int signr ;
   void *usercontext ;
   struct vki_usbdevfs_iso_packet_desc iso_frame_desc[0] ;
};
struct vki_usbdevfs_ioctl {
   int ifno ;
   int ioctl_code ;
   void *data ;
};
struct vki_usbdevfs_setuppacket {
   __vki_u8 bRequestType ;
   __vki_u8 bRequest ;
   __vki_u16 wValue ;
   __vki_u16 wIndex ;
   __vki_u16 wLength ;
};
typedef vki_int32_t vki_key_serial_t;
typedef vki_uint32_t vki_key_perm_t;
struct vki_iw_param {
   __vki_s32 value ;
   __vki_u8 fixed ;
   __vki_u8 disabled ;
   __vki_u16 flags ;
};
struct vki_iw_point {
   void *pointer ;
   __vki_u16 length ;
   __vki_u16 flags ;
};
struct vki_iw_freq {
   __vki_s32 m ;
   __vki_s16 e ;
   __vki_u8 i ;
   __vki_u8 flags ;
};
struct vki_iw_quality {
   __vki_u8 qual ;
   __vki_u8 level ;
   __vki_u8 noise ;
   __vki_u8 updated ;
};
union vki_iwreq_data {
   char name[16] ;
   struct vki_iw_point essid ;
   struct vki_iw_param nwid ;
   struct vki_iw_freq freq ;
   struct vki_iw_param sens ;
   struct vki_iw_param bitrate ;
   struct vki_iw_param txpower ;
   struct vki_iw_param rts ;
   struct vki_iw_param frag ;
   __vki_u32 mode ;
   struct vki_iw_param retry ;
   struct vki_iw_point encoding ;
   struct vki_iw_param power ;
   struct vki_iw_quality qual ;
   struct vki_sockaddr ap_addr ;
   struct vki_sockaddr addr ;
   struct vki_iw_param param ;
   struct vki_iw_point data ;
};
union __anonunion_ifr_ifrn_97 {
   char ifrn_name[16] ;
};
struct vki_iwreq {
   union __anonunion_ifr_ifrn_97 ifr_ifrn ;
   union vki_iwreq_data u ;
};
union __anonunion____missing_field_name_98 {
   __vki_u64 sample_period ;
   __vki_u64 sample_freq ;
};
union __anonunion____missing_field_name_99 {
   __vki_u32 wakeup_events ;
   __vki_u32 wakeup_watermark ;
};
union __anonunion____missing_field_name_100 {
   __vki_u64 bp_addr ;
   __vki_u64 config1 ;
};
union __anonunion____missing_field_name_101 {
   __vki_u64 bp_len ;
   __vki_u64 config2 ;
};
struct vki_perf_event_attr {
   __vki_u32 type ;
   __vki_u32 size ;
   __vki_u64 config ;
   union __anonunion____missing_field_name_98 __annonCompField1 ;
   __vki_u64 sample_type ;
   __vki_u64 read_format ;
   __vki_u64 disabled : 1 ;
   __vki_u64 inherit : 1 ;
   __vki_u64 pinned : 1 ;
   __vki_u64 exclusive : 1 ;
   __vki_u64 exclude_user : 1 ;
   __vki_u64 exclude_kernel : 1 ;
   __vki_u64 exclude_hv : 1 ;
   __vki_u64 exclude_idle : 1 ;
   __vki_u64 mmap : 1 ;
   __vki_u64 comm : 1 ;
   __vki_u64 freq : 1 ;
   __vki_u64 inherit_stat : 1 ;
   __vki_u64 enable_on_exec : 1 ;
   __vki_u64 task : 1 ;
   __vki_u64 watermark : 1 ;
   __vki_u64 precise_ip : 2 ;
   __vki_u64 mmap_data : 1 ;
   __vki_u64 sample_id_all : 1 ;
   __vki_u64 __reserved_1 : 45 ;
   union __anonunion____missing_field_name_99 __annonCompField2 ;
   __vki_u32 bp_type ;
   union __anonunion____missing_field_name_100 __annonCompField3 ;
   union __anonunion____missing_field_name_101 __annonCompField4 ;
};
struct vki_getcpu_cache {
   unsigned long blob[128U / sizeof(long )] ;
};
typedef int __jmp_buf[6];
typedef int __sig_atomic_t;
struct __anonstruct___sigset_t_102 {
   unsigned long __val[1024U / (8U * sizeof(unsigned long ))] ;
};
typedef struct __anonstruct___sigset_t_102 __sigset_t;
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
typedef struct __jmp_buf_tag jmp_buf[1];
typedef struct __jmp_buf_tag sigjmp_buf[1];
enum ThreadStatus {
    VgTs_Empty = 0,
    VgTs_Init = 1,
    VgTs_Runnable = 2,
    VgTs_WaitSys = 3,
    VgTs_Yielding = 4,
    VgTs_Zombie = 5
} ;
typedef enum ThreadStatus ThreadStatus;
enum __anonenum_VgSchedReturnCode_103 {
    VgSrc_None = 0,
    VgSrc_ExitThread = 1,
    VgSrc_ExitProcess = 2,
    VgSrc_FatalSig = 3
} ;
typedef enum __anonenum_VgSchedReturnCode_103 VgSchedReturnCode;
typedef VexGuestX86State VexGuestArchState;
struct SyscallStatus;
struct SyscallStatus;
struct SyscallArgs;
struct SyscallArgs;
struct __anonstruct_ThreadArchState_104 {
   VexGuestArchState vex  __attribute__((__aligned__(16))) ;
   VexGuestArchState vex_shadow1  __attribute__((__aligned__(16))) ;
   VexGuestArchState vex_shadow2  __attribute__((__aligned__(16))) ;
   UChar vex_spill[4096]  __attribute__((__aligned__(16))) ;
};
typedef struct __anonstruct_ThreadArchState_104 ThreadArchState;
struct __anonstruct_ThreadOSstate_105 {
   Int lwpid ;
   Int threadgroup ;
   ThreadId parent ;
   Addr valgrind_stack_base ;
   Addr valgrind_stack_init_SP ;
   Word exitcode ;
   Int fatalsig ;
};
typedef struct __anonstruct_ThreadOSstate_105 ThreadOSstate;
struct SigQueue;
struct __anonstruct_ThreadState_106 {
   ThreadId tid ;
   ThreadStatus status ;
   VgSchedReturnCode exitreason ;
   ThreadArchState arch ;
   vki_sigset_t sig_mask ;
   vki_sigset_t tmp_sig_mask ;
   struct SigQueue *sig_queue ;
   SizeT client_stack_szB ;
   Addr client_stack_highest_word ;
   vki_stack_t altstack ;
   ThreadOSstate os_state ;
   UInt err_disablement_level ;
   Bool sched_jmpbuf_valid ;
   UInt sched_jmpbuf[9] ;
};
typedef struct __anonstruct_ThreadState_106 ThreadState;
enum __anonenum_SegKind_107 {
    SkFree = 0,
    SkAnonC = 1,
    SkAnonV = 2,
    SkFileC = 3,
    SkFileV = 4,
    SkShmC = 5,
    SkResvn = 6
} ;
typedef enum __anonenum_SegKind_107 SegKind;
enum __anonenum_ShrinkMode_108 {
    SmLower = 0,
    SmFixed = 1,
    SmUpper = 2
} ;
typedef enum __anonenum_ShrinkMode_108 ShrinkMode;
struct __anonstruct_NSegment_109 {
   SegKind kind ;
   Addr start ;
   Addr end ;
   ShrinkMode smode ;
   ULong dev ;
   ULong ino ;
   Off64T offset ;
   UInt mode ;
   Int fnIdx ;
   Bool hasR ;
   Bool hasW ;
   Bool hasX ;
   Bool hasT ;
   Bool isCH ;
   Bool mark ;
};
typedef struct __anonstruct_NSegment_109 NSegment;
enum __anonenum_rkind_111 {
    MFixed = 0,
    MHint = 1,
    MAny = 2
} ;
struct __anonstruct_MapRequest_110 {
   enum __anonenum_rkind_111 rkind ;
   Addr start ;
   Addr len ;
};
typedef struct __anonstruct_MapRequest_110 MapRequest;
struct __anonstruct_VgStack_112 {
   HChar bytes[1064960] ;
};
typedef struct __anonstruct_VgStack_112 VgStack;
enum __anonenum_Vg_FnNameKind_113 {
    Vg_FnNameNormal = 0,
    Vg_FnNameMain = 1,
    Vg_FnNameBelowMain = 2
} ;
typedef enum __anonenum_Vg_FnNameKind_113 Vg_FnNameKind;
struct __anonstruct_StackBlock_114 {
   PtrdiffT base ;
   SizeT szB ;
   Bool spRel ;
   Bool isVec ;
   HChar name[16] ;
};
typedef struct __anonstruct_StackBlock_114 StackBlock;
struct __anonstruct_GlobalBlock_115 {
   Addr addr ;
   SizeT szB ;
   Bool isVec ;
   HChar name[16] ;
   HChar soname[16] ;
};
typedef struct __anonstruct_GlobalBlock_115 GlobalBlock;
struct _DebugInfo;
typedef struct _DebugInfo DebugInfo;
enum __anonenum_VgSectKind_116 {
    Vg_SectUnknown = 0,
    Vg_SectText = 1,
    Vg_SectData = 2,
    Vg_SectBSS = 3,
    Vg_SectGOT = 4,
    Vg_SectPLT = 5,
    Vg_SectGOTPLT = 6,
    Vg_SectOPD = 7
} ;
typedef enum __anonenum_VgSectKind_116 VgSectKind;
struct __anonstruct_D3UnwindRegs_117 {
   Addr xip ;
   Addr xsp ;
   Addr xbp ;
};
typedef struct __anonstruct_D3UnwindRegs_117 D3UnwindRegs;
struct __anonstruct_FastCacheEntry_118 {
   Addr guest ;
   Addr host ;
};
typedef struct __anonstruct_FastCacheEntry_118 FastCacheEntry;
struct _BBProfEntry {
   Addr64 addr ;
   ULong score ;
};
typedef struct _BBProfEntry BBProfEntry;
struct _XArray;
typedef struct _XArray XArray;
struct vg_stat {
   ULong dev ;
   ULong ino ;
   ULong nlink ;
   UInt mode ;
   UInt uid ;
   UInt gid ;
   ULong rdev ;
   Long size ;
   ULong blksize ;
   ULong blocks ;
   ULong atime ;
   ULong atime_nsec ;
   ULong mtime ;
   ULong mtime_nsec ;
   ULong ctime ;
   ULong ctime_nsec ;
};
enum __anonenum_VgMsgKind_119 {
    Vg_FailMsg = 0,
    Vg_UserMsg = 1,
    Vg_DebugMsg = 2,
    Vg_ClientMsg = 3
} ;
typedef enum __anonenum_VgMsgKind_119 VgMsgKind;
struct __anonstruct_OutputSink_120 {
   Int fd ;
   Bool is_socket ;
};
typedef struct __anonstruct_OutputSink_120 OutputSink;
typedef void (*vg_atfork_t)(ThreadId  );
typedef Int ArenaId;
struct vg_mallinfo {
   int arena ;
   int ordblks ;
   int smblks ;
   int hblks ;
   int hblkhd ;
   int usmblks ;
   int fsmblks ;
   int uordblks ;
   int fordblks ;
   int keepcost ;
};
struct _ExeContext;
typedef struct _ExeContext ExeContext;
enum __anonenum_VgRes_121 {
    Vg_LowRes = 0,
    Vg_MedRes = 1,
    Vg_HighRes = 2
} ;
typedef enum __anonenum_VgRes_121 VgRes;
typedef Int ErrorKind;
struct _Error;
typedef struct _Error Error;
typedef Int SuppKind;
struct _Supp;
typedef struct _Supp Supp;
struct __anonstruct_VgCallbackClosure_122 {
   Addr64 nraddr ;
   Addr64 readdr ;
   ThreadId tid ;
};
typedef struct __anonstruct_VgCallbackClosure_122 VgCallbackClosure;
enum __anonenum_CorePart_123 {
    Vg_CoreStartup = 1,
    Vg_CoreSignal = 2,
    Vg_CoreSysCall = 3,
    Vg_CoreSysCallArgInMem = 4,
    Vg_CoreTranslate = 5,
    Vg_CoreClientReq = 6
} ;
typedef enum __anonenum_CorePart_123 CorePart;
struct __anonstruct_VgDetails_124 {
   Char *name ;
   Char *version ;
   Char *description ;
   Char *copyright_author ;
   Char *bug_reports_to ;
   UInt avg_translation_sizeB ;
};
typedef struct __anonstruct_VgDetails_124 VgDetails;
struct __anonstruct_VgNeeds_125 {
   Bool libc_freeres ;
   Bool core_errors ;
   Bool tool_errors ;
   Bool superblock_discards ;
   Bool command_line_options ;
   Bool client_requests ;
   Bool syscall_wrapper ;
   Bool sanity_checks ;
   Bool var_info ;
   Bool malloc_replacement ;
   Bool xml_output ;
   Bool final_IR_tidy_pass ;
};
typedef struct __anonstruct_VgNeeds_125 VgNeeds;
struct __anonstruct_VgToolInterface_126 {
   void (*tool_pre_clo_init)(void) ;
   void (*tool_post_clo_init)(void) ;
   IRSB *(*tool_instrument)(VgCallbackClosure * , IRSB * , VexGuestLayout * ,
                            VexGuestExtents * , IRType  , IRType  ) ;
   void (*tool_fini)(Int  ) ;
   Bool (*tool_eq_Error)(VgRes  , Error * , Error * ) ;
   void (*tool_before_pp_Error)(Error * ) ;
   void (*tool_pp_Error)(Error * ) ;
   Bool tool_show_ThreadIDs_for_errors ;
   UInt (*tool_update_extra)(Error * ) ;
   Bool (*tool_recognised_suppression)(Char * , Supp * ) ;
   Bool (*tool_read_extra_suppression_info)(Int  , Char ** , SizeT * , Supp * ) ;
   Bool (*tool_error_matches_suppression)(Error * , Supp * ) ;
   Char *(*tool_get_error_name)(Error * ) ;
   Bool (*tool_get_extra_suppression_info)(Error * , Char * , Int  ) ;
   void (*tool_discard_superblock_info)(Addr64  , VexGuestExtents  ) ;
   Bool (*tool_process_cmd_line_option)(Char * ) ;
   void (*tool_print_usage)(void) ;
   void (*tool_print_debug_usage)(void) ;
   Bool (*tool_handle_client_request)(ThreadId  , UWord * , UWord * ) ;
   void (*tool_pre_syscall)(ThreadId  , UInt  , UWord * , UInt  ) ;
   void (*tool_post_syscall)(ThreadId  , UInt  , UWord * , UInt  , SysRes  ) ;
   Bool (*tool_cheap_sanity_check)(void) ;
   Bool (*tool_expensive_sanity_check)(void) ;
   void *(*tool_malloc)(ThreadId  , SizeT  ) ;
   void *(*tool___builtin_new)(ThreadId  , SizeT  ) ;
   void *(*tool___builtin_vec_new)(ThreadId  , SizeT  ) ;
   void *(*tool_memalign)(ThreadId  , SizeT  , SizeT  ) ;
   void *(*tool_calloc)(ThreadId  , SizeT  , SizeT  ) ;
   void (*tool_free)(ThreadId  , void * ) ;
   void (*tool___builtin_delete)(ThreadId  , void * ) ;
   void (*tool___builtin_vec_delete)(ThreadId  , void * ) ;
   void *(*tool_realloc)(ThreadId  , void * , SizeT  ) ;
   SizeT (*tool_malloc_usable_size)(ThreadId  , void * ) ;
   SizeT tool_client_redzone_szB ;
   IRSB *(*tool_final_IR_tidy_pass)(IRSB * ) ;
   void (*track_new_mem_startup)(Addr  , SizeT  , Bool  , Bool  , Bool  ,
                                 ULong  ) ;
   void (*track_new_mem_stack_signal)(Addr  , SizeT  , ThreadId  ) ;
   void (*track_new_mem_brk)(Addr  , SizeT  , ThreadId  ) ;
   void (*track_new_mem_mmap)(Addr  , SizeT  , Bool  , Bool  , Bool  , ULong  ) ;
   void (*track_copy_mem_remap)(Addr src , Addr dst , SizeT  ) ;
   void (*track_change_mem_mprotect)(Addr  , SizeT  , Bool  , Bool  , Bool  ) ;
   void (*track_die_mem_stack_signal)(Addr  , SizeT  ) ;
   void (*track_die_mem_brk)(Addr  , SizeT  ) ;
   void (*track_die_mem_munmap)(Addr  , SizeT  ) ;
   void ( __attribute__((__regparm__(2))) (*track_new_mem_stack_4_w_ECU))(Addr  ,
                                                                          UInt  ) ;
   void ( __attribute__((__regparm__(2))) (*track_new_mem_stack_8_w_ECU))(Addr  ,
                                                                          UInt  ) ;
   void ( __attribute__((__regparm__(2))) (*track_new_mem_stack_12_w_ECU))(Addr  ,
                                                                           UInt  ) ;
   void ( __attribute__((__regparm__(2))) (*track_new_mem_stack_16_w_ECU))(Addr  ,
                                                                           UInt  ) ;
   void ( __attribute__((__regparm__(2))) (*track_new_mem_stack_32_w_ECU))(Addr  ,
                                                                           UInt  ) ;
   void ( __attribute__((__regparm__(2))) (*track_new_mem_stack_112_w_ECU))(Addr  ,
                                                                            UInt  ) ;
   void ( __attribute__((__regparm__(2))) (*track_new_mem_stack_128_w_ECU))(Addr  ,
                                                                            UInt  ) ;
   void ( __attribute__((__regparm__(2))) (*track_new_mem_stack_144_w_ECU))(Addr  ,
                                                                            UInt  ) ;
   void ( __attribute__((__regparm__(2))) (*track_new_mem_stack_160_w_ECU))(Addr  ,
                                                                            UInt  ) ;
   void (*track_new_mem_stack_w_ECU)(Addr  , SizeT  , UInt  ) ;
   void ( __attribute__((__regparm__(1))) (*track_new_mem_stack_4))(Addr  ) ;
   void ( __attribute__((__regparm__(1))) (*track_new_mem_stack_8))(Addr  ) ;
   void ( __attribute__((__regparm__(1))) (*track_new_mem_stack_12))(Addr  ) ;
   void ( __attribute__((__regparm__(1))) (*track_new_mem_stack_16))(Addr  ) ;
   void ( __attribute__((__regparm__(1))) (*track_new_mem_stack_32))(Addr  ) ;
   void ( __attribute__((__regparm__(1))) (*track_new_mem_stack_112))(Addr  ) ;
   void ( __attribute__((__regparm__(1))) (*track_new_mem_stack_128))(Addr  ) ;
   void ( __attribute__((__regparm__(1))) (*track_new_mem_stack_144))(Addr  ) ;
   void ( __attribute__((__regparm__(1))) (*track_new_mem_stack_160))(Addr  ) ;
   void (*track_new_mem_stack)(Addr  , SizeT  ) ;
   void ( __attribute__((__regparm__(1))) (*track_die_mem_stack_4))(Addr  ) ;
   void ( __attribute__((__regparm__(1))) (*track_die_mem_stack_8))(Addr  ) ;
   void ( __attribute__((__regparm__(1))) (*track_die_mem_stack_12))(Addr  ) ;
   void ( __attribute__((__regparm__(1))) (*track_die_mem_stack_16))(Addr  ) ;
   void ( __attribute__((__regparm__(1))) (*track_die_mem_stack_32))(Addr  ) ;
   void ( __attribute__((__regparm__(1))) (*track_die_mem_stack_112))(Addr  ) ;
   void ( __attribute__((__regparm__(1))) (*track_die_mem_stack_128))(Addr  ) ;
   void ( __attribute__((__regparm__(1))) (*track_die_mem_stack_144))(Addr  ) ;
   void ( __attribute__((__regparm__(1))) (*track_die_mem_stack_160))(Addr  ) ;
   void (*track_die_mem_stack)(Addr  , SizeT  ) ;
   void (*track_ban_mem_stack)(Addr  , SizeT  ) ;
   void (*track_pre_mem_read)(CorePart  , ThreadId  , Char * , Addr  , SizeT  ) ;
   void (*track_pre_mem_read_asciiz)(CorePart  , ThreadId  , Char * , Addr  ) ;
   void (*track_pre_mem_write)(CorePart  , ThreadId  , Char * , Addr  , SizeT  ) ;
   void (*track_post_mem_write)(CorePart  , ThreadId  , Addr  , SizeT  ) ;
   void (*track_pre_reg_read)(CorePart  , ThreadId  , Char * , PtrdiffT  ,
                              SizeT  ) ;
   void (*track_post_reg_write)(CorePart  , ThreadId  , PtrdiffT  , SizeT  ) ;
   void (*track_post_reg_write_clientcall_return)(ThreadId  , PtrdiffT  ,
                                                  SizeT  , Addr  ) ;
   void (*track_start_client_code)(ThreadId  , ULong  ) ;
   void (*track_stop_client_code)(ThreadId  , ULong  ) ;
   void (*track_pre_thread_ll_create)(ThreadId  , ThreadId  ) ;
   void (*track_pre_thread_first_insn)(ThreadId  ) ;
   void (*track_pre_thread_ll_exit)(ThreadId  ) ;
   void (*track_pre_deliver_signal)(ThreadId  , Int sigNo , Bool  ) ;
   void (*track_post_deliver_signal)(ThreadId  , Int sigNo ) ;
};
typedef struct __anonstruct_VgToolInterface_126 VgToolInterface;
enum __anonenum_VgVgdb_127 {
    Vg_VgdbNo = 0,
    Vg_VgdbYes = 1,
    Vg_VgdbFull = 2
} ;
typedef enum __anonenum_VgVgdb_127 VgVgdb;
enum FairSchedType {
    disable_fair_sched = 0,
    enable_fair_sched = 1,
    try_fair_sched = 2
} ;
enum __anonenum_VgSmc_128 {
    Vg_SmcNone = 0,
    Vg_SmcStack = 1,
    Vg_SmcAll = 2,
    Vg_SmcAllNonFile = 3
} ;
typedef enum __anonenum_VgSmc_128 VgSmc;
struct SyscallArgs {
   Word sysno ;
   UWord arg1 ;
   UWord arg2 ;
   UWord arg3 ;
   UWord arg4 ;
   UWord arg5 ;
   UWord arg6 ;
   UWord arg7 ;
   UWord arg8 ;
};
typedef struct SyscallArgs SyscallArgs;
enum __anonenum_what_129 {
    SsComplete = 1,
    SsHandToKernel = 2,
    SsIdle = 3
} ;
struct SyscallStatus {
   enum __anonenum_what_129 what ;
   SysRes sres ;
};
typedef struct SyscallStatus SyscallStatus;
struct __anonstruct_SyscallArgLayout_130 {
   Int o_sysno ;
   Int o_arg1 ;
   Int o_arg2 ;
   Int o_arg3 ;
   Int o_arg4 ;
   Int o_arg5 ;
   Int o_arg6 ;
   Int uu_arg7 ;
   Int uu_arg8 ;
};
typedef struct __anonstruct_SyscallArgLayout_130 SyscallArgLayout;
struct __anonstruct_SyscallTableEntry_131 {
   void (*before)(ThreadId  , SyscallArgLayout * , SyscallArgs * ,
                  SyscallStatus * , UWord * ) ;
   void (*after)(ThreadId  , SyscallArgs * , SyscallStatus * ) ;
};
typedef struct __anonstruct_SyscallTableEntry_131 SyscallTableEntry;
struct timex;
struct sysinfo;
struct __sysctl_args;
struct timespec;
struct vki_size_t;
struct rlimit64;
struct io_event;
struct iocb;
struct mq_attr;
struct sigevent;
struct itimerspec;
struct sched_param;
struct utimbuf;
struct old_sigaction;
struct sigaction;
struct timeval;
struct stat;
struct iovec;
struct mmsghdr;
struct flock64;
struct __anonstruct_132 {
   int  : 0 ;
};
struct __anonstruct_133 {
   int  : 0 ;
};
struct __anonstruct_134 {
   int  : 0 ;
};
struct __anonstruct_135 {
   int  : 0 ;
};
struct __anonstruct_136 {
   int  : 0 ;
};
struct __anonstruct_137 {
   int  : 0 ;
};
struct __anonstruct_138 {
   int  : 0 ;
};
struct __anonstruct_139 {
   int  : 0 ;
};
struct __anonstruct_140 {
   int  : 0 ;
};
struct __anonstruct_141 {
   int  : 0 ;
};
struct __anonstruct_142 {
   int  : 0 ;
};
struct __anonstruct_143 {
   int  : 0 ;
};
struct __anonstruct_144 {
   int  : 0 ;
};
struct __anonstruct_145 {
   int  : 0 ;
};
struct __anonstruct_146 {
   int  : 0 ;
};
struct __anonstruct_147 {
   int  : 0 ;
};
struct __anonstruct_148 {
   int  : 0 ;
};
struct __anonstruct_149 {
   int  : 0 ;
};
struct __anonstruct_150 {
   int  : 0 ;
};
struct __anonstruct_151 {
   int  : 0 ;
};
struct __anonstruct_152 {
   int  : 0 ;
};
struct __anonstruct_153 {
   int  : 0 ;
};
struct __anonstruct_154 {
   int  : 0 ;
};
struct __anonstruct_155 {
   int  : 0 ;
};
struct __anonstruct_156 {
   int  : 0 ;
};
struct __anonstruct_157 {
   int  : 0 ;
};
struct __anonstruct_158 {
   int  : 0 ;
};
struct __anonstruct_159 {
   int  : 0 ;
};
struct __anonstruct_160 {
   int  : 0 ;
};
struct __anonstruct_161 {
   int  : 0 ;
};
struct __anonstruct_162 {
   int  : 0 ;
};
struct __anonstruct_163 {
   int  : 0 ;
};
struct __anonstruct_164 {
   int  : 0 ;
};
struct __anonstruct_165 {
   int  : 0 ;
};
struct __anonstruct_166 {
   int  : 0 ;
};
struct __anonstruct_167 {
   int  : 0 ;
};
struct __anonstruct_168 {
   int  : 0 ;
};
struct __anonstruct_169 {
   int  : 0 ;
};
struct __anonstruct_170 {
   int  : 0 ;
};
struct __anonstruct_171 {
   int  : 0 ;
};
struct __anonstruct_172 {
   int  : 0 ;
};
struct __anonstruct_173 {
   int  : 0 ;
};
struct __anonstruct_174 {
   int  : 0 ;
};
struct __anonstruct_175 {
   int  : 0 ;
};
struct __anonstruct_176 {
   int  : 0 ;
};
struct __anonstruct_177 {
   int  : 0 ;
};
struct __anonstruct_178 {
   int  : 0 ;
};
struct __anonstruct_179 {
   int  : 0 ;
};
struct __anonstruct_180 {
   int  : 0 ;
};
struct __anonstruct_181 {
   int  : 0 ;
};
struct __anonstruct_182 {
   int  : 0 ;
};
struct __anonstruct_183 {
   int  : 0 ;
};
struct __anonstruct_184 {
   int  : 0 ;
};
struct __anonstruct_185 {
   int  : 0 ;
};
struct __anonstruct_186 {
   int  : 0 ;
};
struct __anonstruct_187 {
   int  : 0 ;
};
struct __anonstruct_188 {
   int  : 0 ;
};
struct __anonstruct_189 {
   int  : 0 ;
};
struct __anonstruct_190 {
   int  : 0 ;
};
struct __anonstruct_191 {
   int  : 0 ;
};
struct __anonstruct_192 {
   int  : 0 ;
};
struct __anonstruct_193 {
   int  : 0 ;
};
struct __anonstruct_194 {
   int  : 0 ;
};
struct __anonstruct_195 {
   int  : 0 ;
};
struct __anonstruct_196 {
   int  : 0 ;
};
struct __anonstruct_197 {
   int  : 0 ;
};
struct __anonstruct_198 {
   int  : 0 ;
};
struct __anonstruct_199 {
   int  : 0 ;
};
struct __anonstruct_200 {
   int  : 0 ;
};
struct __anonstruct_201 {
   int  : 0 ;
};
struct __anonstruct_202 {
   int  : 0 ;
};
struct __anonstruct_203 {
   int  : 0 ;
};
struct __anonstruct_204 {
   int  : 0 ;
};
struct __anonstruct_205 {
   int  : 0 ;
};
struct __anonstruct_206 {
   int  : 0 ;
};
struct __anonstruct_207 {
   int  : 0 ;
};
struct __anonstruct_208 {
   int  : 0 ;
};
struct __anonstruct_209 {
   int  : 0 ;
};
struct __anonstruct_210 {
   int  : 0 ;
};
struct __anonstruct_211 {
   int  : 0 ;
};
struct __anonstruct_212 {
   int  : 0 ;
};
struct __anonstruct_213 {
   int  : 0 ;
};
struct __anonstruct_214 {
   int  : 0 ;
};
struct __anonstruct_215 {
   int  : 0 ;
};
struct __anonstruct_216 {
   int  : 0 ;
};
struct __anonstruct_217 {
   int  : 0 ;
};
struct __anonstruct_218 {
   int  : 0 ;
};
struct __anonstruct_219 {
   int  : 0 ;
};
struct __anonstruct_220 {
   int  : 0 ;
};
struct __anonstruct_221 {
   int  : 0 ;
};
struct __anonstruct_222 {
   int  : 0 ;
};
struct __anonstruct_223 {
   int  : 0 ;
};
struct __anonstruct_224 {
   int  : 0 ;
};
struct __anonstruct_225 {
   int  : 0 ;
};
struct __anonstruct_226 {
   int  : 0 ;
};
struct __anonstruct_227 {
   int  : 0 ;
};
struct __anonstruct_228 {
   int  : 0 ;
};
struct __anonstruct_229 {
   int  : 0 ;
};
struct __anonstruct_230 {
   int  : 0 ;
};
struct __anonstruct_231 {
   int  : 0 ;
};
struct __anonstruct_232 {
   int  : 0 ;
};
struct __anonstruct_233 {
   int  : 0 ;
};
struct __anonstruct_234 {
   int  : 0 ;
};
struct __anonstruct_235 {
   int  : 0 ;
};
struct __anonstruct_236 {
   int  : 0 ;
};
struct __anonstruct_237 {
   int  : 0 ;
};
struct __anonstruct_238 {
   int  : 0 ;
};
struct __anonstruct_239 {
   int  : 0 ;
};
struct __anonstruct_240 {
   int  : 0 ;
};
struct __anonstruct_241 {
   int  : 0 ;
};
struct __anonstruct_242 {
   int  : 0 ;
};
struct __anonstruct_243 {
   int  : 0 ;
};
struct __anonstruct_244 {
   int  : 0 ;
};
struct __anonstruct_245 {
   int  : 0 ;
};
struct __anonstruct_246 {
   int  : 0 ;
};
struct __anonstruct_247 {
   int  : 0 ;
};
struct __anonstruct_248 {
   int  : 0 ;
};
struct __anonstruct_249 {
   int  : 0 ;
};
struct __anonstruct_250 {
   int  : 0 ;
};
struct __anonstruct_251 {
   int  : 0 ;
};
struct __anonstruct_252 {
   int  : 0 ;
};
struct __anonstruct_253 {
   int  : 0 ;
};
struct __anonstruct_254 {
   int  : 0 ;
};
struct __anonstruct_255 {
   int  : 0 ;
};
struct __anonstruct_256 {
   int  : 0 ;
};
struct __anonstruct_257 {
   int  : 0 ;
};
struct __anonstruct_258 {
   int  : 0 ;
};
struct __anonstruct_259 {
   int  : 0 ;
};
struct __anonstruct_260 {
   int  : 0 ;
};
struct __anonstruct_261 {
   int  : 0 ;
};
struct __anonstruct_262 {
   int  : 0 ;
};
struct __anonstruct_263 {
   int  : 0 ;
};
struct __anonstruct_264 {
   int  : 0 ;
};
struct __anonstruct_265 {
   int  : 0 ;
};
struct __anonstruct_266 {
   int  : 0 ;
};
struct __anonstruct_267 {
   int  : 0 ;
};
struct __anonstruct_268 {
   int  : 0 ;
};
struct __anonstruct_269 {
   int  : 0 ;
};
struct __anonstruct_270 {
   int  : 0 ;
};
struct __anonstruct_271 {
   int  : 0 ;
};
struct __anonstruct_272 {
   int  : 0 ;
};
struct __anonstruct_273 {
   int  : 0 ;
};
struct __anonstruct_274 {
   int  : 0 ;
};
struct __anonstruct_275 {
   int  : 0 ;
};
struct __anonstruct_276 {
   int  : 0 ;
};
__inline static Bool toBool(Int x ) 
{ 
  Int r ;
  int tmp ;

  {
  if (x == 0) {
    tmp = (int )((Bool )0);
  } else {
    tmp = (int )((Bool )1);
  }
  r = tmp;
  return ((Bool )r);
}
}
__inline static UChar toUChar(Int x ) 
{ 


  {
  x &= 255;
  return ((UChar )x);
}
}
__inline static HChar toHChar(Int x ) 
{ 


  {
  x &= 255;
  return ((HChar )x);
}
}
__inline static UShort toUShort(Int x ) 
{ 


  {
  x &= 65535;
  return ((UShort )x);
}
}
__inline static Short toShort(Int x ) 
{ 


  {
  x &= 65535;
  return ((Short )x);
}
}
__inline static UInt toUInt(Long x ) 
{ 


  {
  x &= 4294967295LL;
  return ((UInt )x);
}
}
__inline static ULong Ptr_to_ULong(void *p ) 
{ 
  UInt w ;

  {
  w = (UInt )p;
  return ((ULong )w);
}
}
__inline static void *ULong_to_Ptr(ULong n ) 
{ 
  UInt w ;

  {
  w = (UInt )n;
  return ((void *)w);
}
}
__inline static Bool sr_isError(SysRes sr ) 
{ 


  {
  return (sr._isError);
}
}
__inline static UWord sr_Res(SysRes sr ) 
{ 
  UWord tmp ;

  {
  if (sr._isError) {
    tmp = (UWord )0;
  } else {
    tmp = sr._val;
  }
  return (tmp);
}
}
__inline static UWord sr_ResHI(SysRes sr ) 
{ 


  {
  return ((UWord )0);
}
}
__inline static UWord sr_Err(SysRes sr ) 
{ 
  UWord tmp ;

  {
  if (sr._isError) {
    tmp = sr._val;
  } else {
    tmp = (UWord )0;
  }
  return (tmp);
}
}
__inline static Bool sr_EQ(SysRes sr1 , SysRes sr2 ) 
{ 
  int tmp ;

  {
  if (sr1._val == sr2._val) {
    if (sr1._isError) {
      if (sr2._isError) {
        tmp = 1;
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if (! sr1._isError) {
      if (! sr2._isError) {
        tmp = 1;
      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return ((Bool )tmp);
}
}
extern void ppIRType(IRType  ) ;
extern Int sizeofIRType(IRType  ) ;
extern IRConst *IRConst_U1(Bool  ) ;
extern IRConst *IRConst_U8(UChar  ) ;
extern IRConst *IRConst_U16(UShort  ) ;
extern IRConst *IRConst_U32(UInt  ) ;
extern IRConst *IRConst_U64(ULong  ) ;
extern IRConst *IRConst_F32(Float  ) ;
extern IRConst *IRConst_F32i(UInt  ) ;
extern IRConst *IRConst_F64(Double  ) ;
extern IRConst *IRConst_F64i(ULong  ) ;
extern IRConst *IRConst_V128(UShort  ) ;
extern IRConst *deepCopyIRConst(IRConst * ) ;
extern void ppIRConst(IRConst * ) ;
extern Bool eqIRConst(IRConst * , IRConst * ) ;
extern IRCallee *mkIRCallee(Int regparms , HChar *name , void *addr ) ;
extern IRCallee *deepCopyIRCallee(IRCallee * ) ;
extern void ppIRCallee(IRCallee * ) ;
extern IRRegArray *mkIRRegArray(Int  , IRType  , Int  ) ;
extern IRRegArray *deepCopyIRRegArray(IRRegArray * ) ;
extern void ppIRRegArray(IRRegArray * ) ;
extern Bool eqIRRegArray(IRRegArray * , IRRegArray * ) ;
extern void ppIRTemp(IRTemp  ) ;
extern void ppIROp(IROp  ) ;
extern IRExpr *IRExpr_Binder(Int binder ) ;
extern IRExpr *IRExpr_Get(Int off , IRType ty ) ;
extern IRExpr *IRExpr_GetI(IRRegArray *descr , IRExpr *ix , Int bias ) ;
extern IRExpr *IRExpr_RdTmp(IRTemp tmp ) ;
extern IRExpr *IRExpr_Qop(IROp op , IRExpr *arg1 , IRExpr *arg2 , IRExpr *arg3 ,
                          IRExpr *arg4 ) ;
extern IRExpr *IRExpr_Triop(IROp op , IRExpr *arg1 , IRExpr *arg2 ,
                            IRExpr *arg3 ) ;
extern IRExpr *IRExpr_Binop(IROp op , IRExpr *arg1 , IRExpr *arg2 ) ;
extern IRExpr *IRExpr_Unop(IROp op , IRExpr *arg ) ;
extern IRExpr *IRExpr_Load(IREndness end , IRType ty , IRExpr *addr ) ;
extern IRExpr *IRExpr_Const(IRConst *con ) ;
extern IRExpr *IRExpr_CCall(IRCallee *cee , IRType retty , IRExpr **args ) ;
extern IRExpr *IRExpr_Mux0X(IRExpr *cond , IRExpr *expr0 , IRExpr *exprX ) ;
extern IRExpr *deepCopyIRExpr(IRExpr * ) ;
extern void ppIRExpr(IRExpr * ) ;
extern IRExpr **mkIRExprVec_0(void) ;
extern IRExpr **mkIRExprVec_1(IRExpr * ) ;
extern IRExpr **mkIRExprVec_2(IRExpr * , IRExpr * ) ;
extern IRExpr **mkIRExprVec_3(IRExpr * , IRExpr * , IRExpr * ) ;
extern IRExpr **mkIRExprVec_4(IRExpr * , IRExpr * , IRExpr * , IRExpr * ) ;
extern IRExpr **mkIRExprVec_5(IRExpr * , IRExpr * , IRExpr * , IRExpr * ,
                              IRExpr * ) ;
extern IRExpr **mkIRExprVec_6(IRExpr * , IRExpr * , IRExpr * , IRExpr * ,
                              IRExpr * , IRExpr * ) ;
extern IRExpr **mkIRExprVec_7(IRExpr * , IRExpr * , IRExpr * , IRExpr * ,
                              IRExpr * , IRExpr * , IRExpr * ) ;
extern IRExpr **mkIRExprVec_8(IRExpr * , IRExpr * , IRExpr * , IRExpr * ,
                              IRExpr * , IRExpr * , IRExpr * , IRExpr * ) ;
extern IRExpr **shallowCopyIRExprVec(IRExpr ** ) ;
extern IRExpr **deepCopyIRExprVec(IRExpr ** ) ;
extern IRExpr *mkIRExpr_HWord(HWord  ) ;
extern IRExpr *mkIRExprCCall(IRType retty , Int regparms , HChar *name ,
                             void *addr , IRExpr **args ) ;
__inline static Bool isIRAtom(IRExpr *e ) 
{ 
  int tmp ;
  Bool tmp___0 ;

  {
  if ((unsigned int )e->tag == 86019U) {
    tmp = 1;
  } else
  if ((unsigned int )e->tag == 86025U) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  tmp___0 = toBool(tmp);
  return (tmp___0);
}
}
extern Bool eqIRAtom(IRExpr * , IRExpr * ) ;
extern void ppIRJumpKind(IRJumpKind  ) ;
extern void ppIREffect(IREffect  ) ;
extern void ppIRDirty(IRDirty * ) ;
extern IRDirty *emptyIRDirty(void) ;
extern IRDirty *deepCopyIRDirty(IRDirty * ) ;
extern IRDirty *unsafeIRDirty_0_N(Int regparms , HChar *name , void *addr ,
                                  IRExpr **args ) ;
extern IRDirty *unsafeIRDirty_1_N(IRTemp dst , Int regparms , HChar *name ,
                                  void *addr , IRExpr **args ) ;
extern void ppIRMBusEvent(IRMBusEvent  ) ;
extern void ppIRCAS(IRCAS *cas ) ;
extern IRCAS *mkIRCAS(IRTemp oldHi , IRTemp oldLo , IREndness end ,
                      IRExpr *addr , IRExpr *expdHi , IRExpr *expdLo ,
                      IRExpr *dataHi , IRExpr *dataLo ) ;
extern IRCAS *deepCopyIRCAS(IRCAS * ) ;
extern IRStmt *IRStmt_NoOp(void) ;
extern IRStmt *IRStmt_IMark(Addr64 addr , Int len , UChar delta ) ;
extern IRStmt *IRStmt_AbiHint(IRExpr *base , Int len , IRExpr *nia ) ;
extern IRStmt *IRStmt_Put(Int off , IRExpr *data ) ;
extern IRStmt *IRStmt_PutI(IRRegArray *descr , IRExpr *ix , Int bias ,
                           IRExpr *data ) ;
extern IRStmt *IRStmt_WrTmp(IRTemp tmp , IRExpr *data ) ;
extern IRStmt *IRStmt_Store(IREndness end , IRExpr *addr , IRExpr *data ) ;
extern IRStmt *IRStmt_CAS(IRCAS *details ) ;
extern IRStmt *IRStmt_LLSC(IREndness end , IRTemp result , IRExpr *addr ,
                           IRExpr *storedata ) ;
extern IRStmt *IRStmt_Dirty(IRDirty *details ) ;
extern IRStmt *IRStmt_MBE(IRMBusEvent event ) ;
extern IRStmt *IRStmt_Exit(IRExpr *guard , IRJumpKind jk , IRConst *dst ) ;
extern IRStmt *deepCopyIRStmt(IRStmt * ) ;
extern void ppIRStmt(IRStmt * ) ;
extern IRTemp newIRTemp(IRTypeEnv * , IRType  ) ;
extern IRTypeEnv *deepCopyIRTypeEnv(IRTypeEnv * ) ;
extern void ppIRTypeEnv(IRTypeEnv * ) ;
extern IRSB *emptyIRSB(void) ;
extern IRSB *deepCopyIRSB(IRSB * ) ;
extern IRSB *deepCopyIRSBExceptStmts(IRSB * ) ;
extern void ppIRSB(IRSB * ) ;
extern void addStmtToIRSB(IRSB * , IRStmt * ) ;
extern IRTypeEnv *emptyIRTypeEnv(void) ;
extern IRType typeOfIRConst(IRConst * ) ;
extern IRType typeOfIRTemp(IRTypeEnv * , IRTemp  ) ;
extern IRType typeOfIRExpr(IRTypeEnv * , IRExpr * ) ;
extern void sanityCheckIRSB(IRSB *bb , HChar *caller , Bool require_flatness ,
                            IRType guest_word_size ) ;
extern Bool isFlatIRStmt(IRStmt * ) ;
extern Bool isPlausibleIRType(IRType ty ) ;
extern HChar const   *LibVEX_ppVexArch(VexArch  ) ;
extern HChar const   *LibVEX_ppVexHwCaps(VexArch  , UInt  ) ;
extern void LibVEX_default_VexArchInfo(VexArchInfo *vai ) ;
extern void LibVEX_default_VexAbiInfo(VexAbiInfo *vbi ) ;
extern void LibVEX_default_VexControl(VexControl *vcon ) ;
extern HChar *private_LibVEX_alloc_first ;
extern HChar *private_LibVEX_alloc_curr ;
extern HChar *private_LibVEX_alloc_last ;
extern  __attribute__((__noreturn__)) void private_LibVEX_alloc_OOM(void) ;
__inline static void *LibVEX_Alloc(Int nbytes ) 
{ 
  HChar *curr ;
  HChar *next ;
  Int ALIGN ;

  {
  ALIGN = (Int )((HWord )(& ((struct align *)0)->x)) - 1;
  nbytes = (nbytes + ALIGN) & ~ ALIGN;
  curr = private_LibVEX_alloc_curr;
  next = curr + nbytes;
  if ((unsigned int )next >= (unsigned int )private_LibVEX_alloc_last) {
    private_LibVEX_alloc_OOM();
  } else {

  }
  private_LibVEX_alloc_curr = next;
  return ((void *)curr);
}
}
extern void LibVEX_ShowAllocStats(void) ;
extern void LibVEX_Init( __attribute__((__noreturn__)) void (*failure_exit)(void) ,
                        void (*log_bytes)(HChar * , Int nbytes ) ,
                        Int debuglevel , Bool valgrind_support ,
                        VexControl *vcon ) ;
extern VexTranslateResult LibVEX_Translate(VexTranslateArgs * ) ;
extern void LibVEX_ShowStats(void) ;
extern HChar *LibVEX_EmWarn_string(VexEmWarn  ) ;
extern void LibVEX_GuestX86_initialise(VexGuestX86State *vex_state ) ;
extern UInt LibVEX_GuestX86_get_eflags(VexGuestX86State *vex_state ) ;
extern void LibVEX_GuestX86_put_eflag_c(UInt new_carry_flag ,
                                        VexGuestX86State *vex_state ) ;
__inline static struct vki_cmsghdr *__vki_cmsg_nxthdr(void *__ctl ,
                                                      __vki_kernel_size_t __size ,
                                                      struct vki_cmsghdr *__cmsg ) 
{ 
  struct vki_cmsghdr *__ptr ;

  {
  __ptr = (struct vki_cmsghdr *)((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(long )) - 1U) & ~ (sizeof(long ) - 1U)));
  if ((unsigned long )((char *)(__ptr + 1) - (char *)__ctl) > (unsigned long )__size) {
    return ((struct vki_cmsghdr *)0);
  } else {

  }
  return (__ptr);
}
}
__inline static struct vki_cmsghdr *vki_cmsg_nxthdr(struct vki_msghdr *__msg ,
                                                    struct vki_cmsghdr *__cmsg ) 
{ 
  struct vki_cmsghdr *tmp ;

  {
  tmp = __vki_cmsg_nxthdr(__msg->msg_control, __msg->msg_controllen, __cmsg);
  return (tmp);
}
}
extern void vgPlain_vki_do_initial_consistency_checks(void) ;
extern Char *vgPlain_sysnum_string(Word sysnum , SizeT n_buf , Char *buf ) ;
extern Char *vgPlain_sysnum_string_extra(Word sysnum , SizeT n_buf , Char *buf ) ;
extern  __attribute__((__nothrow__)) int setjmp(struct __jmp_buf_tag *__env ) ;
extern  __attribute__((__nothrow__)) int __sigsetjmp(struct __jmp_buf_tag *__env ,
                                                     int __savemask ) ;
extern  __attribute__((__nothrow__)) int _setjmp(struct __jmp_buf_tag *__env ) ;
extern  __attribute__((__nothrow__,
__noreturn__)) void longjmp(struct __jmp_buf_tag *__env , int __val ) ;
extern  __attribute__((__nothrow__,
__noreturn__)) void _longjmp(struct __jmp_buf_tag *__env , int __val ) ;
extern  __attribute__((__nothrow__,
__noreturn__)) void siglongjmp(struct __jmp_buf_tag *__env , int __val ) ;
extern UWord __attribute__((__returns_twice__))  ( __attribute__((__regparm__(1))) VG_MINIMAL_SETJMP)(UInt *_env ) ;
extern  __attribute__((__noreturn__)) void ( __attribute__((__regparm__(1))) VG_MINIMAL_LONGJMP)(UInt *_env ) ;
extern ThreadId vgPlain_get_running_tid(void) ;
extern ThreadState vgPlain_threads[500] ;
extern ThreadId vgPlain_running_tid ;
extern HChar const   *vgPlain_name_of_ThreadStatus(ThreadStatus status ) ;
extern ThreadState *vgPlain_get_ThreadState(ThreadId tid ) ;
extern Bool vgPlain_is_valid_tid(ThreadId tid ) ;
extern Bool vgPlain_is_running_thread(ThreadId tid ) ;
extern Bool vgPlain_is_exiting(ThreadId tid ) ;
extern Int vgPlain_count_living_threads(void) ;
extern Int vgPlain_count_runnable_threads(void) ;
extern ThreadId vgPlain_lwpid_to_vgtid(Int lwpid ) ;
extern Int vgPlain_am_get_segment_starts(Addr *starts , Int nStarts ) ;
extern NSegment const   *vgPlain_am_find_nsegment(Addr a ) ;
extern HChar *vgPlain_am_get_filename(NSegment const   * ) ;
extern Bool vgPlain_am_is_valid_for_client(Addr start , SizeT len , UInt prot ) ;
extern void *vgPlain_am_shadow_alloc(SizeT size ) ;
extern SysRes vgPlain_am_munmap_valgrind(Addr start , SizeT length ) ;
extern Addr vgPlain_am_startup(Addr sp_at_startup ) ;
extern NSegment const   *vgPlain_am_next_nsegment(NSegment *here , Bool fwds ) ;
extern Bool vgPlain_am_is_valid_for_client_or_free_or_resvn(Addr start ,
                                                            SizeT len ,
                                                            UInt prot ) ;
extern ULong vgPlain_am_get_anonsize_total(void) ;
extern void vgPlain_am_show_nsegments(Int logLevel , HChar *who ) ;
extern Bool vgPlain_am_do_sync_check(HChar const   *fn , HChar const   *file ,
                                     Int line ) ;
extern Addr vgPlain_am_get_advisory(MapRequest *req , Bool forClient , Bool *ok ) ;
extern Addr vgPlain_am_get_advisory_client_simple(Addr start , SizeT len ,
                                                  Bool *ok ) ;
extern Bool vgPlain_am_covered_by_single_free_segment(Addr start , SizeT len ) ;
extern Bool vgPlain_am_notify_client_mmap(Addr a , SizeT len , UInt prot ,
                                          UInt flags , Int fd , Off64T offset ) ;
extern Bool vgPlain_am_notify_client_shmat(Addr a , SizeT len , UInt prot ) ;
extern Bool vgPlain_am_notify_mprotect(Addr start , SizeT len , UInt prot ) ;
extern Bool vgPlain_am_notify_munmap(Addr start , SizeT len ) ;
extern SysRes vgPlain_am_do_mmap_NO_NOTIFY(Addr start , SizeT length ,
                                           UInt prot , UInt flags , Int fd ,
                                           Off64T offset ) ;
extern SysRes vgPlain_am_mmap_file_fixed_client(Addr start , SizeT length ,
                                                UInt prot , Int fd ,
                                                Off64T offset ) ;
extern SysRes vgPlain_am_mmap_named_file_fixed_client(Addr start ,
                                                      SizeT length , UInt prot ,
                                                      Int fd , Off64T offset ,
                                                      HChar const   *name ) ;
extern SysRes vgPlain_am_mmap_anon_fixed_client(Addr start , SizeT length ,
                                                UInt prot ) ;
extern SysRes vgPlain_am_mmap_anon_float_client(SizeT length , Int prot ) ;
extern SysRes vgPlain_am_sbrk_anon_float_client(SizeT length , Int prot ) ;
extern SysRes vgPlain_am_mmap_anon_float_valgrind(SizeT cszB ) ;
extern SysRes vgPlain_am_sbrk_anon_float_valgrind(SizeT cszB ) ;
extern SysRes vgPlain_am_mmap_file_float_valgrind(SizeT length , UInt prot ,
                                                  Int fd , Off64T offset ) ;
extern SysRes vgPlain_am_shared_mmap_file_float_valgrind(SizeT length ,
                                                         UInt prot , Int fd ,
                                                         Off64T offset ) ;
extern SysRes vgPlain_am_munmap_client(Bool *need_discard , Addr start ,
                                       SizeT length ) ;
extern Bool vgPlain_am_change_ownership_v_to_c(Addr start , SizeT len ) ;
extern void vgPlain_am_set_segment_isCH_if_SkAnonC(NSegment *seg ) ;
extern void vgPlain_am_set_segment_hasT_if_SkFileC_or_SkAnonC(NSegment * ) ;
extern Bool vgPlain_am_create_reservation(Addr start , SizeT length ,
                                          ShrinkMode smode , SSizeT extra ) ;
extern Bool vgPlain_am_extend_into_adjacent_reservation_client(NSegment *seg ,
                                                               SSizeT delta ) ;
extern Bool vgPlain_am_extend_map_client(Bool *need_discard , NSegment *seg ,
                                         SizeT delta ) ;
extern Bool vgPlain_am_relocate_nooverlap_client(Bool *need_discard ,
                                                 Addr old_addr , SizeT old_len ,
                                                 Addr new_addr , SizeT new_len ) ;
extern VgStack *vgPlain_am_alloc_VgStack(Addr *initial_sp ) ;
extern SizeT vgPlain_am_get_VgStack_unused_szB(VgStack *stack , SizeT limit ) ;
extern Bool vgPlain_get_filename(Addr a , Char *filename , Int n_filename ) ;
extern Bool vgPlain_get_fnname(Addr a , Char *fnname , Int n_fnname ) ;
extern Bool vgPlain_get_linenum(Addr a , UInt *linenum ) ;
extern Bool vgPlain_get_fnname_w_offset(Addr a , Char *fnname , Int n_fnname ) ;
extern Bool vgPlain_get_filename_linenum(Addr a , Char *filename ,
                                         Int n_filename , Char *dirname ,
                                         Int n_dirname ,
                                         Bool *dirname_available ,
                                         UInt *linenum ) ;
extern Bool vgPlain_get_fnname_if_entry(Addr a , Char *fnname , Int n_fnname ) ;
extern Vg_FnNameKind vgPlain_get_fnname_kind(Char *name ) ;
extern Vg_FnNameKind vgPlain_get_fnname_kind_from_IP(Addr ip ) ;
extern Bool vgPlain_get_datasym_and_offset(Addr data_addr , Char *dname ,
                                           Int n_dname , PtrdiffT *offset ) ;
extern Bool vgPlain_get_data_description(void *dname1v , void *dname2v ,
                                         Addr data_addr ) ;
extern Bool vgPlain_get_objname(Addr a , Char *objname , Int n_objname ) ;
extern Char *vgPlain_describe_IP(Addr eip , Char *buf , Int n_buf ) ;
extern void *vgPlain_di_get_stack_blocks_at_ip(Addr ip , Bool arrays_only ) ;
extern void *vgPlain_di_get_global_blocks_from_dihandle(ULong di_handle ,
                                                        Bool arrays_only ) ;
extern DebugInfo *vgPlain_find_DebugInfo(Addr a ) ;
extern Addr vgPlain_DebugInfo_get_text_avma(DebugInfo const   *di ) ;
extern SizeT vgPlain_DebugInfo_get_text_size(DebugInfo const   *di ) ;
extern Addr vgPlain_DebugInfo_get_plt_avma(DebugInfo const   *di ) ;
extern SizeT vgPlain_DebugInfo_get_plt_size(DebugInfo const   *di ) ;
extern Addr vgPlain_DebugInfo_get_gotplt_avma(DebugInfo const   *di ) ;
extern SizeT vgPlain_DebugInfo_get_gotplt_size(DebugInfo const   *di ) ;
extern UChar const   *vgPlain_DebugInfo_get_soname(DebugInfo const   *di ) ;
extern UChar const   *vgPlain_DebugInfo_get_filename(DebugInfo const   *di ) ;
extern PtrdiffT vgPlain_DebugInfo_get_text_bias(DebugInfo const   *di ) ;
extern DebugInfo const   *vgPlain_next_DebugInfo(DebugInfo const   *di ) ;
extern Int vgPlain_DebugInfo_syms_howmany(DebugInfo const   *di ) ;
extern void vgPlain_DebugInfo_syms_getidx(DebugInfo const   *di , Int idx ,
                                          Addr *avma , Addr *tocptr ,
                                          UInt *size , UChar **pri_name ,
                                          UChar ***sec_names , Bool *isText ,
                                          Bool *isIFunc ) ;
extern HChar const   *vgPlain_pp_SectKind(VgSectKind kind ) ;
extern VgSectKind vgPlain_DebugInfo_sect_kind(UChar *name , SizeT n_name ,
                                              Addr a ) ;
extern void vgPlain_di_initialise(void) ;
extern ULong vgPlain_di_notify_mmap(Addr a , Bool allow_SkFileV , Int use_fd ) ;
extern void vgPlain_di_notify_munmap(Addr a , SizeT len ) ;
extern void vgPlain_di_notify_mprotect(Addr a , SizeT len , UInt prot ) ;
extern void vgPlain_di_notify_pdb_debuginfo(Int fd , Addr avma ,
                                            SizeT total_size ,
                                            PtrdiffT unknown_purpose__reloc ) ;
extern void vgPlain_di_notify_vm_protect(Addr a , SizeT len , UInt prot ) ;
extern void vgPlain_di_discard_ALL_debuginfo(void) ;
extern Bool vgPlain_get_fnname_raw(Addr a , Char *buf , Int nbuf ) ;
extern Bool vgPlain_get_fnname_no_cxx_demangle(Addr a , Char *buf , Int nbuf ) ;
extern Bool vgPlain_use_CF_info(D3UnwindRegs *uregs , Addr min_accessible ,
                                Addr max_accessible ) ;
extern Bool vgPlain_use_FPO_info(Addr *ipP , Addr *spP , Addr *fpP ,
                                 Addr min_accessible , Addr max_accessible ) ;
extern Addr vgPlain_get_tocptr(Addr guest_code_addr ) ;
extern Bool vgPlain_lookup_symbol_SLOW(UChar *sopatt , UChar *name ,
                                       Addr *pEnt , Addr *pToc ) ;
extern FastCacheEntry __attribute__((__aligned__(16)))  vgPlain_tt_fast[1 << 15] ;
extern UInt *vgPlain_tt_fastN[1 << 15] ;
extern void vgPlain_init_tt_tc(void) ;
extern void vgPlain_add_to_transtab(VexGuestExtents *vge , Addr64 entry ,
                                    AddrH code , UInt code_len ,
                                    Bool is_self_checking ) ;
extern Bool vgPlain_search_transtab(AddrH *result , Addr64 guest_addr ,
                                    Bool upd_cache ) ;
extern void vgPlain_discard_translations(Addr64 start , ULong range ,
                                         HChar *who ) ;
extern void vgPlain_print_tt_tc_stats(void) ;
extern UInt vgPlain_get_bbs_translated(void) ;
extern void vgPlain_add_to_unredir_transtab(VexGuestExtents *vge ,
                                            Addr64 entry , AddrH code ,
                                            UInt code_len ) ;
extern Bool vgPlain_search_unredir_transtab(AddrH *result , Addr64 guest_addr ) ;
extern ULong vgPlain_get_BB_profile(BBProfEntry *tops , UInt n_tops ) ;
extern XArray *vgPlain_newXA(void *(*alloc_fn)(HChar * , SizeT  ) , HChar *cc ,
                             void (*free_fn)(void * ) , Word elemSzB ) ;
extern void vgPlain_deleteXA(XArray * ) ;
extern void vgPlain_setCmpFnXA(XArray * , Int (*compar)(void * , void * ) ) ;
extern Word vgPlain_addToXA(XArray * , void *elem ) ;
extern Word vgPlain_addBytesToXA(XArray *xao , void *bytesV , Word nbytes ) ;
extern void vgPlain_sortXA(XArray * ) ;
extern Bool vgPlain_lookupXA(XArray * , void *key , Word *first , Word *last ) ;
extern Bool vgPlain_lookupXA_UNSAFE(XArray *xao , void *key , Word *first ,
                                    Word *last , Int (*cmpFn)(void * , void * ) ) ;
extern Word vgPlain_sizeXA(XArray * ) ;
extern void *vgPlain_indexXA(XArray * , Word  ) ;
extern void vgPlain_dropTailXA(XArray * , Word  ) ;
extern void vgPlain_dropHeadXA(XArray * , Word  ) ;
extern XArray *vgPlain_cloneXA(HChar *cc , XArray *xa ) ;
extern void vgPlain_getContentsXA_UNSAFE(XArray *sr , void **ctsP , Word *usedP ) ;
extern void ( /* format attribute */  vgPlain_xaprintf)(XArray *dst ,
                                                        HChar const   *format 
                                                        , ...) ;
extern XArray *vgPlain_args_for_client ;
extern XArray *vgPlain_args_for_valgrind ;
extern Int vgPlain_args_for_valgrind_noexecpass ;
extern HChar const   *vgPlain_args_the_exename ;
extern Addr vgPlain_clstk_base ;
extern Addr vgPlain_clstk_end ;
extern UWord vgPlain_clstk_id ;
extern UWord *vgPlain_client_auxv ;
extern Addr vgPlain_brk_base ;
extern Addr vgPlain_brk_limit ;
extern Int vgPlain_cl_exec_fd ;
extern Int vgPlain_cl_cmdline_fd ;
extern struct vki_rlimit vgPlain_client_rlimit_data ;
extern struct vki_rlimit vgPlain_client_rlimit_stack ;
extern HChar *vgPlain_name_of_launcher ;
extern Int vgPlain_fd_soft_limit ;
extern Int vgPlain_fd_hard_limit ;
extern Addr vgPlain_client___libc_freeres_wrapper ;
extern Addr vgPlain_client__dl_sysinfo_int80 ;
extern void vgPlain_debugLog_startup(Int level , HChar *who ) ;
extern void vgPlain_debugLog_setXml(Bool xml ) ;
extern Int vgPlain_debugLog_getLevel(void) ;
extern void ( /* format attribute */  vgPlain_debugLog)(Int level ,
                                                        HChar const   *modulename ,
                                                        HChar const   *format 
                                                        , ...) ;
extern UInt vgPlain_debugLog_vprintf(void (*send_fn)(HChar  , void * ) ,
                                     void *send_arg2 , HChar const   *format ,
                                     va_list vargs ) ;
extern Bool vgPlain_isspace(Char c ) ;
extern Bool vgPlain_isdigit(Char c ) ;
extern Char vgPlain_tolower(Char c ) ;
extern Long vgPlain_strtoll10(Char *str , Char **endptr ) ;
extern Long vgPlain_strtoll16(Char *str , Char **endptr ) ;
extern ULong vgPlain_strtoull10(Char *str , Char **endptr ) ;
extern ULong vgPlain_strtoull16(Char *str , Char **endptr ) ;
extern double vgPlain_strtod(Char *str , Char **endptr ) ;
extern SizeT vgPlain_strlen(Char const   *str ) ;
extern Char *vgPlain_strcat(Char *dest , Char const   *src ) ;
extern Char *vgPlain_strncat(Char *dest , Char const   *src , SizeT n ) ;
extern Char *vgPlain_strpbrk(Char const   *s , Char const   *accpt ) ;
extern Char *vgPlain_strcpy(Char *dest , Char const   *src ) ;
extern Char *vgPlain_strncpy(Char *dest , Char const   *src , SizeT ndest ) ;
extern Int vgPlain_strcmp(Char const   *s1 , Char const   *s2 ) ;
extern Int vgPlain_strcasecmp(Char const   *s1 , Char const   *s2 ) ;
extern Int vgPlain_strncmp(Char const   *s1 , Char const   *s2 , SizeT nmax ) ;
extern Int vgPlain_strncasecmp(Char const   *s1 , Char const   *s2 , SizeT nmax ) ;
extern Char *vgPlain_strstr(Char const   *haystack , Char *needle ) ;
extern Char *vgPlain_strcasestr(Char const   *haystack , Char *needle ) ;
extern Char *vgPlain_strchr(Char const   *s , Char c ) ;
extern Char *vgPlain_strrchr(Char const   *s , Char c ) ;
extern SizeT vgPlain_strspn(Char const   *s , Char const   *accpt ) ;
extern SizeT vgPlain_strcspn(Char const   *s , char const   *reject ) ;
extern Char *vgPlain_strtok_r(Char *s , Char const   *delim , Char **saveptr ) ;
extern Char *vgPlain_strtok(Char *s , Char const   *delim ) ;
extern Bool vgPlain_parse_Addr(UChar **ppc , Addr *result ) ;
extern void vgPlain_strncpy_safely(Char *dest , Char const   *src , SizeT ndest ) ;
extern void *vgPlain_memcpy(void *d , void const   *s , SizeT sz ) ;
extern void *vgPlain_memmove(void *d , void const   *s , SizeT sz ) ;
extern void *vgPlain_memset(void *s , Int c , SizeT sz ) ;
extern Int vgPlain_memcmp(void const   *s1 , void const   *s2 , SizeT n ) ;
__inline static void ( __attribute__((__always_inline__)) vgPlain_bzero_inline)(void *s ,
                                                                                SizeT sz ) 
{ 
  UWord *p ;
  UWord tmp ;
  UWord tmp___0 ;
  UWord tmp___1 ;
  UWord tmp___2 ;
  UWord tmp___3 ;
  UWord tmp___4 ;
  UWord tmp___5 ;
  UWord tmp___6 ;
  UWord tmp___7 ;
  UWord tmp___8 ;
  UWord tmp___9 ;
  UWord tmp___10 ;
  UWord tmp___11 ;
  UWord tmp___12 ;
  UWord tmp___13 ;
  UWord tmp___14 ;
  UWord tmp___15 ;
  UWord tmp___16 ;
  UWord tmp___17 ;
  UWord tmp___18 ;
  UWord tmp___19 ;
  UWord tmp___20 ;
  UWord tmp___21 ;
  UWord tmp___22 ;
  UWord tmp___23 ;
  UWord tmp___24 ;
  UWord tmp___25 ;
  UWord tmp___26 ;
  long tmp___27 ;
  long tmp___28 ;

  {
  tmp___27 = __builtin_expect((long )(! (! (0UL == (sz & (Addr )(sizeof(UWord ) - 1U))))),
                              1L);
  if (tmp___27) {
    tmp___28 = __builtin_expect((long )(! (! (0UL == ((Addr )s & (Addr )(sizeof(UWord ) - 1U))))),
                                1L);
    if (tmp___28) {
      p = (UWord *)s;
      switch (sz / (SizeT )sizeof(UWord )) {
      case 8UL: 
      tmp___5 = 0UL;
      *(p + 7) = tmp___5;
      tmp___4 = tmp___5;
      *(p + 6) = tmp___4;
      tmp___3 = tmp___4;
      *(p + 5) = tmp___3;
      tmp___2 = tmp___3;
      *(p + 4) = tmp___2;
      tmp___1 = tmp___2;
      *(p + 3) = tmp___1;
      tmp___0 = tmp___1;
      *(p + 2) = tmp___0;
      tmp = tmp___0;
      *(p + 1) = tmp;
      *(p + 0) = tmp;
      return;
      case 7UL: 
      tmp___11 = 0UL;
      *(p + 6) = tmp___11;
      tmp___10 = tmp___11;
      *(p + 5) = tmp___10;
      tmp___9 = tmp___10;
      *(p + 4) = tmp___9;
      tmp___8 = tmp___9;
      *(p + 3) = tmp___8;
      tmp___7 = tmp___8;
      *(p + 2) = tmp___7;
      tmp___6 = tmp___7;
      *(p + 1) = tmp___6;
      *(p + 0) = tmp___6;
      return;
      case 6UL: 
      tmp___16 = 0UL;
      *(p + 5) = tmp___16;
      tmp___15 = tmp___16;
      *(p + 4) = tmp___15;
      tmp___14 = tmp___15;
      *(p + 3) = tmp___14;
      tmp___13 = tmp___14;
      *(p + 2) = tmp___13;
      tmp___12 = tmp___13;
      *(p + 1) = tmp___12;
      *(p + 0) = tmp___12;
      return;
      case 5UL: 
      tmp___20 = 0UL;
      *(p + 4) = tmp___20;
      tmp___19 = tmp___20;
      *(p + 3) = tmp___19;
      tmp___18 = tmp___19;
      *(p + 2) = tmp___18;
      tmp___17 = tmp___18;
      *(p + 1) = tmp___17;
      *(p + 0) = tmp___17;
      return;
      case 4UL: 
      tmp___23 = 0UL;
      *(p + 3) = tmp___23;
      tmp___22 = tmp___23;
      *(p + 2) = tmp___22;
      tmp___21 = tmp___22;
      *(p + 1) = tmp___21;
      *(p + 0) = tmp___21;
      return;
      case 3UL: 
      tmp___25 = 0UL;
      *(p + 2) = tmp___25;
      tmp___24 = tmp___25;
      *(p + 1) = tmp___24;
      *(p + 0) = tmp___24;
      return;
      case 2UL: 
      tmp___26 = 0UL;
      *(p + 1) = tmp___26;
      *(p + 0) = tmp___26;
      return;
      case 1UL: 
      *(p + 0) = 0UL;
      return;
      case 0UL: 
      return;
      default: 
      break;
      }
    } else {

    }
  } else {

  }
  vgPlain_memset(s, 0, sz);
  return;
}
}
extern void vgPlain_ssort(void *base , SizeT nmemb , SizeT size ,
                          Int (*compar)(void * , void * ) ) ;
extern Int vgPlain_log2(UInt x ) ;
extern Int vgPlain_log2_64(ULong x ) ;
extern UInt vgPlain_random(UInt *pSeed ) ;
extern  __attribute__((__noreturn__)) void vgPlain_exit(Int status ) ;
extern  __attribute__((__noreturn__)) void vgPlain_tool_panic(Char *str ) ;
extern  __attribute__((__noreturn__)) void vgPlain_assert_fail(Bool isCore ,
                                                               Char const   *expr ,
                                                               Char const   *file ,
                                                               Int line ,
                                                               Char const   *fn ,
                                                               HChar const   *format 
                                                               , ...) ;
extern  __attribute__((__noreturn__)) void vgPlain_core_panic(Char *str ) ;
extern  __attribute__((__noreturn__)) void vgPlain_core_panic_at(Char *str ,
                                                                 UnwindStartRegs * ) ;
extern  __attribute__((__noreturn__)) void vgPlain_unimplemented(Char *msg ) ;
extern void vgPlain_show_sched_status(void) ;
extern SysRes vgPlain_mknod(Char const   *pathname , Int mode , UWord dev ) ;
extern SysRes vgPlain_open(Char const   *pathname , Int flags , Int mode ) ;
extern Int vgPlain_fd_open(Char const   *pathname , Int flags , Int mode ) ;
extern void vgPlain_close(Int fd ) ;
extern Int vgPlain_read(Int fd , void *buf , Int count ) ;
extern Int vgPlain_write(Int fd , void const   *buf , Int count ) ;
extern Int vgPlain_pipe(Int *fd ) ;
extern Off64T vgPlain_lseek(Int fd , Off64T offset , Int whence ) ;
extern SysRes vgPlain_stat(Char const   *file_name , struct vg_stat *buf ) ;
extern Int vgPlain_fstat(Int fd , struct vg_stat *buf ) ;
extern SysRes vgPlain_dup(Int oldfd ) ;
extern SysRes vgPlain_dup2(Int oldfd , Int newfd ) ;
extern Int vgPlain_rename(Char const   *old_name , Char const   *new_name ) ;
extern Int vgPlain_unlink(Char const   *file_name ) ;
extern Int vgPlain_poll(struct vki_pollfd *fds , Int nfds , Int timeout ) ;
extern Int vgPlain_readlink(Char const   *path , Char *buf , UInt bufsize ) ;
extern Int vgPlain_getdents(Int fd , struct vki_dirent *dirp , UInt count ) ;
extern Char *vgPlain_basename(Char const   *path ) ;
extern Char *vgPlain_dirname(Char const   *path ) ;
extern HChar const   *vgPlain_tmpdir(void) ;
extern Bool vgPlain_get_startup_wd(Char *buf , SizeT size ) ;
extern Int vgPlain_safe_fd(Int oldfd ) ;
extern Int vgPlain_fcntl(Int fd , Int cmd , Addr arg ) ;
extern Bool vgPlain_resolve_filename(Int fd , HChar *buf , Int n_buf ) ;
extern Long vgPlain_fsize(Int fd ) ;
extern Bool vgPlain_is_dir(HChar const   *f ) ;
extern Int vgPlain_connect_via_socket(UChar *str ) ;
extern UInt vgPlain_htonl(UInt x ) ;
extern UInt vgPlain_ntohl(UInt x ) ;
extern UShort vgPlain_htons(UShort x ) ;
extern UShort vgPlain_ntohs(UShort x ) ;
extern Int vgPlain_socket(Int domain , Int type , Int protocol ) ;
extern Int vgPlain_write_socket(Int sd , void *msg , Int count ) ;
extern Int vgPlain_getsockname(Int sd , struct vki_sockaddr *name ,
                               Int *namelen ) ;
extern Int vgPlain_getpeername(Int sd , struct vki_sockaddr *name ,
                               Int *namelen ) ;
extern Int vgPlain_getsockopt(Int sd , Int level , Int optname , void *optval ,
                              Int *optlen ) ;
extern Int vgPlain_access(HChar const   *path , Bool irusr , Bool iwusr ,
                          Bool ixusr ) ;
extern Int vgPlain_check_executable(Bool *is_setuid , HChar const   *f ,
                                    Bool allow_setuid ) ;
extern SysRes vgPlain_pread(Int fd , void *buf , Int count , OffT offset ) ;
extern Int vgPlain_mkstemp(HChar *part_of_name , HChar *fullname ) ;
extern Bool vgPlain_record_startup_wd(void) ;
extern UInt ( /* format attribute */  vgPlain_sprintf)(Char *buf ,
                                                       HChar const   *format 
                                                       , ...) ;
extern UInt ( /* format attribute */  vgPlain_vsprintf)(Char *buf ,
                                                        HChar const   *format ,
                                                        va_list vargs ) ;
extern UInt ( /* format attribute */  vgPlain_snprintf)(Char *buf , Int size ,
                                                        HChar const   *format 
                                                        , ...) ;
extern UInt ( /* format attribute */  vgPlain_vsnprintf)(Char *buf , Int size ,
                                                         HChar const   *format ,
                                                         va_list vargs ) ;
extern void vgPlain_percentify(ULong n , ULong m , UInt d , Int n_buf ,
                               char *buf ) ;
extern UInt ( /* format attribute */  vgPlain_printf)(HChar const   *format 
                                                      , ...) ;
extern UInt ( /* format attribute */  vgPlain_vprintf)(HChar const   *format ,
                                                       va_list vargs ) ;
extern UInt ( /* format attribute */  vgPlain_printf_xml)(HChar const   *format 
                                                          , ...) ;
extern UInt ( /* format attribute */  vgPlain_vprintf_xml)(HChar const   *format ,
                                                           va_list vargs ) ;
extern void vgPlain_vcbprintf(void (*char_sink)(HChar  , void *opaque ) ,
                              void *opaque , HChar const   *format ,
                              va_list vargs ) ;
extern UInt ( /* format attribute */  vgPlain_message)(VgMsgKind kind ,
                                                       HChar const   *format 
                                                       , ...) ;
extern UInt ( /* format attribute */  vgPlain_vmessage)(VgMsgKind kind ,
                                                        HChar const   *format ,
                                                        va_list vargs ) ;
extern UInt ( /* format attribute */  vgPlain_fmsg)(HChar const   *format  , ...) ;
extern  __attribute__((__noreturn__)) void ( /* format attribute */  vgPlain_fmsg_bad_option)(HChar *opt ,
                                                                                              HChar const   *format 
                                                                                              , ...) ;
extern UInt ( /* format attribute */  vgPlain_umsg)(HChar const   *format  , ...) ;
extern UInt ( /* format attribute */  vgPlain_dmsg)(HChar const   *format  , ...) ;
extern void vgPlain_message_flush(void) ;
extern OutputSink vgPlain_log_output_sink ;
extern OutputSink vgPlain_xml_output_sink ;
extern void vgPlain_elapsed_wallclock_time(HChar *buf ) ;
extern  __attribute__((__noreturn__)) void vgPlain_err_missing_prog(void) ;
extern  __attribute__((__noreturn__)) void vgPlain_err_config_error(Char *format 
                                                                    , ...) ;
extern Char **vgPlain_client_envp ;
extern Char *vgPlain_getenv(Char *name ) ;
extern Char const   *vgPlain_libdir ;
extern Char const   *vgPlain_LD_PRELOAD_var_name ;
extern Int vgPlain_waitpid(Int pid , Int *status , Int options ) ;
extern Int vgPlain_system(Char *cmd ) ;
extern Int vgPlain_fork(void) ;
extern void vgPlain_execv(Char *filename , Char **argv ) ;
extern Int vgPlain_getrlimit(Int resource , struct vki_rlimit *rlim ) ;
extern Int vgPlain_setrlimit(Int resource , struct vki_rlimit  const  *rlim ) ;
extern Int vgPlain_prctl(Int option , ULong arg2 , ULong arg3 , ULong arg4 ,
                         ULong arg5 ) ;
extern Int vgPlain_gettid(void) ;
extern Int vgPlain_getpid(void) ;
extern Int vgPlain_getppid(void) ;
extern Int vgPlain_getpgrp(void) ;
extern Int vgPlain_geteuid(void) ;
extern Int vgPlain_getegid(void) ;
extern UInt vgPlain_read_millisecond_timer(void) ;
extern void vgPlain_atfork(void (*pre)(ThreadId  ) ,
                           void (*parent)(ThreadId  ) ,
                           void (*child)(ThreadId  ) ) ;
extern Char **vgPlain_env_setenv(Char ***envp , Char const   *varname ,
                                 Char const   *val ) ;
extern void vgPlain_env_unsetenv(Char **env , Char const   *varname ) ;
extern void vgPlain_env_remove_valgrind_env_stuff(Char **env ) ;
extern Char **vgPlain_env_clone(Char **env_clone ) ;
extern Int vgPlain_getgroups(Int size , UInt *list ) ;
extern Int vgPlain_ptrace(Int request , Int pid , void *addr , void *data ) ;
extern void vgPlain_do_atfork_pre(ThreadId tid ) ;
extern void vgPlain_do_atfork_parent(ThreadId tid ) ;
extern void vgPlain_do_atfork_child(ThreadId tid ) ;
extern Int vgPlain_sigprocmask(Int how , vki_sigset_t const   *set ,
                               vki_sigset_t *oldset ) ;
extern Int vgPlain_sigfillset(vki_sigset_t *set ) ;
extern Int vgPlain_sigemptyset(vki_sigset_t *set ) ;
extern Bool vgPlain_isfullsigset(vki_sigset_t const   *set ) ;
extern Bool vgPlain_isemptysigset(vki_sigset_t const   *set ) ;
extern Bool vgPlain_iseqsigset(vki_sigset_t const   *set1 ,
                               vki_sigset_t const   *set2 ) ;
extern Int vgPlain_sigaddset(vki_sigset_t *set , Int signum ) ;
extern Int vgPlain_sigdelset(vki_sigset_t *set , Int signum ) ;
extern Int vgPlain_sigismember(vki_sigset_t const   *set , Int signum ) ;
extern void vgPlain_sigaddset_from_set(vki_sigset_t *dst , vki_sigset_t *src ) ;
extern void vgPlain_sigdelset_from_set(vki_sigset_t *dst , vki_sigset_t *src ) ;
extern void vgPlain_sigintersectset(vki_sigset_t *dst , vki_sigset_t *src ) ;
extern void vgPlain_sigcomplementset(vki_sigset_t *dst , vki_sigset_t *src ) ;
extern Int vgPlain_sigaction(Int signum , vki_sigaction_toK_t const   *act ,
                             vki_sigaction_fromK_t *oldact ) ;
extern void vgPlain_convert_sigaction_fromK_to_toK(vki_sigaction_fromK_t * ,
                                                   vki_sigaction_toK_t * ) ;
extern Int vgPlain_kill(Int pid , Int signo ) ;
extern Int vgPlain_tkill(Int lwpid , Int signo ) ;
extern Int vgPlain_sigtimedwait_zero(vki_sigset_t const   * , vki_siginfo_t * ) ;
extern void *vgPlain_malloc(HChar *cc , SizeT nbytes ) ;
extern void vgPlain_free(void *p ) ;
extern void *vgPlain_calloc(HChar *cc , SizeT n , SizeT bytes_per_elem ) ;
extern void *vgPlain_realloc(HChar *cc , void *p , SizeT size ) ;
extern Char *vgPlain_strdup(HChar *cc , Char const   *s ) ;
extern SizeT vgPlain_malloc_usable_size(void *p ) ;
extern  __attribute__((__noreturn__)) void vgPlain_out_of_memory_NORETURN(HChar *who ,
                                                                          SizeT szB ) ;
extern void *vgPlain_arena_malloc(ArenaId arena , HChar *cc , SizeT nbytes ) ;
extern void vgPlain_arena_free(ArenaId arena , void *ptr ) ;
extern void *vgPlain_arena_calloc(ArenaId arena , HChar *cc , SizeT nmemb ,
                                  SizeT bytes_per_memb ) ;
extern void *vgPlain_arena_realloc(ArenaId arena , HChar *cc , void *ptr ,
                                   SizeT size ) ;
extern void *vgPlain_arena_memalign(ArenaId aid , HChar *cc , SizeT req_alignB ,
                                    SizeT req_pszB ) ;
extern Char *vgPlain_arena_strdup(ArenaId aid , HChar *cc , Char const   *s ) ;
extern SizeT vgPlain_arena_malloc_usable_size(ArenaId aid , void *payload ) ;
extern void vgPlain_mallinfo(ThreadId tid , struct vg_mallinfo *mi ) ;
extern void vgPlain_sanity_check_malloc_all(void) ;
extern void vgPlain_print_all_arena_stats(void) ;
extern void vgPlain_print_arena_cc_analysis(void) ;
extern ExeContext *vgPlain_record_ExeContext(ThreadId tid , Word first_ip_delta ) ;
extern ExeContext *vgPlain_record_depth_1_ExeContext(ThreadId tid ) ;
extern void vgPlain_apply_ExeContext(void (*action)(UInt n , Addr ip ) ,
                                     ExeContext *ec , UInt n_ips ) ;
extern Bool vgPlain_eq_ExeContext(VgRes res , ExeContext *e1 , ExeContext *e2 ) ;
extern void vgPlain_pp_ExeContext(ExeContext *ec ) ;
extern UInt vgPlain_get_ECU_from_ExeContext(ExeContext *e ) ;
extern Int vgPlain_get_ExeContext_n_ips(ExeContext *e ) ;
extern ExeContext *vgPlain_get_ExeContext_from_ECU(UInt uniq ) ;
extern ExeContext *vgPlain_make_depth_1_ExeContext_from_Addr(Addr a ) ;
__inline static Bool vgPlain_is_plausible_ECU(UInt ecu ) 
{ 
  int tmp ;

  {
  if (ecu > 0U) {
    if ((ecu & 3U) == 0U) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return ((Bool )tmp);
}
}
extern ExeContext *vgPlain_make_ExeContext_from_StackTrace(Addr *ips ,
                                                           UInt n_ips ) ;
extern ExeContext *vgPlain_get_error_where(Error *err ) ;
extern ErrorKind vgPlain_get_error_kind(Error *err ) ;
extern Addr vgPlain_get_error_address(Error *err ) ;
extern Char *vgPlain_get_error_string(Error *err ) ;
extern void *vgPlain_get_error_extra(Error *err ) ;
extern void vgPlain_maybe_record_error(ThreadId tid , ErrorKind ekind , Addr a ,
                                       Char *s , void *extra ) ;
extern Bool vgPlain_unique_error(ThreadId tid , ErrorKind ekind , Addr a ,
                                 Char *s , void *extra , ExeContext *where ,
                                 Bool print_error , Bool allow_GDB_attach ,
                                 Bool count_error ) ;
extern Bool vgPlain_get_line(Int fd , Char **bufpp , SizeT *nBufp , Int *lineno ) ;
extern SuppKind vgPlain_get_supp_kind(Supp *su ) ;
extern Char *vgPlain_get_supp_string(Supp *su ) ;
extern void *vgPlain_get_supp_extra(Supp *su ) ;
extern void vgPlain_set_supp_kind(Supp *su , SuppKind suppkind ) ;
extern void vgPlain_set_supp_string(Supp *su , Char *string ) ;
extern void vgPlain_set_supp_extra(Supp *su , void *extra ) ;
extern void (*vgPlain_tl_pre_clo_init)(void) ;
extern void vgPlain_basic_tool_funcs(void (*post_clo_init)(void) ,
                                     IRSB *(*instrument)(VgCallbackClosure *closure ,
                                                         IRSB *sb_in ,
                                                         VexGuestLayout *layout ,
                                                         VexGuestExtents *vge ,
                                                         IRType gWordTy ,
                                                         IRType hWordTy ) ,
                                     void (*fini)(Int  ) ) ;
extern void vgPlain_details_name(Char *name ) ;
extern void vgPlain_details_version(Char *version ) ;
extern void vgPlain_details_description(Char *description ) ;
extern void vgPlain_details_copyright_author(Char *copyright_author ) ;
extern void vgPlain_details_avg_translation_sizeB(UInt size ) ;
extern void vgPlain_details_bug_reports_to(Char *bug_reports_to ) ;
extern void vgPlain_needs_libc_freeres(void) ;
extern void vgPlain_needs_core_errors(void) ;
extern void vgPlain_needs_tool_errors(Bool (*eq_Error)(VgRes res , Error *e1 ,
                                                       Error *e2 ) ,
                                      void (*before_pp_Error)(Error *err ) ,
                                      void (*pp_Error)(Error *err ) ,
                                      Bool show_ThreadIDs_for_errors ,
                                      UInt (*update_extra)(Error *err ) ,
                                      Bool (*recognised_suppression)(Char *name ,
                                                                     Supp *su ) ,
                                      Bool (*read_extra_suppression_info)(Int fd ,
                                                                          Char **bufpp ,
                                                                          SizeT *nBufp ,
                                                                          Supp *su ) ,
                                      Bool (*error_matches_suppression)(Error *err ,
                                                                        Supp *su ) ,
                                      Char *(*get_error_name)(Error *err ) ,
                                      Bool (*print_extra_suppression_info)(Error *err ,
                                                                           Char *buf ,
                                                                           Int nBuf ) ) ;
extern void vgPlain_needs_superblock_discards(void (*discard_superblock_info)(Addr64 orig_addr ,
                                                                              VexGuestExtents extents ) ) ;
extern void vgPlain_needs_command_line_options(Bool (*process_cmd_line_option)(Char *argv ) ,
                                               void (*print_usage)(void) ,
                                               void (*print_debug_usage)(void) ) ;
extern void vgPlain_needs_client_requests(Bool (*handle_client_request)(ThreadId tid ,
                                                                        UWord *arg_block ,
                                                                        UWord *ret ) ) ;
extern void vgPlain_needs_syscall_wrapper(void (*pre_syscall)(ThreadId tid ,
                                                              UInt syscallno ,
                                                              UWord *args ,
                                                              UInt nArgs ) ,
                                          void (*post_syscall)(ThreadId tid ,
                                                               UInt syscallno ,
                                                               UWord *args ,
                                                               UInt nArgs ,
                                                               SysRes res ) ) ;
extern void vgPlain_needs_sanity_checks(Bool (*cheap_sanity_check)(void) ,
                                        Bool (*expensive_sanity_check)(void) ) ;
extern void vgPlain_needs_var_info(void) ;
extern void vgPlain_needs_malloc_replacement(void *(*pmalloc)(ThreadId tid ,
                                                              SizeT n ) ,
                                             void *(*p__builtin_new)(ThreadId tid ,
                                                                     SizeT n ) ,
                                             void *(*p__builtin_vec_new)(ThreadId tid ,
                                                                         SizeT n ) ,
                                             void *(*pmemalign)(ThreadId tid ,
                                                                SizeT align ,
                                                                SizeT n ) ,
                                             void *(*pcalloc)(ThreadId tid ,
                                                              SizeT nmemb ,
                                                              SizeT size1 ) ,
                                             void (*pfree)(ThreadId tid ,
                                                           void *p ) ,
                                             void (*p__builtin_delete)(ThreadId tid ,
                                                                       void *p ) ,
                                             void (*p__builtin_vec_delete)(ThreadId tid ,
                                                                           void *p ) ,
                                             void *(*prealloc)(ThreadId tid ,
                                                               void *p ,
                                                               SizeT new_size ) ,
                                             SizeT (*pmalloc_usable_size)(ThreadId tid ,
                                                                          void *p ) ,
                                             SizeT client_malloc_redzone_szB ) ;
extern void vgPlain_needs_xml_output(void) ;
extern void vgPlain_needs_final_IR_tidy_pass(IRSB *(*final_tidy)(IRSB * ) ) ;
extern void vgPlain_track_new_mem_startup(void (*f)(Addr a , SizeT len ,
                                                    Bool rr , Bool ww ,
                                                    Bool xx , ULong di_handle ) ) ;
extern void vgPlain_track_new_mem_stack_signal(void (*f)(Addr a , SizeT len ,
                                                         ThreadId tid ) ) ;
extern void vgPlain_track_new_mem_brk(void (*f)(Addr a , SizeT len ,
                                                ThreadId tid ) ) ;
extern void vgPlain_track_new_mem_mmap(void (*f)(Addr a , SizeT len , Bool rr ,
                                                 Bool ww , Bool xx ,
                                                 ULong di_handle ) ) ;
extern void vgPlain_track_copy_mem_remap(void (*f)(Addr from , Addr to ,
                                                   SizeT len ) ) ;
extern void vgPlain_track_change_mem_mprotect(void (*f)(Addr a , SizeT len ,
                                                        Bool rr , Bool ww ,
                                                        Bool xx ) ) ;
extern void vgPlain_track_die_mem_stack_signal(void (*f)(Addr a , SizeT len ) ) ;
extern void vgPlain_track_die_mem_brk(void (*f)(Addr a , SizeT len ) ) ;
extern void vgPlain_track_die_mem_munmap(void (*f)(Addr a , SizeT len ) ) ;
extern void vgPlain_track_new_mem_stack_4_w_ECU(void ( __attribute__((__regparm__(2))) (*f))(Addr new_ESP ,
                                                                                             UInt ecu ) ) ;
extern void vgPlain_track_new_mem_stack_8_w_ECU(void ( __attribute__((__regparm__(2))) (*f))(Addr new_ESP ,
                                                                                             UInt ecu ) ) ;
extern void vgPlain_track_new_mem_stack_12_w_ECU(void ( __attribute__((__regparm__(2))) (*f))(Addr new_ESP ,
                                                                                              UInt ecu ) ) ;
extern void vgPlain_track_new_mem_stack_16_w_ECU(void ( __attribute__((__regparm__(2))) (*f))(Addr new_ESP ,
                                                                                              UInt ecu ) ) ;
extern void vgPlain_track_new_mem_stack_32_w_ECU(void ( __attribute__((__regparm__(2))) (*f))(Addr new_ESP ,
                                                                                              UInt ecu ) ) ;
extern void vgPlain_track_new_mem_stack_112_w_ECU(void ( __attribute__((__regparm__(2))) (*f))(Addr new_ESP ,
                                                                                               UInt ecu ) ) ;
extern void vgPlain_track_new_mem_stack_128_w_ECU(void ( __attribute__((__regparm__(2))) (*f))(Addr new_ESP ,
                                                                                               UInt ecu ) ) ;
extern void vgPlain_track_new_mem_stack_144_w_ECU(void ( __attribute__((__regparm__(2))) (*f))(Addr new_ESP ,
                                                                                               UInt ecu ) ) ;
extern void vgPlain_track_new_mem_stack_160_w_ECU(void ( __attribute__((__regparm__(2))) (*f))(Addr new_ESP ,
                                                                                               UInt ecu ) ) ;
extern void vgPlain_track_new_mem_stack_w_ECU(void (*f)(Addr a , SizeT len ,
                                                        UInt ecu ) ) ;
extern void vgPlain_track_new_mem_stack_4(void ( __attribute__((__regparm__(1))) (*f))(Addr new_ESP ) ) ;
extern void vgPlain_track_new_mem_stack_8(void ( __attribute__((__regparm__(1))) (*f))(Addr new_ESP ) ) ;
extern void vgPlain_track_new_mem_stack_12(void ( __attribute__((__regparm__(1))) (*f))(Addr new_ESP ) ) ;
extern void vgPlain_track_new_mem_stack_16(void ( __attribute__((__regparm__(1))) (*f))(Addr new_ESP ) ) ;
extern void vgPlain_track_new_mem_stack_32(void ( __attribute__((__regparm__(1))) (*f))(Addr new_ESP ) ) ;
extern void vgPlain_track_new_mem_stack_112(void ( __attribute__((__regparm__(1))) (*f))(Addr new_ESP ) ) ;
extern void vgPlain_track_new_mem_stack_128(void ( __attribute__((__regparm__(1))) (*f))(Addr new_ESP ) ) ;
extern void vgPlain_track_new_mem_stack_144(void ( __attribute__((__regparm__(1))) (*f))(Addr new_ESP ) ) ;
extern void vgPlain_track_new_mem_stack_160(void ( __attribute__((__regparm__(1))) (*f))(Addr new_ESP ) ) ;
extern void vgPlain_track_new_mem_stack(void (*f)(Addr a , SizeT len ) ) ;
extern void vgPlain_track_die_mem_stack_4(void ( __attribute__((__regparm__(1))) (*f))(Addr die_ESP ) ) ;
extern void vgPlain_track_die_mem_stack_8(void ( __attribute__((__regparm__(1))) (*f))(Addr die_ESP ) ) ;
extern void vgPlain_track_die_mem_stack_12(void ( __attribute__((__regparm__(1))) (*f))(Addr die_ESP ) ) ;
extern void vgPlain_track_die_mem_stack_16(void ( __attribute__((__regparm__(1))) (*f))(Addr die_ESP ) ) ;
extern void vgPlain_track_die_mem_stack_32(void ( __attribute__((__regparm__(1))) (*f))(Addr die_ESP ) ) ;
extern void vgPlain_track_die_mem_stack_112(void ( __attribute__((__regparm__(1))) (*f))(Addr die_ESP ) ) ;
extern void vgPlain_track_die_mem_stack_128(void ( __attribute__((__regparm__(1))) (*f))(Addr die_ESP ) ) ;
extern void vgPlain_track_die_mem_stack_144(void ( __attribute__((__regparm__(1))) (*f))(Addr die_ESP ) ) ;
extern void vgPlain_track_die_mem_stack_160(void ( __attribute__((__regparm__(1))) (*f))(Addr die_ESP ) ) ;
extern void vgPlain_track_die_mem_stack(void (*f)(Addr a , SizeT len ) ) ;
extern void vgPlain_track_ban_mem_stack(void (*f)(Addr a , SizeT len ) ) ;
extern void vgPlain_track_pre_mem_read(void (*f)(CorePart part , ThreadId tid ,
                                                 Char *s , Addr a , SizeT size ) ) ;
extern void vgPlain_track_pre_mem_read_asciiz(void (*f)(CorePart part ,
                                                        ThreadId tid , Char *s ,
                                                        Addr a ) ) ;
extern void vgPlain_track_pre_mem_write(void (*f)(CorePart part , ThreadId tid ,
                                                  Char *s , Addr a , SizeT size ) ) ;
extern void vgPlain_track_post_mem_write(void (*f)(CorePart part ,
                                                   ThreadId tid , Addr a ,
                                                   SizeT size ) ) ;
extern void vgPlain_track_pre_reg_read(void (*f)(CorePart part , ThreadId tid ,
                                                 Char *s ,
                                                 PtrdiffT guest_state_offset ,
                                                 SizeT size ) ) ;
extern void vgPlain_track_post_reg_write(void (*f)(CorePart part ,
                                                   ThreadId tid ,
                                                   PtrdiffT guest_state_offset ,
                                                   SizeT size ) ) ;
extern void vgPlain_track_post_reg_write_clientcall_return(void (*f)(ThreadId tid ,
                                                                     PtrdiffT guest_state_offset ,
                                                                     SizeT size ,
                                                                     Addr f ) ) ;
extern void vgPlain_track_start_client_code(void (*f)(ThreadId tid ,
                                                      ULong blocks_dispatched ) ) ;
extern void vgPlain_track_stop_client_code(void (*f)(ThreadId tid ,
                                                     ULong blocks_dispatched ) ) ;
extern void vgPlain_track_pre_thread_ll_create(void (*f)(ThreadId tid ,
                                                         ThreadId child ) ) ;
extern void vgPlain_track_pre_thread_first_insn(void (*f)(ThreadId tid ) ) ;
extern void vgPlain_track_pre_thread_ll_exit(void (*f)(ThreadId tid ) ) ;
extern void vgPlain_track_pre_deliver_signal(void (*f)(ThreadId tid ,
                                                       Int sigNo ,
                                                       Bool alt_stack ) ) ;
extern void vgPlain_track_post_deliver_signal(void (*f)(ThreadId tid ,
                                                        Int sigNo ) ) ;
extern VgDetails vgPlain_details ;
extern VgNeeds vgPlain_needs ;
extern VgToolInterface vgPlain_tdict ;
extern Bool vgPlain_sanity_check_needs(Char **failmsg ) ;
extern Int vgPlain_clo_verbosity ;
extern Bool vgPlain_clo_stats ;
extern Int vgPlain_clo_vgdb_error ;
extern Bool vgPlain_clo_xml ;
extern HChar *vgPlain_clo_xml_user_comment ;
extern VexControl vgPlain_clo_vex_control ;
extern Int vgPlain_clo_backtrace_size ;
extern Bool vgPlain_clo_show_below_main ;
extern Char *vgPlain_expand_file_name(Char *option_name , Char *format ) ;
extern Bool vgPlain_clo_error_limit ;
extern Int vgPlain_clo_error_exitcode ;
extern VgVgdb vgPlain_clo_vgdb ;
extern Int vgPlain_clo_vgdb_poll ;
extern HChar *vgPlain_clo_vgdb_prefix ;
extern Bool vgPlain_clo_vgdb_shadow_registers ;
extern Bool vgPlain_clo_db_attach ;
extern Char *vgPlain_clo_db_command ;
extern Int vgPlain_clo_gen_suppressions ;
extern Int vgPlain_clo_sanity_level ;
extern Bool vgPlain_clo_demangle ;
extern Bool vgPlain_clo_trace_children ;
extern HChar *vgPlain_clo_trace_children_skip ;
extern HChar *vgPlain_clo_trace_children_skip_by_arg ;
extern Bool vgPlain_clo_child_silent_after_fork ;
extern Char *vgPlain_clo_log_fname_expanded ;
extern Char *vgPlain_clo_xml_fname_expanded ;
extern Bool vgPlain_clo_time_stamp ;
extern Int vgPlain_clo_input_fd ;
extern Int vgPlain_clo_n_suppressions ;
extern Char *vgPlain_clo_suppressions[100] ;
extern Int vgPlain_clo_n_fullpath_after ;
extern Char *vgPlain_clo_fullpath_after[100] ;
extern UChar vgPlain_clo_trace_flags ;
extern UChar vgPlain_clo_profile_flags ;
extern Int vgPlain_clo_trace_notbelow ;
extern Bool vgPlain_clo_trace_syscalls ;
extern Bool vgPlain_clo_trace_signals ;
extern Bool vgPlain_clo_trace_symtab ;
extern HChar *vgPlain_clo_trace_symtab_patt ;
extern Bool vgPlain_clo_trace_cfi ;
extern Bool vgPlain_clo_debug_dump_syms ;
extern Bool vgPlain_clo_debug_dump_line ;
extern Bool vgPlain_clo_debug_dump_frames ;
extern Bool vgPlain_clo_trace_redir ;
extern enum FairSchedType vgPlain_clo_fair_sched ;
extern Bool vgPlain_clo_trace_sched ;
extern Bool vgPlain_clo_profile_heap ;
extern Int vgPlain_clo_dump_error ;
extern Char *vgPlain_clo_sim_hints ;
extern Bool vgPlain_clo_sym_offsets ;
extern Bool vgPlain_clo_read_var_info ;
extern Char *vgPlain_clo_prefix_to_strip ;
extern Int vgPlain_clo_n_req_tsyms ;
extern HChar *vgPlain_clo_req_tsyms[100] ;
extern Bool vgPlain_clo_track_fds ;
extern Bool vgPlain_clo_run_libc_freeres ;
extern Bool vgPlain_clo_show_emwarns ;
extern Word vgPlain_clo_max_stackframe ;
extern Word vgPlain_clo_main_stacksize ;
extern Bool vgPlain_clo_wait_for_gdb ;
extern VgSmc vgPlain_clo_smc_check ;
extern HChar *vgPlain_clo_kernel_variant ;
extern Bool vgPlain_clo_dsymutil ;
extern Bool vgPlain_should_we_trace_this_child(HChar *child_exe_name ,
                                               HChar **child_argv ) ;
extern ThreadId vgPlain_alloc_ThreadState(void) ;
extern void vgPlain_exit_thread(ThreadId tid ) ;
extern void vgPlain_get_thread_out_of_syscall(ThreadId tid ) ;
extern void vgPlain_nuke_all_threads_except(ThreadId me ,
                                            VgSchedReturnCode reason ) ;
extern void vgPlain_acquire_BigLock(ThreadId tid , HChar *who ) ;
extern void vgPlain_acquire_BigLock_LL(HChar *who ) ;
extern void vgPlain_release_BigLock(ThreadId tid , ThreadStatus state ,
                                    HChar *who ) ;
extern void vgPlain_release_BigLock_LL(HChar *who ) ;
extern void vgPlain_vg_yield(void) ;
extern VgSchedReturnCode vgPlain_scheduler(ThreadId tid ) ;
extern ThreadId vgPlain_scheduler_init_phase1(void) ;
extern void vgPlain_scheduler_init_phase2(ThreadId main_tid , Addr clstack_end ,
                                          SizeT clstack_size ) ;
extern void vgPlain_disable_vgdb_poll(void) ;
extern void vgPlain_force_vgdb_poll(void) ;
extern void vgPlain_print_scheduler_stats(void) ;
extern Bool vgPlain_in_generated_code ;
extern void vgPlain_sanity_check_general(Bool force_expensive ) ;
extern void vgPlain_set_fault_catcher(void (*catcher)(Int sig , Addr addr ) ) ;
extern Int vgPlain_max_signal ;
extern void vgPlain_sigstartup_actions(void) ;
extern void vgPlain_poll_signals(ThreadId  ) ;
extern SysRes vgPlain_do_sys_sigaltstack(ThreadId tid , vki_stack_t *ss ,
                                         vki_stack_t *oss ) ;
extern SysRes vgPlain_do_sys_sigaction(Int signo ,
                                       vki_sigaction_toK_t const   *new_act ,
                                       vki_sigaction_fromK_t *old_act ) ;
extern SysRes vgPlain_do_sys_sigprocmask(ThreadId tid , Int how ,
                                         vki_sigset_t *set ,
                                         vki_sigset_t *oldset ) ;
extern void vgPlain_clear_out_queued_signals(ThreadId tid ,
                                             vki_sigset_t *saved_mask ) ;
extern void vgPlain_kill_self(Int sigNo ) ;
extern void vgPlain_synth_fault(ThreadId tid ) ;
extern void vgPlain_synth_fault_mapping(ThreadId tid , Addr addr ) ;
extern void vgPlain_synth_fault_perms(ThreadId tid , Addr addr ) ;
extern void vgPlain_synth_sigill(ThreadId tid , Addr addr ) ;
extern void vgPlain_synth_sigtrap(ThreadId tid ) ;
extern void vgPlain_synth_sigbus(ThreadId tid ) ;
extern Bool vgPlain_extend_stack(Addr addr , UInt maxsize ) ;
extern void vgPlain_set_default_handler(Int sig ) ;
extern SysRes vgPlain_do_syscall(UWord sysno , UWord  , UWord  , UWord  ,
                                 UWord  , UWord  , UWord  , UWord  , UWord  ) ;
extern SysRes vgPlain_mk_SysRes_x86_linux(Int val ) ;
extern SysRes vgPlain_mk_SysRes_amd64_linux(Long val ) ;
extern SysRes vgPlain_mk_SysRes_ppc32_linux(UInt val , UInt cr0so ) ;
extern SysRes vgPlain_mk_SysRes_ppc64_linux(ULong val , ULong cr0so ) ;
extern SysRes vgPlain_mk_SysRes_arm_linux(Int val ) ;
extern SysRes vgPlain_mk_SysRes_x86_darwin(UChar scclass , Bool isErr ,
                                           UInt wHI , UInt wLO ) ;
extern SysRes vgPlain_mk_SysRes_amd64_darwin(UChar scclass , Bool isErr ,
                                             ULong wHI , ULong wLO ) ;
extern SysRes vgPlain_mk_SysRes_s390x_linux(Long val ) ;
extern SysRes vgPlain_mk_SysRes_Error(UWord val ) ;
extern SysRes vgPlain_mk_SysRes_Success(UWord val ) ;
extern HChar const   *vgPlain_strerror(UWord errnum ) ;
void vgPlain_main_thread_wrapper_NORETURN(ThreadId tid ) ;
extern void vgPlain_client_syscall(ThreadId tid , UInt trc ) ;
extern void vgPlain_post_syscall(ThreadId tid ) ;
extern void vgPlain_clear_syscallInfo(Int tid ) ;
extern void vgPlain_fixup_guest_state_after_syscall_interrupted(ThreadId tid ,
                                                                Addr ip ,
                                                                SysRes sysret ,
                                                                Bool restart ) ;
extern void vgPlain_reap_threads(ThreadId self ) ;
extern void vgPlain_cleanup_thread(ThreadArchState * ) ;
extern void vgPlain_init_preopened_fds(void) ;
extern void vgPlain_show_open_fds(void) ;
extern void (*vgPlain_address_of_m_main_shutdown_actions_NORETURN)(ThreadId  ,
                                                                   VgSchedReturnCode  ) ;
extern SyscallTableEntry *vgModuleLocal_get_linux_syscall_entry(UInt sysno ) ;
__inline static UWord getRES(SyscallStatus *st ) 
{ 
  long tmp ;
  Bool tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  UWord tmp___3 ;

  {
  tmp = __builtin_expect((long )(! (! ((unsigned int )st->what == 1U))), 1L);
  if (tmp) {

  } else {
    vgPlain_assert_fail((Bool )1, (Char const   *)"st->what == SsComplete",
                        (Char const   *)"m_syswrap/priv_types_n_macros.h", 305,
                        (Char const   *)"getRES", "");
  }
  tmp___0 = sr_isError(st->sres);
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  tmp___2 = __builtin_expect((long )tmp___1, 1L);
  if (tmp___2) {

  } else {
    vgPlain_assert_fail((Bool )1, (Char const   *)"!sr_isError(st->sres)",
                        (Char const   *)"m_syswrap/priv_types_n_macros.h", 306,
                        (Char const   *)"getRES", "");
  }
  tmp___3 = sr_Res(st->sres);
  return (tmp___3);
}
}
__inline static UWord getRESHI(SyscallStatus *st ) 
{ 
  long tmp ;
  Bool tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  UWord tmp___3 ;

  {
  tmp = __builtin_expect((long )(! (! ((unsigned int )st->what == 1U))), 1L);
  if (tmp) {

  } else {
    vgPlain_assert_fail((Bool )1, (Char const   *)"st->what == SsComplete",
                        (Char const   *)"m_syswrap/priv_types_n_macros.h", 311,
                        (Char const   *)"getRESHI", "");
  }
  tmp___0 = sr_isError(st->sres);
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  tmp___2 = __builtin_expect((long )tmp___1, 1L);
  if (tmp___2) {

  } else {
    vgPlain_assert_fail((Bool )1, (Char const   *)"!sr_isError(st->sres)",
                        (Char const   *)"m_syswrap/priv_types_n_macros.h", 312,
                        (Char const   *)"getRESHI", "");
  }
  tmp___3 = sr_ResHI(st->sres);
  return (tmp___3);
}
}
__inline static UWord getERR(SyscallStatus *st ) 
{ 
  long tmp ;
  Bool tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  UWord tmp___3 ;

  {
  tmp = __builtin_expect((long )(! (! ((unsigned int )st->what == 1U))), 1L);
  if (tmp) {

  } else {
    vgPlain_assert_fail((Bool )1, (Char const   *)"st->what == SsComplete",
                        (Char const   *)"m_syswrap/priv_types_n_macros.h", 317,
                        (Char const   *)"getERR", "");
  }
  tmp___0 = sr_isError(st->sres);
  if (tmp___0) {
    tmp___1 = 1;
  } else {
    tmp___1 = 0;
  }
  tmp___2 = __builtin_expect((long )tmp___1, 1L);
  if (tmp___2) {

  } else {
    vgPlain_assert_fail((Bool )1, (Char const   *)"sr_isError(st->sres)",
                        (Char const   *)"m_syswrap/priv_types_n_macros.h", 318,
                        (Char const   *)"getERR", "");
  }
  tmp___3 = sr_Err(st->sres);
  return (tmp___3);
}
}
extern Bool vgModuleLocal_valid_client_addr(Addr start , SizeT size ,
                                            ThreadId tid ,
                                            Char const   *syscallname ) ;
extern Bool vgModuleLocal_safe_to_deref(void *start , SizeT size ) ;
extern Bool vgModuleLocal_client_signal_OK(Int sigNo ) ;
extern Bool vgModuleLocal_fd_allowed(Int fd , Char const   *syscallname ,
                                     ThreadId tid , Bool isNewFD ) ;
extern void vgModuleLocal_record_fd_open_named(ThreadId tid , Int fd ) ;
extern void vgModuleLocal_record_fd_open_nameless(ThreadId tid , Int fd ) ;
extern void vgModuleLocal_record_fd_open_with_given_name(ThreadId tid , Int fd ,
                                                         char *pathname ) ;
extern Bool vgModuleLocal_do_sigkill(Int pid , Int tgid ) ;
extern void vgModuleLocal_notify_core_and_tool_of_mmap(Addr a , SizeT len ,
                                                       UInt prot ,
                                                       UInt mm_flags , Int fd ,
                                                       Off64T offset ) ;
extern void vgModuleLocal_notify_core_and_tool_of_munmap(Addr a , SizeT len ) ;
extern void vgModuleLocal_notify_core_and_tool_of_mprotect(Addr a , SizeT len ,
                                                           Int prot ) ;
extern void vgModuleLocal_buf_and_len_pre_check(ThreadId tid , Addr buf_p ,
                                                Addr buflen_p , Char *buf_s ,
                                                Char *buflen_s ) ;
extern void vgModuleLocal_buf_and_len_post_check(ThreadId tid , SysRes res ,
                                                 Addr buf_p , Addr buflen_p ,
                                                 Char *s ) ;
extern void vgModuleLocal_PRE_unknown_ioctl(ThreadId tid , UWord request ,
                                            UWord arg ) ;
extern void vgModuleLocal_POST_unknown_ioctl(ThreadId tid , UInt res ,
                                             UWord request , UWord arg ) ;
extern void vgSysWrap_generic_sys_ni_syscall_before(ThreadId tid ,
                                                    SyscallArgLayout *layout ,
                                                    SyscallArgs *arrghs ,
                                                    SyscallStatus *status ,
                                                    UWord *flags ) ;
extern void vgSysWrap_generic_sys_ni_syscall_after(ThreadId tid ,
                                                   SyscallArgs *arrghs ,
                                                   SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_exit_before(ThreadId tid ,
                                              SyscallArgLayout *layout ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ,
                                              UWord *flags ) ;
extern void vgSysWrap_generic_sys_exit_after(ThreadId tid ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_fork_before(ThreadId tid ,
                                              SyscallArgLayout *layout ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ,
                                              UWord *flags ) ;
extern void vgSysWrap_generic_sys_fork_after(ThreadId tid ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_read_before(ThreadId tid ,
                                              SyscallArgLayout *layout ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ,
                                              UWord *flags ) ;
extern void vgSysWrap_generic_sys_read_after(ThreadId tid ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_write_before(ThreadId tid ,
                                               SyscallArgLayout *layout ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ,
                                               UWord *flags ) ;
extern void vgSysWrap_generic_sys_write_after(ThreadId tid ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_open_before(ThreadId tid ,
                                              SyscallArgLayout *layout ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ,
                                              UWord *flags ) ;
extern void vgSysWrap_generic_sys_open_after(ThreadId tid ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_close_before(ThreadId tid ,
                                               SyscallArgLayout *layout ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ,
                                               UWord *flags ) ;
extern void vgSysWrap_generic_sys_close_after(ThreadId tid ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_waitpid_before(ThreadId tid ,
                                                 SyscallArgLayout *layout ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ,
                                                 UWord *flags ) ;
extern void vgSysWrap_generic_sys_waitpid_after(ThreadId tid ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_creat_before(ThreadId tid ,
                                               SyscallArgLayout *layout ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ,
                                               UWord *flags ) ;
extern void vgSysWrap_generic_sys_creat_after(ThreadId tid ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_link_before(ThreadId tid ,
                                              SyscallArgLayout *layout ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ,
                                              UWord *flags ) ;
extern void vgSysWrap_generic_sys_link_after(ThreadId tid ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_unlink_before(ThreadId tid ,
                                                SyscallArgLayout *layout ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ,
                                                UWord *flags ) ;
extern void vgSysWrap_generic_sys_unlink_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_execve_before(ThreadId tid ,
                                                SyscallArgLayout *layout ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ,
                                                UWord *flags ) ;
extern void vgSysWrap_generic_sys_execve_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_chdir_before(ThreadId tid ,
                                               SyscallArgLayout *layout ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ,
                                               UWord *flags ) ;
extern void vgSysWrap_generic_sys_chdir_after(ThreadId tid ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_time_before(ThreadId tid ,
                                              SyscallArgLayout *layout ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ,
                                              UWord *flags ) ;
extern void vgSysWrap_generic_sys_time_after(ThreadId tid ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_mknod_before(ThreadId tid ,
                                               SyscallArgLayout *layout ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ,
                                               UWord *flags ) ;
extern void vgSysWrap_generic_sys_mknod_after(ThreadId tid ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_chmod_before(ThreadId tid ,
                                               SyscallArgLayout *layout ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ,
                                               UWord *flags ) ;
extern void vgSysWrap_generic_sys_chmod_after(ThreadId tid ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_getpid_before(ThreadId tid ,
                                                SyscallArgLayout *layout ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ,
                                                UWord *flags ) ;
extern void vgSysWrap_generic_sys_getpid_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_alarm_before(ThreadId tid ,
                                               SyscallArgLayout *layout ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ,
                                               UWord *flags ) ;
extern void vgSysWrap_generic_sys_alarm_after(ThreadId tid ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_pause_before(ThreadId tid ,
                                               SyscallArgLayout *layout ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ,
                                               UWord *flags ) ;
extern void vgSysWrap_generic_sys_pause_after(ThreadId tid ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_access_before(ThreadId tid ,
                                                SyscallArgLayout *layout ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ,
                                                UWord *flags ) ;
extern void vgSysWrap_generic_sys_access_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_kill_before(ThreadId tid ,
                                              SyscallArgLayout *layout ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ,
                                              UWord *flags ) ;
extern void vgSysWrap_generic_sys_kill_after(ThreadId tid ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_rename_before(ThreadId tid ,
                                                SyscallArgLayout *layout ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ,
                                                UWord *flags ) ;
extern void vgSysWrap_generic_sys_rename_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_mkdir_before(ThreadId tid ,
                                               SyscallArgLayout *layout ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ,
                                               UWord *flags ) ;
extern void vgSysWrap_generic_sys_mkdir_after(ThreadId tid ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_rmdir_before(ThreadId tid ,
                                               SyscallArgLayout *layout ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ,
                                               UWord *flags ) ;
extern void vgSysWrap_generic_sys_rmdir_after(ThreadId tid ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_dup_before(ThreadId tid ,
                                             SyscallArgLayout *layout ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ,
                                             UWord *flags ) ;
extern void vgSysWrap_generic_sys_dup_after(ThreadId tid , SyscallArgs *arrghs ,
                                            SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_times_before(ThreadId tid ,
                                               SyscallArgLayout *layout ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ,
                                               UWord *flags ) ;
extern void vgSysWrap_generic_sys_times_after(ThreadId tid ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_setpgid_before(ThreadId tid ,
                                                 SyscallArgLayout *layout ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ,
                                                 UWord *flags ) ;
extern void vgSysWrap_generic_sys_setpgid_after(ThreadId tid ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_umask_before(ThreadId tid ,
                                               SyscallArgLayout *layout ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ,
                                               UWord *flags ) ;
extern void vgSysWrap_generic_sys_umask_after(ThreadId tid ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_dup2_before(ThreadId tid ,
                                              SyscallArgLayout *layout ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ,
                                              UWord *flags ) ;
extern void vgSysWrap_generic_sys_dup2_after(ThreadId tid ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_getppid_before(ThreadId tid ,
                                                 SyscallArgLayout *layout ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ,
                                                 UWord *flags ) ;
extern void vgSysWrap_generic_sys_getppid_after(ThreadId tid ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_getpgrp_before(ThreadId tid ,
                                                 SyscallArgLayout *layout ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ,
                                                 UWord *flags ) ;
extern void vgSysWrap_generic_sys_getpgrp_after(ThreadId tid ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_setsid_before(ThreadId tid ,
                                                SyscallArgLayout *layout ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ,
                                                UWord *flags ) ;
extern void vgSysWrap_generic_sys_setsid_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_munmap_before(ThreadId tid ,
                                                SyscallArgLayout *layout ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ,
                                                UWord *flags ) ;
extern void vgSysWrap_generic_sys_munmap_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_truncate_before(ThreadId tid ,
                                                  SyscallArgLayout *layout ,
                                                  SyscallArgs *arrghs ,
                                                  SyscallStatus *status ,
                                                  UWord *flags ) ;
extern void vgSysWrap_generic_sys_truncate_after(ThreadId tid ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_ftruncate_before(ThreadId tid ,
                                                   SyscallArgLayout *layout ,
                                                   SyscallArgs *arrghs ,
                                                   SyscallStatus *status ,
                                                   UWord *flags ) ;
extern void vgSysWrap_generic_sys_ftruncate_after(ThreadId tid ,
                                                  SyscallArgs *arrghs ,
                                                  SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_fchmod_before(ThreadId tid ,
                                                SyscallArgLayout *layout ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ,
                                                UWord *flags ) ;
extern void vgSysWrap_generic_sys_fchmod_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_msync_before(ThreadId tid ,
                                               SyscallArgLayout *layout ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ,
                                               UWord *flags ) ;
extern void vgSysWrap_generic_sys_msync_after(ThreadId tid ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_readv_before(ThreadId tid ,
                                               SyscallArgLayout *layout ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ,
                                               UWord *flags ) ;
extern void vgSysWrap_generic_sys_readv_after(ThreadId tid ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_writev_before(ThreadId tid ,
                                                SyscallArgLayout *layout ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ,
                                                UWord *flags ) ;
extern void vgSysWrap_generic_sys_writev_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_getsid_before(ThreadId tid ,
                                                SyscallArgLayout *layout ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ,
                                                UWord *flags ) ;
extern void vgSysWrap_generic_sys_getsid_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_fdatasync_before(ThreadId tid ,
                                                   SyscallArgLayout *layout ,
                                                   SyscallArgs *arrghs ,
                                                   SyscallStatus *status ,
                                                   UWord *flags ) ;
extern void vgSysWrap_generic_sys_fdatasync_after(ThreadId tid ,
                                                  SyscallArgs *arrghs ,
                                                  SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_mlock_before(ThreadId tid ,
                                               SyscallArgLayout *layout ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ,
                                               UWord *flags ) ;
extern void vgSysWrap_generic_sys_mlock_after(ThreadId tid ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_munlock_before(ThreadId tid ,
                                                 SyscallArgLayout *layout ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ,
                                                 UWord *flags ) ;
extern void vgSysWrap_generic_sys_munlock_after(ThreadId tid ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_mlockall_before(ThreadId tid ,
                                                  SyscallArgLayout *layout ,
                                                  SyscallArgs *arrghs ,
                                                  SyscallStatus *status ,
                                                  UWord *flags ) ;
extern void vgSysWrap_generic_sys_mlockall_after(ThreadId tid ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_nanosleep_before(ThreadId tid ,
                                                   SyscallArgLayout *layout ,
                                                   SyscallArgs *arrghs ,
                                                   SyscallStatus *status ,
                                                   UWord *flags ) ;
extern void vgSysWrap_generic_sys_nanosleep_after(ThreadId tid ,
                                                  SyscallArgs *arrghs ,
                                                  SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_mremap_before(ThreadId tid ,
                                                SyscallArgLayout *layout ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ,
                                                UWord *flags ) ;
extern void vgSysWrap_generic_sys_mremap_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_getuid_before(ThreadId tid ,
                                                SyscallArgLayout *layout ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ,
                                                UWord *flags ) ;
extern void vgSysWrap_generic_sys_getuid_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_getgid_before(ThreadId tid ,
                                                SyscallArgLayout *layout ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ,
                                                UWord *flags ) ;
extern void vgSysWrap_generic_sys_getgid_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_geteuid_before(ThreadId tid ,
                                                 SyscallArgLayout *layout ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ,
                                                 UWord *flags ) ;
extern void vgSysWrap_generic_sys_geteuid_after(ThreadId tid ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_getegid_before(ThreadId tid ,
                                                 SyscallArgLayout *layout ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ,
                                                 UWord *flags ) ;
extern void vgSysWrap_generic_sys_getegid_after(ThreadId tid ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_getpgid_before(ThreadId tid ,
                                                 SyscallArgLayout *layout ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ,
                                                 UWord *flags ) ;
extern void vgSysWrap_generic_sys_getpgid_after(ThreadId tid ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_fsync_before(ThreadId tid ,
                                               SyscallArgLayout *layout ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ,
                                               UWord *flags ) ;
extern void vgSysWrap_generic_sys_fsync_after(ThreadId tid ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_wait4_before(ThreadId tid ,
                                               SyscallArgLayout *layout ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ,
                                               UWord *flags ) ;
extern void vgSysWrap_generic_sys_wait4_after(ThreadId tid ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_mprotect_before(ThreadId tid ,
                                                  SyscallArgLayout *layout ,
                                                  SyscallArgs *arrghs ,
                                                  SyscallStatus *status ,
                                                  UWord *flags ) ;
extern void vgSysWrap_generic_sys_mprotect_after(ThreadId tid ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_getcwd_before(ThreadId tid ,
                                                SyscallArgLayout *layout ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ,
                                                UWord *flags ) ;
extern void vgSysWrap_generic_sys_getcwd_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_symlink_before(ThreadId tid ,
                                                 SyscallArgLayout *layout ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ,
                                                 UWord *flags ) ;
extern void vgSysWrap_generic_sys_symlink_after(ThreadId tid ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_getgroups_before(ThreadId tid ,
                                                   SyscallArgLayout *layout ,
                                                   SyscallArgs *arrghs ,
                                                   SyscallStatus *status ,
                                                   UWord *flags ) ;
extern void vgSysWrap_generic_sys_getgroups_after(ThreadId tid ,
                                                  SyscallArgs *arrghs ,
                                                  SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_setgroups_before(ThreadId tid ,
                                                   SyscallArgLayout *layout ,
                                                   SyscallArgs *arrghs ,
                                                   SyscallStatus *status ,
                                                   UWord *flags ) ;
extern void vgSysWrap_generic_sys_setgroups_after(ThreadId tid ,
                                                  SyscallArgs *arrghs ,
                                                  SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_chown_before(ThreadId tid ,
                                               SyscallArgLayout *layout ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ,
                                               UWord *flags ) ;
extern void vgSysWrap_generic_sys_chown_after(ThreadId tid ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_setuid_before(ThreadId tid ,
                                                SyscallArgLayout *layout ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ,
                                                UWord *flags ) ;
extern void vgSysWrap_generic_sys_setuid_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_gettimeofday_before(ThreadId tid ,
                                                      SyscallArgLayout *layout ,
                                                      SyscallArgs *arrghs ,
                                                      SyscallStatus *status ,
                                                      UWord *flags ) ;
extern void vgSysWrap_generic_sys_gettimeofday_after(ThreadId tid ,
                                                     SyscallArgs *arrghs ,
                                                     SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_madvise_before(ThreadId tid ,
                                                 SyscallArgLayout *layout ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ,
                                                 UWord *flags ) ;
extern void vgSysWrap_generic_sys_madvise_after(ThreadId tid ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_nice_before(ThreadId tid ,
                                              SyscallArgLayout *layout ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ,
                                              UWord *flags ) ;
extern void vgSysWrap_generic_sys_nice_after(ThreadId tid ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_sync_before(ThreadId tid ,
                                              SyscallArgLayout *layout ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ,
                                              UWord *flags ) ;
extern void vgSysWrap_generic_sys_sync_after(ThreadId tid ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_brk_before(ThreadId tid ,
                                             SyscallArgLayout *layout ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ,
                                             UWord *flags ) ;
extern void vgSysWrap_generic_sys_brk_after(ThreadId tid , SyscallArgs *arrghs ,
                                            SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_acct_before(ThreadId tid ,
                                              SyscallArgLayout *layout ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ,
                                              UWord *flags ) ;
extern void vgSysWrap_generic_sys_acct_after(ThreadId tid ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_chroot_before(ThreadId tid ,
                                                SyscallArgLayout *layout ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ,
                                                UWord *flags ) ;
extern void vgSysWrap_generic_sys_chroot_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_readlink_before(ThreadId tid ,
                                                  SyscallArgLayout *layout ,
                                                  SyscallArgs *arrghs ,
                                                  SyscallStatus *status ,
                                                  UWord *flags ) ;
extern void vgSysWrap_generic_sys_readlink_after(ThreadId tid ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_fchdir_before(ThreadId tid ,
                                                SyscallArgLayout *layout ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ,
                                                UWord *flags ) ;
extern void vgSysWrap_generic_sys_fchdir_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_getdents_before(ThreadId tid ,
                                                  SyscallArgLayout *layout ,
                                                  SyscallArgs *arrghs ,
                                                  SyscallStatus *status ,
                                                  UWord *flags ) ;
extern void vgSysWrap_generic_sys_getdents_after(ThreadId tid ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_select_before(ThreadId tid ,
                                                SyscallArgLayout *layout ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ,
                                                UWord *flags ) ;
extern void vgSysWrap_generic_sys_select_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_flock_before(ThreadId tid ,
                                               SyscallArgLayout *layout ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ,
                                               UWord *flags ) ;
extern void vgSysWrap_generic_sys_flock_after(ThreadId tid ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_poll_before(ThreadId tid ,
                                              SyscallArgLayout *layout ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ,
                                              UWord *flags ) ;
extern void vgSysWrap_generic_sys_poll_after(ThreadId tid ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_getrusage_before(ThreadId tid ,
                                                   SyscallArgLayout *layout ,
                                                   SyscallArgs *arrghs ,
                                                   SyscallStatus *status ,
                                                   UWord *flags ) ;
extern void vgSysWrap_generic_sys_getrusage_after(ThreadId tid ,
                                                  SyscallArgs *arrghs ,
                                                  SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_stime_before(ThreadId tid ,
                                               SyscallArgLayout *layout ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ,
                                               UWord *flags ) ;
extern void vgSysWrap_generic_sys_stime_after(ThreadId tid ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_settimeofday_before(ThreadId tid ,
                                                      SyscallArgLayout *layout ,
                                                      SyscallArgs *arrghs ,
                                                      SyscallStatus *status ,
                                                      UWord *flags ) ;
extern void vgSysWrap_generic_sys_settimeofday_after(ThreadId tid ,
                                                     SyscallArgs *arrghs ,
                                                     SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_getpriority_before(ThreadId tid ,
                                                     SyscallArgLayout *layout ,
                                                     SyscallArgs *arrghs ,
                                                     SyscallStatus *status ,
                                                     UWord *flags ) ;
extern void vgSysWrap_generic_sys_getpriority_after(ThreadId tid ,
                                                    SyscallArgs *arrghs ,
                                                    SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_setpriority_before(ThreadId tid ,
                                                     SyscallArgLayout *layout ,
                                                     SyscallArgs *arrghs ,
                                                     SyscallStatus *status ,
                                                     UWord *flags ) ;
extern void vgSysWrap_generic_sys_setpriority_after(ThreadId tid ,
                                                    SyscallArgs *arrghs ,
                                                    SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_setitimer_before(ThreadId tid ,
                                                   SyscallArgLayout *layout ,
                                                   SyscallArgs *arrghs ,
                                                   SyscallStatus *status ,
                                                   UWord *flags ) ;
extern void vgSysWrap_generic_sys_setitimer_after(ThreadId tid ,
                                                  SyscallArgs *arrghs ,
                                                  SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_getitimer_before(ThreadId tid ,
                                                   SyscallArgLayout *layout ,
                                                   SyscallArgs *arrghs ,
                                                   SyscallStatus *status ,
                                                   UWord *flags ) ;
extern void vgSysWrap_generic_sys_getitimer_after(ThreadId tid ,
                                                  SyscallArgs *arrghs ,
                                                  SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_setreuid_before(ThreadId tid ,
                                                  SyscallArgLayout *layout ,
                                                  SyscallArgs *arrghs ,
                                                  SyscallStatus *status ,
                                                  UWord *flags ) ;
extern void vgSysWrap_generic_sys_setreuid_after(ThreadId tid ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_setregid_before(ThreadId tid ,
                                                  SyscallArgLayout *layout ,
                                                  SyscallArgs *arrghs ,
                                                  SyscallStatus *status ,
                                                  UWord *flags ) ;
extern void vgSysWrap_generic_sys_setregid_after(ThreadId tid ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_fchown_before(ThreadId tid ,
                                                SyscallArgLayout *layout ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ,
                                                UWord *flags ) ;
extern void vgSysWrap_generic_sys_fchown_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_setgid_before(ThreadId tid ,
                                                SyscallArgLayout *layout ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ,
                                                UWord *flags ) ;
extern void vgSysWrap_generic_sys_setgid_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_utimes_before(ThreadId tid ,
                                                SyscallArgLayout *layout ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ,
                                                UWord *flags ) ;
extern void vgSysWrap_generic_sys_utimes_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_sigaction_before(ThreadId tid ,
                                                   SyscallArgLayout *layout ,
                                                   SyscallArgs *arrghs ,
                                                   SyscallStatus *status ,
                                                   UWord *flags ) ;
extern void vgSysWrap_generic_sys_sigaction_after(ThreadId tid ,
                                                  SyscallArgs *arrghs ,
                                                  SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_newstat_before(ThreadId tid ,
                                                 SyscallArgLayout *layout ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ,
                                                 UWord *flags ) ;
extern void vgSysWrap_generic_sys_newstat_after(ThreadId tid ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_newlstat_before(ThreadId tid ,
                                                  SyscallArgLayout *layout ,
                                                  SyscallArgs *arrghs ,
                                                  SyscallStatus *status ,
                                                  UWord *flags ) ;
extern void vgSysWrap_generic_sys_newlstat_after(ThreadId tid ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_newfstat_before(ThreadId tid ,
                                                  SyscallArgLayout *layout ,
                                                  SyscallArgs *arrghs ,
                                                  SyscallStatus *status ,
                                                  UWord *flags ) ;
extern void vgSysWrap_generic_sys_newfstat_after(ThreadId tid ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_ptrace_before(ThreadId tid ,
                                                SyscallArgLayout *layout ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ,
                                                UWord *flags ) ;
extern void vgSysWrap_generic_sys_ptrace_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_setrlimit_before(ThreadId tid ,
                                                   SyscallArgLayout *layout ,
                                                   SyscallArgs *arrghs ,
                                                   SyscallStatus *status ,
                                                   UWord *flags ) ;
extern void vgSysWrap_generic_sys_setrlimit_after(ThreadId tid ,
                                                  SyscallArgs *arrghs ,
                                                  SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_old_getrlimit_before(ThreadId tid ,
                                                       SyscallArgLayout *layout ,
                                                       SyscallArgs *arrghs ,
                                                       SyscallStatus *status ,
                                                       UWord *flags ) ;
extern void vgSysWrap_generic_sys_old_getrlimit_after(ThreadId tid ,
                                                      SyscallArgs *arrghs ,
                                                      SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_statfs_before(ThreadId tid ,
                                                SyscallArgLayout *layout ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ,
                                                UWord *flags ) ;
extern void vgSysWrap_generic_sys_statfs_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_fstatfs_before(ThreadId tid ,
                                                 SyscallArgLayout *layout ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ,
                                                 UWord *flags ) ;
extern void vgSysWrap_generic_sys_fstatfs_after(ThreadId tid ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_iopl_before(ThreadId tid ,
                                              SyscallArgLayout *layout ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ,
                                              UWord *flags ) ;
extern void vgSysWrap_generic_sys_iopl_after(ThreadId tid ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_ipc_before(ThreadId tid ,
                                             SyscallArgLayout *layout ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ,
                                             UWord *flags ) ;
extern void vgSysWrap_generic_sys_ipc_after(ThreadId tid , SyscallArgs *arrghs ,
                                            SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_newuname_before(ThreadId tid ,
                                                  SyscallArgLayout *layout ,
                                                  SyscallArgs *arrghs ,
                                                  SyscallStatus *status ,
                                                  UWord *flags ) ;
extern void vgSysWrap_generic_sys_newuname_after(ThreadId tid ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_pread64_before(ThreadId tid ,
                                                 SyscallArgLayout *layout ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ,
                                                 UWord *flags ) ;
extern void vgSysWrap_generic_sys_pread64_after(ThreadId tid ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_pwrite64_before(ThreadId tid ,
                                                  SyscallArgLayout *layout ,
                                                  SyscallArgs *arrghs ,
                                                  SyscallStatus *status ,
                                                  UWord *flags ) ;
extern void vgSysWrap_generic_sys_pwrite64_after(ThreadId tid ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_sigaltstack_before(ThreadId tid ,
                                                     SyscallArgLayout *layout ,
                                                     SyscallArgs *arrghs ,
                                                     SyscallStatus *status ,
                                                     UWord *flags ) ;
extern void vgSysWrap_generic_sys_sigaltstack_after(ThreadId tid ,
                                                    SyscallArgs *arrghs ,
                                                    SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_getpmsg_before(ThreadId tid ,
                                                 SyscallArgLayout *layout ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ,
                                                 UWord *flags ) ;
extern void vgSysWrap_generic_sys_getpmsg_after(ThreadId tid ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_putpmsg_before(ThreadId tid ,
                                                 SyscallArgLayout *layout ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ,
                                                 UWord *flags ) ;
extern void vgSysWrap_generic_sys_putpmsg_after(ThreadId tid ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_getrlimit_before(ThreadId tid ,
                                                   SyscallArgLayout *layout ,
                                                   SyscallArgs *arrghs ,
                                                   SyscallStatus *status ,
                                                   UWord *flags ) ;
extern void vgSysWrap_generic_sys_getrlimit_after(ThreadId tid ,
                                                  SyscallArgs *arrghs ,
                                                  SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_truncate64_before(ThreadId tid ,
                                                    SyscallArgLayout *layout ,
                                                    SyscallArgs *arrghs ,
                                                    SyscallStatus *status ,
                                                    UWord *flags ) ;
extern void vgSysWrap_generic_sys_truncate64_after(ThreadId tid ,
                                                   SyscallArgs *arrghs ,
                                                   SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_ftruncate64_before(ThreadId tid ,
                                                     SyscallArgLayout *layout ,
                                                     SyscallArgs *arrghs ,
                                                     SyscallStatus *status ,
                                                     UWord *flags ) ;
extern void vgSysWrap_generic_sys_ftruncate64_after(ThreadId tid ,
                                                    SyscallArgs *arrghs ,
                                                    SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_lchown_before(ThreadId tid ,
                                                SyscallArgLayout *layout ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ,
                                                UWord *flags ) ;
extern void vgSysWrap_generic_sys_lchown_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_mincore_before(ThreadId tid ,
                                                 SyscallArgLayout *layout ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ,
                                                 UWord *flags ) ;
extern void vgSysWrap_generic_sys_mincore_after(ThreadId tid ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_getdents64_before(ThreadId tid ,
                                                    SyscallArgLayout *layout ,
                                                    SyscallArgs *arrghs ,
                                                    SyscallStatus *status ,
                                                    UWord *flags ) ;
extern void vgSysWrap_generic_sys_getdents64_after(ThreadId tid ,
                                                   SyscallArgs *arrghs ,
                                                   SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_statfs64_before(ThreadId tid ,
                                                  SyscallArgLayout *layout ,
                                                  SyscallArgs *arrghs ,
                                                  SyscallStatus *status ,
                                                  UWord *flags ) ;
extern void vgSysWrap_generic_sys_statfs64_after(ThreadId tid ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ) ;
extern void vgSysWrap_generic_sys_fstatfs64_before(ThreadId tid ,
                                                   SyscallArgLayout *layout ,
                                                   SyscallArgs *arrghs ,
                                                   SyscallStatus *status ,
                                                   UWord *flags ) ;
extern void vgSysWrap_generic_sys_fstatfs64_after(ThreadId tid ,
                                                  SyscallArgs *arrghs ,
                                                  SyscallStatus *status ) ;
extern void vgModuleLocal_generic_PRE_sys_socketpair(ThreadId  , UWord  ,
                                                     UWord  , UWord  , UWord  ) ;
extern SysRes vgModuleLocal_generic_POST_sys_socketpair(ThreadId  , SysRes  ,
                                                        UWord  , UWord  ,
                                                        UWord  , UWord  ) ;
extern SysRes vgModuleLocal_generic_POST_sys_socket(ThreadId  , SysRes  ) ;
extern void vgModuleLocal_generic_PRE_sys_bind(ThreadId  , UWord  , UWord  ,
                                               UWord  ) ;
extern void vgModuleLocal_generic_PRE_sys_accept(ThreadId  , UWord  , UWord  ,
                                                 UWord  ) ;
extern SysRes vgModuleLocal_generic_POST_sys_accept(ThreadId  , SysRes  ,
                                                    UWord  , UWord  , UWord  ) ;
extern void vgModuleLocal_generic_PRE_sys_sendto(ThreadId  , UWord  , UWord  ,
                                                 UWord  , UWord  , UWord  ,
                                                 UWord  ) ;
extern void vgModuleLocal_generic_PRE_sys_send(ThreadId  , UWord  , UWord  ,
                                               UWord  ) ;
extern void vgModuleLocal_generic_PRE_sys_recvfrom(ThreadId  , UWord  , UWord  ,
                                                   UWord  , UWord  , UWord  ,
                                                   UWord  ) ;
extern void vgModuleLocal_generic_POST_sys_recvfrom(ThreadId  , SysRes  ,
                                                    UWord  , UWord  , UWord  ,
                                                    UWord  , UWord  , UWord  ) ;
extern void vgModuleLocal_generic_PRE_sys_recv(ThreadId  , UWord  , UWord  ,
                                               UWord  ) ;
extern void vgModuleLocal_generic_POST_sys_recv(ThreadId  , UWord  , UWord  ,
                                                UWord  , UWord  ) ;
extern void vgModuleLocal_generic_PRE_sys_connect(ThreadId  , UWord  , UWord  ,
                                                  UWord  ) ;
extern void vgModuleLocal_generic_PRE_sys_setsockopt(ThreadId  , UWord  ,
                                                     UWord  , UWord  , UWord  ,
                                                     UWord  ) ;
extern void vgModuleLocal_generic_PRE_sys_getsockname(ThreadId  , UWord  ,
                                                      UWord  , UWord  ) ;
extern void vgModuleLocal_generic_POST_sys_getsockname(ThreadId  , SysRes  ,
                                                       UWord  , UWord  , UWord  ) ;
extern void vgModuleLocal_generic_PRE_sys_getpeername(ThreadId  , UWord  ,
                                                      UWord  , UWord  ) ;
extern void vgModuleLocal_generic_POST_sys_getpeername(ThreadId  , SysRes  ,
                                                       UWord  , UWord  , UWord  ) ;
extern void vgModuleLocal_generic_PRE_sys_sendmsg(ThreadId  , Char * ,
                                                  struct vki_msghdr * ) ;
extern void vgModuleLocal_generic_PRE_sys_recvmsg(ThreadId  , Char * ,
                                                  struct vki_msghdr * ) ;
extern void vgModuleLocal_generic_POST_sys_recvmsg(ThreadId  , Char * ,
                                                   struct vki_msghdr * , UInt  ) ;
extern void vgModuleLocal_generic_PRE_sys_semop(ThreadId  , UWord  , UWord  ,
                                                UWord  ) ;
extern void vgModuleLocal_generic_PRE_sys_semtimedop(ThreadId  , UWord  ,
                                                     UWord  , UWord  , UWord  ) ;
extern void vgModuleLocal_generic_PRE_sys_semctl(ThreadId  , UWord  , UWord  ,
                                                 UWord  , UWord  ) ;
extern void vgModuleLocal_generic_POST_sys_semctl(ThreadId  , UWord  , UWord  ,
                                                  UWord  , UWord  , UWord  ) ;
extern UWord vgModuleLocal_generic_PRE_sys_shmat(ThreadId  , UWord  , UWord  ,
                                                 UWord  ) ;
extern void vgModuleLocal_generic_POST_sys_shmat(ThreadId  , UWord  , UWord  ,
                                                 UWord  , UWord  ) ;
extern Bool vgModuleLocal_generic_PRE_sys_shmdt(ThreadId  , UWord  ) ;
extern void vgModuleLocal_generic_POST_sys_shmdt(ThreadId  , UWord  , UWord  ) ;
extern void vgModuleLocal_generic_PRE_sys_shmctl(ThreadId  , UWord  , UWord  ,
                                                 UWord  ) ;
extern void vgModuleLocal_generic_POST_sys_shmctl(ThreadId  , UWord  , UWord  ,
                                                  UWord  , UWord  ) ;
extern SysRes vgModuleLocal_generic_PRE_sys_mmap(ThreadId  , UWord  , UWord  ,
                                                 UWord  , UWord  , UWord  ,
                                                 Off64T  ) ;
Word vgModuleLocal_start_thread_NORETURN(void *arg ) ;
Addr vgModuleLocal_allocstack(ThreadId tid ) ;
extern void vgModuleLocal_call_on_new_stack_0_1(Addr stack , Addr retaddr ,
                                                void (*f)(Word  ) , Word arg1 ) ;
SysRes vgModuleLocal_do_fork_clone(ThreadId tid , UInt flags ,
                                   Int *parent_tidptr , Int *child_tidptr ) ;
void vgSysWrap_linux_sys_mount_before(ThreadId tid , SyscallArgLayout *layout ,
                                      SyscallArgs *arrghs ,
                                      SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_mount_after(ThreadId tid , SyscallArgs *arrghs ,
                                            SyscallStatus *status ) ;
void vgSysWrap_linux_sys_oldumount_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_oldumount_after(ThreadId tid ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ) ;
void vgSysWrap_linux_sys_umount_before(ThreadId tid , SyscallArgLayout *layout ,
                                       SyscallArgs *arrghs ,
                                       SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_umount_after(ThreadId tid ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ) ;
void vgSysWrap_linux_sys_perf_event_open_before(ThreadId tid ,
                                                SyscallArgLayout *layout ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ,
                                                UWord *flags ) ;
void vgSysWrap_linux_sys_perf_event_open_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) ;
void vgSysWrap_linux_sys_preadv_before(ThreadId tid , SyscallArgLayout *layout ,
                                       SyscallArgs *arrghs ,
                                       SyscallStatus *status , UWord *flags ) ;
void vgSysWrap_linux_sys_preadv_after(ThreadId tid , SyscallArgs *arrghs ,
                                      SyscallStatus *status ) ;
void vgSysWrap_linux_sys_pwritev_before(ThreadId tid ,
                                        SyscallArgLayout *layout ,
                                        SyscallArgs *arrghs ,
                                        SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_pwritev_after(ThreadId tid ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ) ;
void vgSysWrap_linux_sys_sendmmsg_before(ThreadId tid ,
                                         SyscallArgLayout *layout ,
                                         SyscallArgs *arrghs ,
                                         SyscallStatus *status , UWord *flags ) ;
void vgSysWrap_linux_sys_sendmmsg_after(ThreadId tid , SyscallArgs *arrghs ,
                                        SyscallStatus *status ) ;
void vgSysWrap_linux_sys_recvmmsg_before(ThreadId tid ,
                                         SyscallArgLayout *layout ,
                                         SyscallArgs *arrghs ,
                                         SyscallStatus *status , UWord *flags ) ;
void vgSysWrap_linux_sys_recvmmsg_after(ThreadId tid , SyscallArgs *arrghs ,
                                        SyscallStatus *status ) ;
void vgSysWrap_linux_sys_dup3_before(ThreadId tid , SyscallArgLayout *layout ,
                                     SyscallArgs *arrghs ,
                                     SyscallStatus *status , UWord *flags ) ;
void vgSysWrap_linux_sys_dup3_after(ThreadId tid , SyscallArgs *arrghs ,
                                    SyscallStatus *status ) ;
void vgSysWrap_linux_sys_getcpu_before(ThreadId tid , SyscallArgLayout *layout ,
                                       SyscallArgs *arrghs ,
                                       SyscallStatus *status , UWord *flags ) ;
void vgSysWrap_linux_sys_getcpu_after(ThreadId tid , SyscallArgs *arrghs ,
                                      SyscallStatus *status ) ;
void vgSysWrap_linux_sys_splice_before(ThreadId tid , SyscallArgLayout *layout ,
                                       SyscallArgs *arrghs ,
                                       SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_splice_after(ThreadId tid ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ) ;
void vgSysWrap_linux_sys_readahead_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_readahead_after(ThreadId tid ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ) ;
void vgSysWrap_linux_sys_fcntl_before(ThreadId tid , SyscallArgLayout *layout ,
                                      SyscallArgs *arrghs ,
                                      SyscallStatus *status , UWord *flags ) ;
void vgSysWrap_linux_sys_fcntl_after(ThreadId tid , SyscallArgs *arrghs ,
                                     SyscallStatus *status ) ;
void vgSysWrap_linux_sys_fcntl64_before(ThreadId tid ,
                                        SyscallArgLayout *layout ,
                                        SyscallArgs *arrghs ,
                                        SyscallStatus *status , UWord *flags ) ;
void vgSysWrap_linux_sys_fcntl64_after(ThreadId tid , SyscallArgs *arrghs ,
                                       SyscallStatus *status ) ;
void vgSysWrap_linux_sys_ioctl_before(ThreadId tid , SyscallArgLayout *layout ,
                                      SyscallArgs *arrghs ,
                                      SyscallStatus *status , UWord *flags ) ;
void vgSysWrap_linux_sys_ioctl_after(ThreadId tid , SyscallArgs *arrghs ,
                                     SyscallStatus *status ) ;
void vgSysWrap_linux_sys_setfsuid16_before(ThreadId tid ,
                                           SyscallArgLayout *layout ,
                                           SyscallArgs *arrghs ,
                                           SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_setfsuid16_after(ThreadId tid ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ) ;
void vgSysWrap_linux_sys_setfsuid_before(ThreadId tid ,
                                         SyscallArgLayout *layout ,
                                         SyscallArgs *arrghs ,
                                         SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_setfsuid_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) ;
void vgSysWrap_linux_sys_setfsgid16_before(ThreadId tid ,
                                           SyscallArgLayout *layout ,
                                           SyscallArgs *arrghs ,
                                           SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_setfsgid16_after(ThreadId tid ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ) ;
void vgSysWrap_linux_sys_setfsgid_before(ThreadId tid ,
                                         SyscallArgLayout *layout ,
                                         SyscallArgs *arrghs ,
                                         SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_setfsgid_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) ;
void vgSysWrap_linux_sys_setresuid16_before(ThreadId tid ,
                                            SyscallArgLayout *layout ,
                                            SyscallArgs *arrghs ,
                                            SyscallStatus *status ,
                                            UWord *flags ) ;
extern void vgSysWrap_linux_sys_setresuid16_after(ThreadId tid ,
                                                  SyscallArgs *arrghs ,
                                                  SyscallStatus *status ) ;
void vgSysWrap_linux_sys_setresuid_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_setresuid_after(ThreadId tid ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ) ;
void vgSysWrap_linux_sys_getresuid16_before(ThreadId tid ,
                                            SyscallArgLayout *layout ,
                                            SyscallArgs *arrghs ,
                                            SyscallStatus *status ,
                                            UWord *flags ) ;
void vgSysWrap_linux_sys_getresuid16_after(ThreadId tid , SyscallArgs *arrghs ,
                                           SyscallStatus *status ) ;
void vgSysWrap_linux_sys_getresuid_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) ;
void vgSysWrap_linux_sys_getresuid_after(ThreadId tid , SyscallArgs *arrghs ,
                                         SyscallStatus *status ) ;
void vgSysWrap_linux_sys_setresgid16_before(ThreadId tid ,
                                            SyscallArgLayout *layout ,
                                            SyscallArgs *arrghs ,
                                            SyscallStatus *status ,
                                            UWord *flags ) ;
extern void vgSysWrap_linux_sys_setresgid16_after(ThreadId tid ,
                                                  SyscallArgs *arrghs ,
                                                  SyscallStatus *status ) ;
void vgSysWrap_linux_sys_setresgid_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_setresgid_after(ThreadId tid ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ) ;
void vgSysWrap_linux_sys_getresgid16_before(ThreadId tid ,
                                            SyscallArgLayout *layout ,
                                            SyscallArgs *arrghs ,
                                            SyscallStatus *status ,
                                            UWord *flags ) ;
void vgSysWrap_linux_sys_getresgid16_after(ThreadId tid , SyscallArgs *arrghs ,
                                           SyscallStatus *status ) ;
void vgSysWrap_linux_sys_getresgid_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) ;
void vgSysWrap_linux_sys_getresgid_after(ThreadId tid , SyscallArgs *arrghs ,
                                         SyscallStatus *status ) ;
void vgSysWrap_linux_sys_exit_group_before(ThreadId tid ,
                                           SyscallArgLayout *layout ,
                                           SyscallArgs *arrghs ,
                                           SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_exit_group_after(ThreadId tid ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ) ;
void vgSysWrap_linux_sys_llseek_before(ThreadId tid , SyscallArgLayout *layout ,
                                       SyscallArgs *arrghs ,
                                       SyscallStatus *status , UWord *flags ) ;
void vgSysWrap_linux_sys_llseek_after(ThreadId tid , SyscallArgs *arrghs ,
                                      SyscallStatus *status ) ;
void vgSysWrap_linux_sys_adjtimex_before(ThreadId tid ,
                                         SyscallArgLayout *layout ,
                                         SyscallArgs *arrghs ,
                                         SyscallStatus *status , UWord *flags ) ;
void vgSysWrap_linux_sys_adjtimex_after(ThreadId tid , SyscallArgs *arrghs ,
                                        SyscallStatus *status ) ;
void vgSysWrap_linux_sys_ioperm_before(ThreadId tid , SyscallArgLayout *layout ,
                                       SyscallArgs *arrghs ,
                                       SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_ioperm_after(ThreadId tid ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ) ;
void vgSysWrap_linux_sys_syslog_before(ThreadId tid , SyscallArgLayout *layout ,
                                       SyscallArgs *arrghs ,
                                       SyscallStatus *status , UWord *flags ) ;
void vgSysWrap_linux_sys_syslog_after(ThreadId tid , SyscallArgs *arrghs ,
                                      SyscallStatus *status ) ;
void vgSysWrap_linux_sys_vhangup_before(ThreadId tid ,
                                        SyscallArgLayout *layout ,
                                        SyscallArgs *arrghs ,
                                        SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_vhangup_after(ThreadId tid ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ) ;
void vgSysWrap_linux_sys_sysinfo_before(ThreadId tid ,
                                        SyscallArgLayout *layout ,
                                        SyscallArgs *arrghs ,
                                        SyscallStatus *status , UWord *flags ) ;
void vgSysWrap_linux_sys_sysinfo_after(ThreadId tid , SyscallArgs *arrghs ,
                                       SyscallStatus *status ) ;
void vgSysWrap_linux_sys_personality_before(ThreadId tid ,
                                            SyscallArgLayout *layout ,
                                            SyscallArgs *arrghs ,
                                            SyscallStatus *status ,
                                            UWord *flags ) ;
extern void vgSysWrap_linux_sys_personality_after(ThreadId tid ,
                                                  SyscallArgs *arrghs ,
                                                  SyscallStatus *status ) ;
void vgSysWrap_linux_sys_sysctl_before(ThreadId tid , SyscallArgLayout *layout ,
                                       SyscallArgs *arrghs ,
                                       SyscallStatus *status , UWord *flags ) ;
void vgSysWrap_linux_sys_sysctl_after(ThreadId tid , SyscallArgs *arrghs ,
                                      SyscallStatus *status ) ;
void vgSysWrap_linux_sys_prctl_before(ThreadId tid , SyscallArgLayout *layout ,
                                      SyscallArgs *arrghs ,
                                      SyscallStatus *status , UWord *flags ) ;
void vgSysWrap_linux_sys_prctl_after(ThreadId tid , SyscallArgs *arrghs ,
                                     SyscallStatus *status ) ;
void vgSysWrap_linux_sys_sendfile_before(ThreadId tid ,
                                         SyscallArgLayout *layout ,
                                         SyscallArgs *arrghs ,
                                         SyscallStatus *status , UWord *flags ) ;
void vgSysWrap_linux_sys_sendfile_after(ThreadId tid , SyscallArgs *arrghs ,
                                        SyscallStatus *status ) ;
void vgSysWrap_linux_sys_sendfile64_before(ThreadId tid ,
                                           SyscallArgLayout *layout ,
                                           SyscallArgs *arrghs ,
                                           SyscallStatus *status , UWord *flags ) ;
void vgSysWrap_linux_sys_sendfile64_after(ThreadId tid , SyscallArgs *arrghs ,
                                          SyscallStatus *status ) ;
void vgSysWrap_linux_sys_futex_before(ThreadId tid , SyscallArgLayout *layout ,
                                      SyscallArgs *arrghs ,
                                      SyscallStatus *status , UWord *flags ) ;
void vgSysWrap_linux_sys_futex_after(ThreadId tid , SyscallArgs *arrghs ,
                                     SyscallStatus *status ) ;
void vgSysWrap_linux_sys_set_robust_list_before(ThreadId tid ,
                                                SyscallArgLayout *layout ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ,
                                                UWord *flags ) ;
extern void vgSysWrap_linux_sys_set_robust_list_after(ThreadId tid ,
                                                      SyscallArgs *arrghs ,
                                                      SyscallStatus *status ) ;
void vgSysWrap_linux_sys_get_robust_list_before(ThreadId tid ,
                                                SyscallArgLayout *layout ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ,
                                                UWord *flags ) ;
void vgSysWrap_linux_sys_get_robust_list_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) ;
void vgSysWrap_linux_sys_pselect6_before(ThreadId tid ,
                                         SyscallArgLayout *layout ,
                                         SyscallArgs *arrghs ,
                                         SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_pselect6_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) ;
void vgSysWrap_linux_sys_ppoll_before(ThreadId tid , SyscallArgLayout *layout ,
                                      SyscallArgs *arrghs ,
                                      SyscallStatus *status , UWord *flags ) ;
void vgSysWrap_linux_sys_ppoll_after(ThreadId tid , SyscallArgs *arrghs ,
                                     SyscallStatus *status ) ;
void vgSysWrap_linux_sys_epoll_create_before(ThreadId tid ,
                                             SyscallArgLayout *layout ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ,
                                             UWord *flags ) ;
void vgSysWrap_linux_sys_epoll_create_after(ThreadId tid , SyscallArgs *arrghs ,
                                            SyscallStatus *status ) ;
void vgSysWrap_linux_sys_epoll_create1_before(ThreadId tid ,
                                              SyscallArgLayout *layout ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ,
                                              UWord *flags ) ;
void vgSysWrap_linux_sys_epoll_create1_after(ThreadId tid ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ) ;
void vgSysWrap_linux_sys_epoll_ctl_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_epoll_ctl_after(ThreadId tid ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ) ;
void vgSysWrap_linux_sys_epoll_wait_before(ThreadId tid ,
                                           SyscallArgLayout *layout ,
                                           SyscallArgs *arrghs ,
                                           SyscallStatus *status , UWord *flags ) ;
void vgSysWrap_linux_sys_epoll_wait_after(ThreadId tid , SyscallArgs *arrghs ,
                                          SyscallStatus *status ) ;
void vgSysWrap_linux_sys_epoll_pwait_before(ThreadId tid ,
                                            SyscallArgLayout *layout ,
                                            SyscallArgs *arrghs ,
                                            SyscallStatus *status ,
                                            UWord *flags ) ;
void vgSysWrap_linux_sys_epoll_pwait_after(ThreadId tid , SyscallArgs *arrghs ,
                                           SyscallStatus *status ) ;
void vgSysWrap_linux_sys_eventfd_before(ThreadId tid ,
                                        SyscallArgLayout *layout ,
                                        SyscallArgs *arrghs ,
                                        SyscallStatus *status , UWord *flags ) ;
void vgSysWrap_linux_sys_eventfd_after(ThreadId tid , SyscallArgs *arrghs ,
                                       SyscallStatus *status ) ;
void vgSysWrap_linux_sys_eventfd2_before(ThreadId tid ,
                                         SyscallArgLayout *layout ,
                                         SyscallArgs *arrghs ,
                                         SyscallStatus *status , UWord *flags ) ;
void vgSysWrap_linux_sys_eventfd2_after(ThreadId tid , SyscallArgs *arrghs ,
                                        SyscallStatus *status ) ;
void vgSysWrap_linux_sys_fallocate_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_fallocate_after(ThreadId tid ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ) ;
void vgSysWrap_linux_sys_prlimit64_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) ;
void vgSysWrap_linux_sys_prlimit64_after(ThreadId tid , SyscallArgs *arrghs ,
                                         SyscallStatus *status ) ;
void vgSysWrap_linux_sys_gettid_before(ThreadId tid , SyscallArgLayout *layout ,
                                       SyscallArgs *arrghs ,
                                       SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_gettid_after(ThreadId tid ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ) ;
void vgSysWrap_linux_sys_set_tid_address_before(ThreadId tid ,
                                                SyscallArgLayout *layout ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ,
                                                UWord *flags ) ;
extern void vgSysWrap_linux_sys_set_tid_address_after(ThreadId tid ,
                                                      SyscallArgs *arrghs ,
                                                      SyscallStatus *status ) ;
void vgSysWrap_linux_sys_tkill_before(ThreadId tid , SyscallArgLayout *layout ,
                                      SyscallArgs *arrghs ,
                                      SyscallStatus *status , UWord *flags ) ;
void vgSysWrap_linux_sys_tkill_after(ThreadId tid , SyscallArgs *arrghs ,
                                     SyscallStatus *status ) ;
void vgSysWrap_linux_sys_tgkill_before(ThreadId tid , SyscallArgLayout *layout ,
                                       SyscallArgs *arrghs ,
                                       SyscallStatus *status , UWord *flags ) ;
void vgSysWrap_linux_sys_tgkill_after(ThreadId tid , SyscallArgs *arrghs ,
                                      SyscallStatus *status ) ;
void vgSysWrap_linux_sys_fadvise64_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_fadvise64_after(ThreadId tid ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ) ;
void vgSysWrap_linux_sys_fadvise64_64_before(ThreadId tid ,
                                             SyscallArgLayout *layout ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ,
                                             UWord *flags ) ;
extern void vgSysWrap_linux_sys_fadvise64_64_after(ThreadId tid ,
                                                   SyscallArgs *arrghs ,
                                                   SyscallStatus *status ) ;
void vgSysWrap_linux_sys_io_setup_before(ThreadId tid ,
                                         SyscallArgLayout *layout ,
                                         SyscallArgs *arrghs ,
                                         SyscallStatus *status , UWord *flags ) ;
void vgSysWrap_linux_sys_io_setup_after(ThreadId tid , SyscallArgs *arrghs ,
                                        SyscallStatus *status ) ;
void vgSysWrap_linux_sys_io_destroy_before(ThreadId tid ,
                                           SyscallArgLayout *layout ,
                                           SyscallArgs *arrghs ,
                                           SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_io_destroy_after(ThreadId tid ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ) ;
void vgSysWrap_linux_sys_io_getevents_before(ThreadId tid ,
                                             SyscallArgLayout *layout ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ,
                                             UWord *flags ) ;
void vgSysWrap_linux_sys_io_getevents_after(ThreadId tid , SyscallArgs *arrghs ,
                                            SyscallStatus *status ) ;
void vgSysWrap_linux_sys_io_submit_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_io_submit_after(ThreadId tid ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ) ;
void vgSysWrap_linux_sys_io_cancel_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) ;
void vgSysWrap_linux_sys_io_cancel_after(ThreadId tid , SyscallArgs *arrghs ,
                                         SyscallStatus *status ) ;
void vgSysWrap_linux_sys_ioprio_set_before(ThreadId tid ,
                                           SyscallArgLayout *layout ,
                                           SyscallArgs *arrghs ,
                                           SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_ioprio_set_after(ThreadId tid ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ) ;
void vgSysWrap_linux_sys_ioprio_get_before(ThreadId tid ,
                                           SyscallArgLayout *layout ,
                                           SyscallArgs *arrghs ,
                                           SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_ioprio_get_after(ThreadId tid ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ) ;
void vgSysWrap_linux_sys_mbind_before(ThreadId tid , SyscallArgLayout *layout ,
                                      SyscallArgs *arrghs ,
                                      SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_mbind_after(ThreadId tid , SyscallArgs *arrghs ,
                                            SyscallStatus *status ) ;
void vgSysWrap_linux_sys_set_mempolicy_before(ThreadId tid ,
                                              SyscallArgLayout *layout ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ,
                                              UWord *flags ) ;
extern void vgSysWrap_linux_sys_set_mempolicy_after(ThreadId tid ,
                                                    SyscallArgs *arrghs ,
                                                    SyscallStatus *status ) ;
void vgSysWrap_linux_sys_get_mempolicy_before(ThreadId tid ,
                                              SyscallArgLayout *layout ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ,
                                              UWord *flags ) ;
void vgSysWrap_linux_sys_get_mempolicy_after(ThreadId tid ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ) ;
void vgSysWrap_linux_sys_inotify_init_before(ThreadId tid ,
                                             SyscallArgLayout *layout ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ,
                                             UWord *flags ) ;
void vgSysWrap_linux_sys_inotify_init_after(ThreadId tid , SyscallArgs *arrghs ,
                                            SyscallStatus *status ) ;
void vgSysWrap_linux_sys_inotify_init1_before(ThreadId tid ,
                                              SyscallArgLayout *layout ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ,
                                              UWord *flags ) ;
void vgSysWrap_linux_sys_inotify_init1_after(ThreadId tid ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ) ;
void vgSysWrap_linux_sys_inotify_add_watch_before(ThreadId tid ,
                                                  SyscallArgLayout *layout ,
                                                  SyscallArgs *arrghs ,
                                                  SyscallStatus *status ,
                                                  UWord *flags ) ;
extern void vgSysWrap_linux_sys_inotify_add_watch_after(ThreadId tid ,
                                                        SyscallArgs *arrghs ,
                                                        SyscallStatus *status ) ;
void vgSysWrap_linux_sys_inotify_rm_watch_before(ThreadId tid ,
                                                 SyscallArgLayout *layout ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ,
                                                 UWord *flags ) ;
extern void vgSysWrap_linux_sys_inotify_rm_watch_after(ThreadId tid ,
                                                       SyscallArgs *arrghs ,
                                                       SyscallStatus *status ) ;
void vgSysWrap_linux_sys_mq_open_before(ThreadId tid ,
                                        SyscallArgLayout *layout ,
                                        SyscallArgs *arrghs ,
                                        SyscallStatus *status , UWord *flags ) ;
void vgSysWrap_linux_sys_mq_open_after(ThreadId tid , SyscallArgs *arrghs ,
                                       SyscallStatus *status ) ;
void vgSysWrap_linux_sys_mq_unlink_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_mq_unlink_after(ThreadId tid ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ) ;
void vgSysWrap_linux_sys_mq_timedsend_before(ThreadId tid ,
                                             SyscallArgLayout *layout ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ,
                                             UWord *flags ) ;
extern void vgSysWrap_linux_sys_mq_timedsend_after(ThreadId tid ,
                                                   SyscallArgs *arrghs ,
                                                   SyscallStatus *status ) ;
void vgSysWrap_linux_sys_mq_timedreceive_before(ThreadId tid ,
                                                SyscallArgLayout *layout ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ,
                                                UWord *flags ) ;
void vgSysWrap_linux_sys_mq_timedreceive_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) ;
void vgSysWrap_linux_sys_mq_notify_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_mq_notify_after(ThreadId tid ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ) ;
void vgSysWrap_linux_sys_mq_getsetattr_before(ThreadId tid ,
                                              SyscallArgLayout *layout ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ,
                                              UWord *flags ) ;
void vgSysWrap_linux_sys_mq_getsetattr_after(ThreadId tid ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ) ;
void vgSysWrap_linux_sys_clock_settime_before(ThreadId tid ,
                                              SyscallArgLayout *layout ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ,
                                              UWord *flags ) ;
extern void vgSysWrap_linux_sys_clock_settime_after(ThreadId tid ,
                                                    SyscallArgs *arrghs ,
                                                    SyscallStatus *status ) ;
void vgSysWrap_linux_sys_clock_gettime_before(ThreadId tid ,
                                              SyscallArgLayout *layout ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ,
                                              UWord *flags ) ;
void vgSysWrap_linux_sys_clock_gettime_after(ThreadId tid ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ) ;
void vgSysWrap_linux_sys_clock_getres_before(ThreadId tid ,
                                             SyscallArgLayout *layout ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ,
                                             UWord *flags ) ;
void vgSysWrap_linux_sys_clock_getres_after(ThreadId tid , SyscallArgs *arrghs ,
                                            SyscallStatus *status ) ;
void vgSysWrap_linux_sys_clock_nanosleep_before(ThreadId tid ,
                                                SyscallArgLayout *layout ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ,
                                                UWord *flags ) ;
void vgSysWrap_linux_sys_clock_nanosleep_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) ;
void vgSysWrap_linux_sys_timer_create_before(ThreadId tid ,
                                             SyscallArgLayout *layout ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ,
                                             UWord *flags ) ;
void vgSysWrap_linux_sys_timer_create_after(ThreadId tid , SyscallArgs *arrghs ,
                                            SyscallStatus *status ) ;
void vgSysWrap_linux_sys_timer_settime_before(ThreadId tid ,
                                              SyscallArgLayout *layout ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ,
                                              UWord *flags ) ;
void vgSysWrap_linux_sys_timer_settime_after(ThreadId tid ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ) ;
void vgSysWrap_linux_sys_timer_gettime_before(ThreadId tid ,
                                              SyscallArgLayout *layout ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ,
                                              UWord *flags ) ;
void vgSysWrap_linux_sys_timer_gettime_after(ThreadId tid ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ) ;
void vgSysWrap_linux_sys_timer_getoverrun_before(ThreadId tid ,
                                                 SyscallArgLayout *layout ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ,
                                                 UWord *flags ) ;
extern void vgSysWrap_linux_sys_timer_getoverrun_after(ThreadId tid ,
                                                       SyscallArgs *arrghs ,
                                                       SyscallStatus *status ) ;
void vgSysWrap_linux_sys_timer_delete_before(ThreadId tid ,
                                             SyscallArgLayout *layout ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ,
                                             UWord *flags ) ;
extern void vgSysWrap_linux_sys_timer_delete_after(ThreadId tid ,
                                                   SyscallArgs *arrghs ,
                                                   SyscallStatus *status ) ;
void vgSysWrap_linux_sys_timerfd_create_before(ThreadId tid ,
                                               SyscallArgLayout *layout ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ,
                                               UWord *flags ) ;
void vgSysWrap_linux_sys_timerfd_create_after(ThreadId tid ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ) ;
void vgSysWrap_linux_sys_timerfd_gettime_before(ThreadId tid ,
                                                SyscallArgLayout *layout ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ,
                                                UWord *flags ) ;
void vgSysWrap_linux_sys_timerfd_gettime_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) ;
void vgSysWrap_linux_sys_timerfd_settime_before(ThreadId tid ,
                                                SyscallArgLayout *layout ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ,
                                                UWord *flags ) ;
void vgSysWrap_linux_sys_timerfd_settime_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) ;
void vgSysWrap_linux_sys_signalfd_before(ThreadId tid ,
                                         SyscallArgLayout *layout ,
                                         SyscallArgs *arrghs ,
                                         SyscallStatus *status , UWord *flags ) ;
void vgSysWrap_linux_sys_signalfd_after(ThreadId tid , SyscallArgs *arrghs ,
                                        SyscallStatus *status ) ;
void vgSysWrap_linux_sys_signalfd4_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) ;
void vgSysWrap_linux_sys_signalfd4_after(ThreadId tid , SyscallArgs *arrghs ,
                                         SyscallStatus *status ) ;
void vgSysWrap_linux_sys_capget_before(ThreadId tid , SyscallArgLayout *layout ,
                                       SyscallArgs *arrghs ,
                                       SyscallStatus *status , UWord *flags ) ;
void vgSysWrap_linux_sys_capget_after(ThreadId tid , SyscallArgs *arrghs ,
                                      SyscallStatus *status ) ;
void vgSysWrap_linux_sys_capset_before(ThreadId tid , SyscallArgLayout *layout ,
                                       SyscallArgs *arrghs ,
                                       SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_capset_after(ThreadId tid ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ) ;
void vgSysWrap_linux_sys_openat_before(ThreadId tid , SyscallArgLayout *layout ,
                                       SyscallArgs *arrghs ,
                                       SyscallStatus *status , UWord *flags ) ;
void vgSysWrap_linux_sys_openat_after(ThreadId tid , SyscallArgs *arrghs ,
                                      SyscallStatus *status ) ;
void vgSysWrap_linux_sys_mkdirat_before(ThreadId tid ,
                                        SyscallArgLayout *layout ,
                                        SyscallArgs *arrghs ,
                                        SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_mkdirat_after(ThreadId tid ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ) ;
void vgSysWrap_linux_sys_mknodat_before(ThreadId tid ,
                                        SyscallArgLayout *layout ,
                                        SyscallArgs *arrghs ,
                                        SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_mknodat_after(ThreadId tid ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ) ;
void vgSysWrap_linux_sys_fchownat_before(ThreadId tid ,
                                         SyscallArgLayout *layout ,
                                         SyscallArgs *arrghs ,
                                         SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_fchownat_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) ;
void vgSysWrap_linux_sys_futimesat_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_futimesat_after(ThreadId tid ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ) ;
void vgSysWrap_linux_sys_newfstatat_before(ThreadId tid ,
                                           SyscallArgLayout *layout ,
                                           SyscallArgs *arrghs ,
                                           SyscallStatus *status , UWord *flags ) ;
void vgSysWrap_linux_sys_newfstatat_after(ThreadId tid , SyscallArgs *arrghs ,
                                          SyscallStatus *status ) ;
void vgSysWrap_linux_sys_unlinkat_before(ThreadId tid ,
                                         SyscallArgLayout *layout ,
                                         SyscallArgs *arrghs ,
                                         SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_unlinkat_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) ;
void vgSysWrap_linux_sys_renameat_before(ThreadId tid ,
                                         SyscallArgLayout *layout ,
                                         SyscallArgs *arrghs ,
                                         SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_renameat_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) ;
void vgSysWrap_linux_sys_linkat_before(ThreadId tid , SyscallArgLayout *layout ,
                                       SyscallArgs *arrghs ,
                                       SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_linkat_after(ThreadId tid ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ) ;
void vgSysWrap_linux_sys_symlinkat_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_symlinkat_after(ThreadId tid ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ) ;
void vgSysWrap_linux_sys_readlinkat_before(ThreadId tid ,
                                           SyscallArgLayout *layout ,
                                           SyscallArgs *arrghs ,
                                           SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_readlinkat_after(ThreadId tid ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ) ;
void vgSysWrap_linux_sys_fchmodat_before(ThreadId tid ,
                                         SyscallArgLayout *layout ,
                                         SyscallArgs *arrghs ,
                                         SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_fchmodat_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) ;
void vgSysWrap_linux_sys_faccessat_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_faccessat_after(ThreadId tid ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ) ;
void vgSysWrap_linux_sys_utimensat_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_utimensat_after(ThreadId tid ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ) ;
void vgSysWrap_linux_sys_add_key_before(ThreadId tid ,
                                        SyscallArgLayout *layout ,
                                        SyscallArgs *arrghs ,
                                        SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_add_key_after(ThreadId tid ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ) ;
void vgSysWrap_linux_sys_request_key_before(ThreadId tid ,
                                            SyscallArgLayout *layout ,
                                            SyscallArgs *arrghs ,
                                            SyscallStatus *status ,
                                            UWord *flags ) ;
extern void vgSysWrap_linux_sys_request_key_after(ThreadId tid ,
                                                  SyscallArgs *arrghs ,
                                                  SyscallStatus *status ) ;
void vgSysWrap_linux_sys_keyctl_before(ThreadId tid , SyscallArgLayout *layout ,
                                       SyscallArgs *arrghs ,
                                       SyscallStatus *status , UWord *flags ) ;
void vgSysWrap_linux_sys_keyctl_after(ThreadId tid , SyscallArgs *arrghs ,
                                      SyscallStatus *status ) ;
void vgSysWrap_linux_sys_getuid16_before(ThreadId tid ,
                                         SyscallArgLayout *layout ,
                                         SyscallArgs *arrghs ,
                                         SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_getuid16_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) ;
void vgSysWrap_linux_sys_setuid16_before(ThreadId tid ,
                                         SyscallArgLayout *layout ,
                                         SyscallArgs *arrghs ,
                                         SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_setuid16_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) ;
void vgSysWrap_linux_sys_getgid16_before(ThreadId tid ,
                                         SyscallArgLayout *layout ,
                                         SyscallArgs *arrghs ,
                                         SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_getgid16_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) ;
void vgSysWrap_linux_sys_setgid16_before(ThreadId tid ,
                                         SyscallArgLayout *layout ,
                                         SyscallArgs *arrghs ,
                                         SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_setgid16_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) ;
void vgSysWrap_linux_sys_geteuid16_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_geteuid16_after(ThreadId tid ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ) ;
void vgSysWrap_linux_sys_getegid16_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_getegid16_after(ThreadId tid ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ) ;
void vgSysWrap_linux_sys_setreuid16_before(ThreadId tid ,
                                           SyscallArgLayout *layout ,
                                           SyscallArgs *arrghs ,
                                           SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_setreuid16_after(ThreadId tid ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ) ;
void vgSysWrap_linux_sys_setregid16_before(ThreadId tid ,
                                           SyscallArgLayout *layout ,
                                           SyscallArgs *arrghs ,
                                           SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_setregid16_after(ThreadId tid ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ) ;
void vgSysWrap_linux_sys_getgroups16_before(ThreadId tid ,
                                            SyscallArgLayout *layout ,
                                            SyscallArgs *arrghs ,
                                            SyscallStatus *status ,
                                            UWord *flags ) ;
void vgSysWrap_linux_sys_getgroups16_after(ThreadId tid , SyscallArgs *arrghs ,
                                           SyscallStatus *status ) ;
void vgSysWrap_linux_sys_setgroups16_before(ThreadId tid ,
                                            SyscallArgLayout *layout ,
                                            SyscallArgs *arrghs ,
                                            SyscallStatus *status ,
                                            UWord *flags ) ;
extern void vgSysWrap_linux_sys_setgroups16_after(ThreadId tid ,
                                                  SyscallArgs *arrghs ,
                                                  SyscallStatus *status ) ;
void vgSysWrap_linux_sys_chown16_before(ThreadId tid ,
                                        SyscallArgLayout *layout ,
                                        SyscallArgs *arrghs ,
                                        SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_chown16_after(ThreadId tid ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ) ;
void vgSysWrap_linux_sys_fchown16_before(ThreadId tid ,
                                         SyscallArgLayout *layout ,
                                         SyscallArgs *arrghs ,
                                         SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_fchown16_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) ;
void vgSysWrap_linux_sys_setxattr_before(ThreadId tid ,
                                         SyscallArgLayout *layout ,
                                         SyscallArgs *arrghs ,
                                         SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_setxattr_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) ;
void vgSysWrap_linux_sys_lsetxattr_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_lsetxattr_after(ThreadId tid ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ) ;
void vgSysWrap_linux_sys_fsetxattr_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_fsetxattr_after(ThreadId tid ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ) ;
void vgSysWrap_linux_sys_getxattr_before(ThreadId tid ,
                                         SyscallArgLayout *layout ,
                                         SyscallArgs *arrghs ,
                                         SyscallStatus *status , UWord *flags ) ;
void vgSysWrap_linux_sys_getxattr_after(ThreadId tid , SyscallArgs *arrghs ,
                                        SyscallStatus *status ) ;
void vgSysWrap_linux_sys_lgetxattr_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) ;
void vgSysWrap_linux_sys_lgetxattr_after(ThreadId tid , SyscallArgs *arrghs ,
                                         SyscallStatus *status ) ;
void vgSysWrap_linux_sys_fgetxattr_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) ;
void vgSysWrap_linux_sys_fgetxattr_after(ThreadId tid , SyscallArgs *arrghs ,
                                         SyscallStatus *status ) ;
void vgSysWrap_linux_sys_listxattr_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) ;
void vgSysWrap_linux_sys_listxattr_after(ThreadId tid , SyscallArgs *arrghs ,
                                         SyscallStatus *status ) ;
void vgSysWrap_linux_sys_llistxattr_before(ThreadId tid ,
                                           SyscallArgLayout *layout ,
                                           SyscallArgs *arrghs ,
                                           SyscallStatus *status , UWord *flags ) ;
void vgSysWrap_linux_sys_llistxattr_after(ThreadId tid , SyscallArgs *arrghs ,
                                          SyscallStatus *status ) ;
void vgSysWrap_linux_sys_flistxattr_before(ThreadId tid ,
                                           SyscallArgLayout *layout ,
                                           SyscallArgs *arrghs ,
                                           SyscallStatus *status , UWord *flags ) ;
void vgSysWrap_linux_sys_flistxattr_after(ThreadId tid , SyscallArgs *arrghs ,
                                          SyscallStatus *status ) ;
void vgSysWrap_linux_sys_removexattr_before(ThreadId tid ,
                                            SyscallArgLayout *layout ,
                                            SyscallArgs *arrghs ,
                                            SyscallStatus *status ,
                                            UWord *flags ) ;
extern void vgSysWrap_linux_sys_removexattr_after(ThreadId tid ,
                                                  SyscallArgs *arrghs ,
                                                  SyscallStatus *status ) ;
void vgSysWrap_linux_sys_lremovexattr_before(ThreadId tid ,
                                             SyscallArgLayout *layout ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ,
                                             UWord *flags ) ;
extern void vgSysWrap_linux_sys_lremovexattr_after(ThreadId tid ,
                                                   SyscallArgs *arrghs ,
                                                   SyscallStatus *status ) ;
void vgSysWrap_linux_sys_fremovexattr_before(ThreadId tid ,
                                             SyscallArgLayout *layout ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ,
                                             UWord *flags ) ;
extern void vgSysWrap_linux_sys_fremovexattr_after(ThreadId tid ,
                                                   SyscallArgs *arrghs ,
                                                   SyscallStatus *status ) ;
void vgSysWrap_linux_sys_sched_setparam_before(ThreadId tid ,
                                               SyscallArgLayout *layout ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ,
                                               UWord *flags ) ;
void vgSysWrap_linux_sys_sched_setparam_after(ThreadId tid ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ) ;
void vgSysWrap_linux_sys_sched_getparam_before(ThreadId tid ,
                                               SyscallArgLayout *layout ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ,
                                               UWord *flags ) ;
void vgSysWrap_linux_sys_sched_getparam_after(ThreadId tid ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ) ;
void vgSysWrap_linux_sys_sched_setscheduler_before(ThreadId tid ,
                                                   SyscallArgLayout *layout ,
                                                   SyscallArgs *arrghs ,
                                                   SyscallStatus *status ,
                                                   UWord *flags ) ;
extern void vgSysWrap_linux_sys_sched_setscheduler_after(ThreadId tid ,
                                                         SyscallArgs *arrghs ,
                                                         SyscallStatus *status ) ;
void vgSysWrap_linux_sys_sched_getscheduler_before(ThreadId tid ,
                                                   SyscallArgLayout *layout ,
                                                   SyscallArgs *arrghs ,
                                                   SyscallStatus *status ,
                                                   UWord *flags ) ;
extern void vgSysWrap_linux_sys_sched_getscheduler_after(ThreadId tid ,
                                                         SyscallArgs *arrghs ,
                                                         SyscallStatus *status ) ;
void vgSysWrap_linux_sys_sched_yield_before(ThreadId tid ,
                                            SyscallArgLayout *layout ,
                                            SyscallArgs *arrghs ,
                                            SyscallStatus *status ,
                                            UWord *flags ) ;
extern void vgSysWrap_linux_sys_sched_yield_after(ThreadId tid ,
                                                  SyscallArgs *arrghs ,
                                                  SyscallStatus *status ) ;
void vgSysWrap_linux_sys_sched_get_priority_max_before(ThreadId tid ,
                                                       SyscallArgLayout *layout ,
                                                       SyscallArgs *arrghs ,
                                                       SyscallStatus *status ,
                                                       UWord *flags ) ;
extern void vgSysWrap_linux_sys_sched_get_priority_max_after(ThreadId tid ,
                                                             SyscallArgs *arrghs ,
                                                             SyscallStatus *status ) ;
void vgSysWrap_linux_sys_sched_get_priority_min_before(ThreadId tid ,
                                                       SyscallArgLayout *layout ,
                                                       SyscallArgs *arrghs ,
                                                       SyscallStatus *status ,
                                                       UWord *flags ) ;
extern void vgSysWrap_linux_sys_sched_get_priority_min_after(ThreadId tid ,
                                                             SyscallArgs *arrghs ,
                                                             SyscallStatus *status ) ;
void vgSysWrap_linux_sys_sched_rr_get_interval_before(ThreadId tid ,
                                                      SyscallArgLayout *layout ,
                                                      SyscallArgs *arrghs ,
                                                      SyscallStatus *status ,
                                                      UWord *flags ) ;
void vgSysWrap_linux_sys_sched_rr_get_interval_after(ThreadId tid ,
                                                     SyscallArgs *arrghs ,
                                                     SyscallStatus *status ) ;
void vgSysWrap_linux_sys_sched_setaffinity_before(ThreadId tid ,
                                                  SyscallArgLayout *layout ,
                                                  SyscallArgs *arrghs ,
                                                  SyscallStatus *status ,
                                                  UWord *flags ) ;
extern void vgSysWrap_linux_sys_sched_setaffinity_after(ThreadId tid ,
                                                        SyscallArgs *arrghs ,
                                                        SyscallStatus *status ) ;
void vgSysWrap_linux_sys_sched_getaffinity_before(ThreadId tid ,
                                                  SyscallArgLayout *layout ,
                                                  SyscallArgs *arrghs ,
                                                  SyscallStatus *status ,
                                                  UWord *flags ) ;
void vgSysWrap_linux_sys_sched_getaffinity_after(ThreadId tid ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ) ;
void vgSysWrap_linux_sys_munlockall_before(ThreadId tid ,
                                           SyscallArgLayout *layout ,
                                           SyscallArgs *arrghs ,
                                           SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_munlockall_after(ThreadId tid ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ) ;
void vgSysWrap_linux_sys_pipe_before(ThreadId tid , SyscallArgLayout *layout ,
                                     SyscallArgs *arrghs ,
                                     SyscallStatus *status , UWord *flags ) ;
void vgSysWrap_linux_sys_pipe_after(ThreadId tid , SyscallArgs *arrghs ,
                                    SyscallStatus *status ) ;
void vgSysWrap_linux_sys_pipe2_before(ThreadId tid , SyscallArgLayout *layout ,
                                      SyscallArgs *arrghs ,
                                      SyscallStatus *status , UWord *flags ) ;
void vgSysWrap_linux_sys_pipe2_after(ThreadId tid , SyscallArgs *arrghs ,
                                     SyscallStatus *status ) ;
void vgSysWrap_linux_sys_quotactl_before(ThreadId tid ,
                                         SyscallArgLayout *layout ,
                                         SyscallArgs *arrghs ,
                                         SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_quotactl_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) ;
void vgSysWrap_linux_sys_waitid_before(ThreadId tid , SyscallArgLayout *layout ,
                                       SyscallArgs *arrghs ,
                                       SyscallStatus *status , UWord *flags ) ;
void vgSysWrap_linux_sys_waitid_after(ThreadId tid , SyscallArgs *arrghs ,
                                      SyscallStatus *status ) ;
void vgSysWrap_linux_sys_utime_before(ThreadId tid , SyscallArgLayout *layout ,
                                      SyscallArgs *arrghs ,
                                      SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_utime_after(ThreadId tid , SyscallArgs *arrghs ,
                                            SyscallStatus *status ) ;
void vgSysWrap_linux_sys_lseek_before(ThreadId tid , SyscallArgLayout *layout ,
                                      SyscallArgs *arrghs ,
                                      SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_lseek_after(ThreadId tid , SyscallArgs *arrghs ,
                                            SyscallStatus *status ) ;
void vgSysWrap_linux_sys_sigpending_before(ThreadId tid ,
                                           SyscallArgLayout *layout ,
                                           SyscallArgs *arrghs ,
                                           SyscallStatus *status , UWord *flags ) ;
void vgSysWrap_linux_sys_sigpending_after(ThreadId tid , SyscallArgs *arrghs ,
                                          SyscallStatus *status ) ;
void vgSysWrap_linux_sys_sigprocmask_before(ThreadId tid ,
                                            SyscallArgLayout *layout ,
                                            SyscallArgs *arrghs ,
                                            SyscallStatus *status ,
                                            UWord *flags ) ;
void vgSysWrap_linux_sys_sigprocmask_after(ThreadId tid , SyscallArgs *arrghs ,
                                           SyscallStatus *status ) ;
void vgSysWrap_linux_sys_sigaction_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) ;
void vgSysWrap_linux_sys_sigaction_after(ThreadId tid , SyscallArgs *arrghs ,
                                         SyscallStatus *status ) ;
void vgSysWrap_linux_sys_rt_sigaction_before(ThreadId tid ,
                                             SyscallArgLayout *layout ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ,
                                             UWord *flags ) ;
void vgSysWrap_linux_sys_rt_sigaction_after(ThreadId tid , SyscallArgs *arrghs ,
                                            SyscallStatus *status ) ;
void vgSysWrap_linux_sys_rt_sigprocmask_before(ThreadId tid ,
                                               SyscallArgLayout *layout ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ,
                                               UWord *flags ) ;
void vgSysWrap_linux_sys_rt_sigprocmask_after(ThreadId tid ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ) ;
void vgSysWrap_linux_sys_rt_sigpending_before(ThreadId tid ,
                                              SyscallArgLayout *layout ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ,
                                              UWord *flags ) ;
void vgSysWrap_linux_sys_rt_sigpending_after(ThreadId tid ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ) ;
void vgSysWrap_linux_sys_rt_sigtimedwait_before(ThreadId tid ,
                                                SyscallArgLayout *layout ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ,
                                                UWord *flags ) ;
void vgSysWrap_linux_sys_rt_sigtimedwait_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) ;
void vgSysWrap_linux_sys_rt_sigqueueinfo_before(ThreadId tid ,
                                                SyscallArgLayout *layout ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ,
                                                UWord *flags ) ;
void vgSysWrap_linux_sys_rt_sigqueueinfo_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) ;
void vgSysWrap_linux_sys_rt_tgsigqueueinfo_before(ThreadId tid ,
                                                  SyscallArgLayout *layout ,
                                                  SyscallArgs *arrghs ,
                                                  SyscallStatus *status ,
                                                  UWord *flags ) ;
void vgSysWrap_linux_sys_rt_tgsigqueueinfo_after(ThreadId tid ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ) ;
void vgSysWrap_linux_sys_rt_sigsuspend_before(ThreadId tid ,
                                              SyscallArgLayout *layout ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ,
                                              UWord *flags ) ;
extern void vgSysWrap_linux_sys_rt_sigsuspend_after(ThreadId tid ,
                                                    SyscallArgs *arrghs ,
                                                    SyscallStatus *status ) ;
void vgSysWrap_linux_sys_sync_file_range_before(ThreadId tid ,
                                                SyscallArgLayout *layout ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ,
                                                UWord *flags ) ;
extern void vgSysWrap_linux_sys_sync_file_range_after(ThreadId tid ,
                                                      SyscallArgs *arrghs ,
                                                      SyscallStatus *status ) ;
void vgSysWrap_linux_sys_sync_file_range2_before(ThreadId tid ,
                                                 SyscallArgLayout *layout ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ,
                                                 UWord *flags ) ;
extern void vgSysWrap_linux_sys_sync_file_range2_after(ThreadId tid ,
                                                       SyscallArgs *arrghs ,
                                                       SyscallStatus *status ) ;
void vgSysWrap_linux_sys_stime_before(ThreadId tid , SyscallArgLayout *layout ,
                                      SyscallArgs *arrghs ,
                                      SyscallStatus *status , UWord *flags ) ;
extern void vgSysWrap_linux_sys_stime_after(ThreadId tid , SyscallArgs *arrghs ,
                                            SyscallStatus *status ) ;
void vgSysWrap_linux_sys_init_module_before(ThreadId tid ,
                                            SyscallArgLayout *layout ,
                                            SyscallArgs *arrghs ,
                                            SyscallStatus *status ,
                                            UWord *flags ) ;
extern void vgSysWrap_linux_sys_init_module_after(ThreadId tid ,
                                                  SyscallArgs *arrghs ,
                                                  SyscallStatus *status ) ;
void vgSysWrap_linux_sys_delete_module_before(ThreadId tid ,
                                              SyscallArgLayout *layout ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ,
                                              UWord *flags ) ;
extern void vgSysWrap_linux_sys_delete_module_after(ThreadId tid ,
                                                    SyscallArgs *arrghs ,
                                                    SyscallStatus *status ) ;
void vgSysWrap_linux_sys_lookup_dcookie_before(ThreadId tid ,
                                               SyscallArgLayout *layout ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ,
                                               UWord *flags ) ;
void vgSysWrap_linux_sys_lookup_dcookie_after(ThreadId tid ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ) ;
void vgSysWrap_linux_sys_process_vm_readv_before(ThreadId tid ,
                                                 SyscallArgLayout *layout ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ,
                                                 UWord *flags ) ;
void vgSysWrap_linux_sys_process_vm_readv_after(ThreadId tid ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ) ;
void vgSysWrap_linux_sys_process_vm_writev_before(ThreadId tid ,
                                                  SyscallArgLayout *layout ,
                                                  SyscallArgs *arrghs ,
                                                  SyscallStatus *status ,
                                                  UWord *flags ) ;
extern void vgSysWrap_linux_sys_process_vm_writev_after(ThreadId tid ,
                                                        SyscallArgs *arrghs ,
                                                        SyscallStatus *status ) ;
void vgModuleLocal_linux_PRE_sys_msgsnd(ThreadId tid , UWord arg0 , UWord arg1 ,
                                        UWord arg2 , UWord arg3 ) ;
void vgModuleLocal_linux_PRE_sys_msgrcv(ThreadId tid , UWord arg0 , UWord arg1 ,
                                        UWord arg2 , UWord arg3 , UWord arg4 ) ;
void vgModuleLocal_linux_POST_sys_msgrcv(ThreadId tid , UWord res , UWord arg0 ,
                                         UWord arg1 , UWord arg2 , UWord arg3 ,
                                         UWord arg4 ) ;
void vgModuleLocal_linux_PRE_sys_msgctl(ThreadId tid , UWord arg0 , UWord arg1 ,
                                        UWord arg2 ) ;
void vgModuleLocal_linux_POST_sys_msgctl(ThreadId tid , UWord res , UWord arg0 ,
                                         UWord arg1 , UWord arg2 ) ;
void vgModuleLocal_linux_PRE_sys_getsockopt(ThreadId tid , UWord arg0 ,
                                            UWord arg1 , UWord arg2 ,
                                            UWord arg3 , UWord arg4 ) ;
void vgModuleLocal_linux_POST_sys_getsockopt(ThreadId tid , SysRes res ,
                                             UWord arg0 , UWord arg1 ,
                                             UWord arg2 , UWord arg3 ,
                                             UWord arg4 ) ;
static VgSchedReturnCode thread_wrapper(Word tidW ) 
{ 
  VgSchedReturnCode ret ;
  ThreadId tid ;
  ThreadState *tst ;
  ThreadState *tmp ;
  long tmp___0 ;
  Bool tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  Bool tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;

  {
  tid = (ThreadId )tidW;
  tmp = vgPlain_get_ThreadState(tid);
  tst = tmp;
  vgPlain_debugLog(1, "syswrap-linux", "thread_wrapper(tid=%lld): entry\n",
                   (ULong )tidW);
  tmp___0 = __builtin_expect((long )(! (! ((unsigned int )tst->status == 1U))),
                             1L);
  if (tmp___0) {

  } else {
    vgPlain_assert_fail((Bool )1, (Char const   *)"tst->status == VgTs_Init",
                        (Char const   *)"m_syswrap/syswrap-linux.c", 75,
                        (Char const   *)"thread_wrapper", "");
  }
  vgPlain_acquire_BigLock(tid, (HChar *)"thread_wrapper(starting new thread)");
  tst->err_disablement_level = (UInt )0;
  while (1) {
    if (vgPlain_tdict.track_pre_thread_first_insn) {
      (*(vgPlain_tdict.track_pre_thread_first_insn))(tid);
    } else {

    }
    break;
  }
  tst->os_state.lwpid = vgPlain_gettid();
  tst->os_state.threadgroup = vgPlain_getpid();
  ret = vgPlain_scheduler(tid);
  tmp___1 = vgPlain_is_exiting(tid);
  if (tmp___1) {
    tmp___2 = 1;
  } else {
    tmp___2 = 0;
  }
  tmp___3 = __builtin_expect((long )tmp___2, 1L);
  if (tmp___3) {

  } else {
    vgPlain_assert_fail((Bool )1, (Char const   *)"VG_(is_exiting)(tid)",
                        (Char const   *)"m_syswrap/syswrap-linux.c", 100,
                        (Char const   *)"thread_wrapper", "");
  }
  tmp___4 = __builtin_expect((long )(! (! ((unsigned int )tst->status == 2U))),
                             1L);
  if (tmp___4) {

  } else {
    vgPlain_assert_fail((Bool )1,
                        (Char const   *)"tst->status == VgTs_Runnable",
                        (Char const   *)"m_syswrap/syswrap-linux.c", 102,
                        (Char const   *)"thread_wrapper", "");
  }
  tmp___5 = vgPlain_is_running_thread(tid);
  if (tmp___5) {
    tmp___6 = 1;
  } else {
    tmp___6 = 0;
  }
  tmp___7 = __builtin_expect((long )tmp___6, 1L);
  if (tmp___7) {

  } else {
    vgPlain_assert_fail((Bool )1, (Char const   *)"VG_(is_running_thread)(tid)",
                        (Char const   *)"m_syswrap/syswrap-linux.c", 103,
                        (Char const   *)"thread_wrapper", "");
  }
  vgPlain_debugLog(1, "syswrap-linux", "thread_wrapper(tid=%lld): exit\n",
                   (ULong )tidW);
  return (ret);
}
}
static void run_a_thread_NORETURN(Word tidW ) 
{ 
  ThreadId tid ;
  VgSchedReturnCode src ;
  Int c ;
  ThreadState *tst ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  tid = (ThreadId )tidW;
  vgPlain_debugLog(1, "syswrap-linux",
                   "run_a_thread_NORETURN(tid=%lld): pre-thread_wrapper\n",
                   (ULong )tidW);
  tst = vgPlain_get_ThreadState(tid);
  tmp = __builtin_expect((long )(! (! tst)), 1L);
  if (tmp) {

  } else {
    vgPlain_assert_fail((Bool )1, (Char const   *)"tst",
                        (Char const   *)"m_syswrap/syswrap-linux.c", 132,
                        (Char const   *)"run_a_thread_NORETURN", "");
  }
  src = thread_wrapper((Word )tid);
  vgPlain_debugLog(1, "syswrap-linux",
                   "run_a_thread_NORETURN(tid=%lld): post-thread_wrapper\n",
                   (ULong )tidW);
  c = vgPlain_count_living_threads();
  tmp___0 = __builtin_expect((long )(! (! (c >= 1))), 1L);
  if (tmp___0) {

  } else {
    vgPlain_assert_fail((Bool )1, (Char const   *)"c >= 1",
                        (Char const   *)"m_syswrap/syswrap-linux.c", 142,
                        (Char const   *)"run_a_thread_NORETURN", "");
  }
  while (1) {
    if (vgPlain_tdict.track_pre_thread_ll_exit) {
      (*(vgPlain_tdict.track_pre_thread_ll_exit))(tid);
    } else {

    }
    break;
  }
  if (tst->err_disablement_level > 0U) {
    vgPlain_umsg("WARNING: exiting thread has error reporting disabled.\nWARNING: possibly as a result of some mistake in the use\nWARNING: of the VALGRIND_DISABLE_ERROR_REPORTING macros.\n");
    vgPlain_debugLog(1, "syswrap-linux",
                     "run_a_thread_NORETURN(tid=%lld): WARNING: exiting thread has err_disablement_level = %u\n",
                     (ULong )tidW, tst->err_disablement_level);
  } else {

  }
  tst->err_disablement_level = (UInt )0;
  if (c == 1) {
    vgPlain_debugLog(1, "syswrap-linux",
                     "run_a_thread_NORETURN(tid=%lld): last one standing\n",
                     (ULong )tidW);
    (*vgPlain_address_of_m_main_shutdown_actions_NORETURN)(tid, src);
  } else {
    vgPlain_debugLog(1, "syswrap-linux",
                     "run_a_thread_NORETURN(tid=%lld): not last one standing\n",
                     (ULong )tidW);
    vgPlain_exit_thread(tid);
    tmp___1 = __builtin_expect((long )(! (! ((unsigned int )tst->status == 5U))),
                               1L);
    if (tmp___1) {

    } else {
      vgPlain_assert_fail((Bool )1,
                          (Char const   *)"tst->status == VgTs_Zombie",
                          (Char const   *)"m_syswrap/syswrap-linux.c", 191,
                          (Char const   *)"run_a_thread_NORETURN", "");
    }
    __asm__  volatile   ("movl\t%1, %0\n"
                         "movl\t%2, %%eax\n"
                         "movl\t%3, %%ebx\n"
                         "int\t$0x80\n": "=m" (tst->status): "n" (0), "n" (1),
                         "m" (tst->os_state.exitcode): "eax", "ebx");
    vgPlain_core_panic((Char *)"Thread exit failed?\n");
  }
  tmp___2 = __builtin_expect(0L, 1L);
  if (tmp___2) {

  } else {
    vgPlain_assert_fail((Bool )1, (Char const   *)"0",
                        (Char const   *)"m_syswrap/syswrap-linux.c", 260,
                        (Char const   *)"run_a_thread_NORETURN", "");
  }
  return;
}
}
Word vgModuleLocal_start_thread_NORETURN(void *arg ) 
{ 
  ThreadState *tst ;
  ThreadId tid ;
  long tmp ;

  {
  tst = (ThreadState *)arg;
  tid = tst->tid;
  run_a_thread_NORETURN((Word )tid);
  tmp = __builtin_expect(0L, 1L);
  if (tmp) {

  } else {
    vgPlain_assert_fail((Bool )1, (Char const   *)"0",
                        (Char const   *)"m_syswrap/syswrap-linux.c", 270,
                        (Char const   *)"vgModuleLocal_start_thread_NORETURN",
                        "");
  }
  return (0L);
}
}
Addr vgModuleLocal_allocstack(ThreadId tid ) 
{ 
  ThreadState *tst ;
  ThreadState *tmp ;
  VgStack *stack ;
  Addr initial_SP ;
  long tmp___0 ;
  long tmp___1 ;

  {
  tmp = vgPlain_get_ThreadState(tid);
  tst = tmp;
  if (tst->os_state.valgrind_stack_base == 0UL) {
    tmp___0 = __builtin_expect((long )(! (! (tst->os_state.valgrind_stack_init_SP == 0UL))),
                               1L);
    if (tmp___0) {

    } else {
      vgPlain_assert_fail((Bool )1,
                          (Char const   *)"tst->os_state.valgrind_stack_init_SP == 0",
                          (Char const   *)"m_syswrap/syswrap-linux.c", 287,
                          (Char const   *)"vgModuleLocal_allocstack", "");
    }
  } else {

  }
  if (tst->os_state.valgrind_stack_base != 0UL) {
    tmp___1 = __builtin_expect((long )(! (! (tst->os_state.valgrind_stack_init_SP != 0UL))),
                               1L);
    if (tmp___1) {

    } else {
      vgPlain_assert_fail((Bool )1,
                          (Char const   *)"tst->os_state.valgrind_stack_init_SP != 0",
                          (Char const   *)"m_syswrap/syswrap-linux.c", 290,
                          (Char const   *)"vgModuleLocal_allocstack", "");
    }
  } else {

  }
  if (tst->os_state.valgrind_stack_base == 0UL) {
    stack = vgPlain_am_alloc_VgStack(& initial_SP);
    if (stack) {
      tst->os_state.valgrind_stack_base = (Addr )stack;
      tst->os_state.valgrind_stack_init_SP = initial_SP;
    } else {

    }
  } else {

  }
  return (tst->os_state.valgrind_stack_init_SP);
}
}
void vgPlain_main_thread_wrapper_NORETURN(ThreadId tid ) 
{ 
  Addr sp ;
  long tmp ;
  Int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
  vgPlain_debugLog(1, "syswrap-linux",
                   "entering VG_(main_thread_wrapper_NORETURN)\n");
  sp = vgModuleLocal_allocstack(tid);
  tmp = __builtin_expect((long )(! (! (sp != 0UL))), 1L);
  if (tmp) {

  } else {
    vgPlain_assert_fail((Bool )1, (Char const   *)"sp != 0",
                        (Char const   *)"m_syswrap/syswrap-linux.c", 343,
                        (Char const   *)"vgPlain_main_thread_wrapper_NORETURN",
                        "Cannot allocate main thread\'s stack.");
  }
  tmp___0 = vgPlain_count_living_threads();
  if (tmp___0 == 1) {
    tmp___1 = 1;
  } else {
    tmp___1 = 0;
  }
  tmp___2 = __builtin_expect((long )tmp___1, 1L);
  if (tmp___2) {

  } else {
    vgPlain_assert_fail((Bool )1,
                        (Char const   *)"VG_(count_living_threads)() == 1",
                        (Char const   *)"m_syswrap/syswrap-linux.c", 346,
                        (Char const   *)"vgPlain_main_thread_wrapper_NORETURN",
                        "");
  }
  vgModuleLocal_call_on_new_stack_0_1(sp, (Addr )0, & run_a_thread_NORETURN,
                                      (Word )tid);
  tmp___3 = __builtin_expect(0L, 1L);
  if (tmp___3) {

  } else {
    vgPlain_assert_fail((Bool )1, (Char const   *)"0",
                        (Char const   *)"m_syswrap/syswrap-linux.c", 356,
                        (Char const   *)"vgPlain_main_thread_wrapper_NORETURN",
                        "");
  }
  return;
}
}
SysRes vgModuleLocal_do_fork_clone(ThreadId tid , UInt flags ,
                                   Int *parent_tidptr , Int *child_tidptr ) 
{ 
  vki_sigset_t fork_saved_mask ;
  vki_sigset_t mask ;
  SysRes res ;
  SysRes tmp ;
  UWord tmp___0 ;
  Int tmp___1 ;
  Bool tmp___2 ;
  UWord tmp___3 ;
  Bool tmp___4 ;
  UWord tmp___5 ;

  {
  if (flags & 542464U) {
    tmp = vgPlain_mk_SysRes_Error((UWord )22);
    return (tmp);
  } else {

  }
  vgPlain_sigfillset(& mask);
  vgPlain_sigprocmask(2, (vki_sigset_t const   *)(& mask), & fork_saved_mask);
  vgPlain_do_atfork_pre(tid);
  res = vgPlain_do_syscall((UWord )120, (UWord )flags, (UWord )((void *)0),
                           (UWord )parent_tidptr, (UWord )((void *)0),
                           (UWord )child_tidptr, (UWord )0, (UWord )0, (UWord )0);
  tmp___4 = sr_isError(res);
  if (tmp___4) {
    _L: /* CIL Label */ 
    tmp___2 = sr_isError(res);
    if (tmp___2) {

    } else {
      tmp___3 = sr_Res(res);
      if (tmp___3 > 0UL) {
        vgPlain_do_atfork_parent(tid);
        if (vgPlain_clo_trace_syscalls) {
          tmp___0 = sr_Res(res);
          tmp___1 = vgPlain_getpid();
          vgPlain_printf("   clone(fork): process %d created child %ld\n",
                         tmp___1, tmp___0);
        } else {

        }
        vgPlain_sigprocmask(2, (vki_sigset_t const   *)(& fork_saved_mask),
                            (vki_sigset_t *)((void *)0));
      } else {

      }
    }
  } else {
    tmp___5 = sr_Res(res);
    if (tmp___5 == 0UL) {
      vgPlain_do_atfork_child(tid);
      vgPlain_sigprocmask(2, (vki_sigset_t const   *)(& fork_saved_mask),
                          (vki_sigset_t *)((void *)0));
      if (vgPlain_clo_child_silent_after_fork) {
        if (! vgPlain_log_output_sink.is_socket) {
          vgPlain_log_output_sink.fd = -1;
        } else {

        }
        if (! vgPlain_xml_output_sink.is_socket) {
          vgPlain_xml_output_sink.fd = -1;
        } else {

        }
      } else {

      }
    } else {
      goto _L;
    }
  }
  return (res);
}
}
void vgSysWrap_linux_sys_mount_before(ThreadId tid , SyscallArgLayout *layout ,
                                      SyscallArgs *arrghs ,
                                      SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;
  Int here___3 ;
  long tmp___7 ;
  long tmp___8 ;

  {
  *flags |= (unsigned long )(1 << 1);
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_mount( %#lx(%s), %#lx(%s), %#lx(%s), %#lx, %#lx )",
                   arrghs->arg1, (Char *)arrghs->arg1, arrghs->arg2,
                   (Char *)arrghs->arg2, arrghs->arg3, (Char *)arrghs->arg3,
                   arrghs->arg4, arrghs->arg5);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(char *) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 474,
                            (Char const   *)"vgSysWrap_linux_sys_mount_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 474,
                            (Char const   *)"vgSysWrap_linux_sys_mount_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"mount(source)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(char *));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(char *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 474,
                            (Char const   *)"vgSysWrap_linux_sys_mount_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 474,
                            (Char const   *)"vgSysWrap_linux_sys_mount_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"mount(target)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(char *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(char *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 474,
                            (Char const   *)"vgSysWrap_linux_sys_mount_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 474,
                            (Char const   *)"vgSysWrap_linux_sys_mount_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"mount(type)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(char *));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(unsigned long ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned long) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 474,
                            (Char const   *)"vgSysWrap_linux_sys_mount_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 474,
                            (Char const   *)"vgSysWrap_linux_sys_mount_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"mount(flags)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(unsigned long ));
      break;
    }
    while (1) {
      here___3 = layout->o_arg5;
      tmp___7 = __builtin_expect((long )(! (! (sizeof(void *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___7) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(void *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 474,
                            (Char const   *)"vgSysWrap_linux_sys_mount_before",
                            "");
      }
      tmp___8 = __builtin_expect((long )(! (! (here___3 >= 0))), 1L);
      if (tmp___8) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 474,
                            (Char const   *)"vgSysWrap_linux_sys_mount_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"mount(data)",
                                            (PtrdiffT )here___3,
                                            (SizeT )sizeof(void *));
      break;
    }
  } else {

  }
  if (arrghs->arg1) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read_asciiz) {
        (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                     (Char *)"mount(source)",
                                                     arrghs->arg1);
      } else {

      }
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"mount(target)",
                                                   arrghs->arg2);
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"mount(type)",
                                                   arrghs->arg3);
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_oldumount_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_oldumount( %#lx )", arrghs->arg1);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(char *) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 484,
                            (Char const   *)"vgSysWrap_linux_sys_oldumount_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 484,
                            (Char const   *)"vgSysWrap_linux_sys_oldumount_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"umount(path)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(char *));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"umount(path)",
                                                   arrghs->arg1);
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_umount_before(ThreadId tid , SyscallArgLayout *layout ,
                                       SyscallArgs *arrghs ,
                                       SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_umount( %#lx, %ld )", arrghs->arg1, arrghs->arg2);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(char *) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 491,
                            (Char const   *)"vgSysWrap_linux_sys_umount_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 491,
                            (Char const   *)"vgSysWrap_linux_sys_umount_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"umount2(path)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(char *));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 491,
                            (Char const   *)"vgSysWrap_linux_sys_umount_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 491,
                            (Char const   *)"vgSysWrap_linux_sys_umount_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"umount2(flags)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"umount2(path)",
                                                   arrghs->arg1);
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_setfsuid16_before(ThreadId tid ,
                                           SyscallArgLayout *layout ,
                                           SyscallArgs *arrghs ,
                                           SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_setfsuid16 ( %ld )", arrghs->arg1);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_old_uid_t ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_old_uid_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 502,
                            (Char const   *)"vgSysWrap_linux_sys_setfsuid16_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 502,
                            (Char const   *)"vgSysWrap_linux_sys_setfsuid16_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"setfsuid16(uid)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_old_uid_t ));
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_setfsuid_before(ThreadId tid ,
                                         SyscallArgLayout *layout ,
                                         SyscallArgs *arrghs ,
                                         SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_setfsuid ( %ld )", arrghs->arg1);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_uid_t ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_uid_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 508,
                            (Char const   *)"vgSysWrap_linux_sys_setfsuid_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 508,
                            (Char const   *)"vgSysWrap_linux_sys_setfsuid_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"setfsuid(uid)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_uid_t ));
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_setfsgid16_before(ThreadId tid ,
                                           SyscallArgLayout *layout ,
                                           SyscallArgs *arrghs ,
                                           SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_setfsgid16 ( %ld )", arrghs->arg1);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_old_gid_t ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_old_gid_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 514,
                            (Char const   *)"vgSysWrap_linux_sys_setfsgid16_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 514,
                            (Char const   *)"vgSysWrap_linux_sys_setfsgid16_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"setfsgid16(gid)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_old_gid_t ));
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_setfsgid_before(ThreadId tid ,
                                         SyscallArgLayout *layout ,
                                         SyscallArgs *arrghs ,
                                         SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_setfsgid ( %ld )", arrghs->arg1);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_gid_t ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_gid_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 520,
                            (Char const   *)"vgSysWrap_linux_sys_setfsgid_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 520,
                            (Char const   *)"vgSysWrap_linux_sys_setfsgid_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"setfsgid(gid)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_gid_t ));
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_setresuid16_before(ThreadId tid ,
                                            SyscallArgLayout *layout ,
                                            SyscallArgs *arrghs ,
                                            SyscallStatus *status ,
                                            UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_setresuid16 ( %ld, %ld, %ld )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_old_uid_t ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_old_uid_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 527,
                            (Char const   *)"vgSysWrap_linux_sys_setresuid16_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 527,
                            (Char const   *)"vgSysWrap_linux_sys_setresuid16_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"setresuid16(ruid)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_old_uid_t ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(vki_old_uid_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_old_uid_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 527,
                            (Char const   *)"vgSysWrap_linux_sys_setresuid16_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 527,
                            (Char const   *)"vgSysWrap_linux_sys_setresuid16_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"setresuid16(euid)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(vki_old_uid_t ));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(vki_old_uid_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_old_uid_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 527,
                            (Char const   *)"vgSysWrap_linux_sys_setresuid16_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 527,
                            (Char const   *)"vgSysWrap_linux_sys_setresuid16_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"setresuid16(suid)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(vki_old_uid_t ));
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_setresuid_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_setresuid ( %ld, %ld, %ld )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_uid_t ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_uid_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 534,
                            (Char const   *)"vgSysWrap_linux_sys_setresuid_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 534,
                            (Char const   *)"vgSysWrap_linux_sys_setresuid_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"setresuid(ruid)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_uid_t ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(vki_uid_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_uid_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 534,
                            (Char const   *)"vgSysWrap_linux_sys_setresuid_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 534,
                            (Char const   *)"vgSysWrap_linux_sys_setresuid_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"setresuid(euid)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(vki_uid_t ));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(vki_uid_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_uid_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 534,
                            (Char const   *)"vgSysWrap_linux_sys_setresuid_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 534,
                            (Char const   *)"vgSysWrap_linux_sys_setresuid_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"setresuid(suid)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(vki_uid_t ));
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_getresuid16_before(ThreadId tid ,
                                            SyscallArgLayout *layout ,
                                            SyscallArgs *arrghs ,
                                            SyscallStatus *status ,
                                            UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_getresuid16 ( %#lx, %#lx, %#lx )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_old_uid_t *) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_old_uid_t *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 542,
                            (Char const   *)"vgSysWrap_linux_sys_getresuid16_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 542,
                            (Char const   *)"vgSysWrap_linux_sys_getresuid16_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"getresuid16(ruid)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_old_uid_t *));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(vki_old_uid_t *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_old_uid_t *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 542,
                            (Char const   *)"vgSysWrap_linux_sys_getresuid16_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 542,
                            (Char const   *)"vgSysWrap_linux_sys_getresuid16_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"getresuid16(euid)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(vki_old_uid_t *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(vki_old_uid_t *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_old_uid_t *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 542,
                            (Char const   *)"vgSysWrap_linux_sys_getresuid16_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 542,
                            (Char const   *)"vgSysWrap_linux_sys_getresuid16_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"getresuid16(suid)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(vki_old_uid_t *));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"getresuid16(ruid)",
                                             arrghs->arg1,
                                             (SizeT )sizeof(vki_old_uid_t ));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"getresuid16(euid)",
                                             arrghs->arg2,
                                             (SizeT )sizeof(vki_old_uid_t ));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"getresuid16(suid)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(vki_old_uid_t ));
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_getresuid16_after(ThreadId tid , SyscallArgs *arrghs ,
                                           SyscallStatus *status ) 
{ 
  Bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  UWord tmp___2 ;

  {
  if ((unsigned int )status->what == 1U) {
    tmp = sr_isError(status->sres);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
  } else {
    tmp___0 = 0;
  }
  tmp___1 = __builtin_expect((long )tmp___0, 1L);
  if (tmp___1) {

  } else {
    vgPlain_assert_fail((Bool )1, (Char const   *)"SUCCESS",
                        (Char const   *)"m_syswrap/syswrap-linux.c", 549,
                        (Char const   *)"vgSysWrap_linux_sys_getresuid16_after",
                        "");
  }
  tmp___2 = getRES(status);
  if (tmp___2 == 0UL) {
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg1,
                                                (SizeT )sizeof(vki_old_uid_t ));
      } else {

      }
      break;
    }
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg2,
                                                (SizeT )sizeof(vki_old_uid_t ));
      } else {

      }
      break;
    }
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                                (SizeT )sizeof(vki_old_uid_t ));
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_getresuid_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_getresuid ( %#lx, %#lx, %#lx )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_uid_t *) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_uid_t *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 561,
                            (Char const   *)"vgSysWrap_linux_sys_getresuid_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 561,
                            (Char const   *)"vgSysWrap_linux_sys_getresuid_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"getresuid(ruid)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_uid_t *));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(vki_uid_t *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_uid_t *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 561,
                            (Char const   *)"vgSysWrap_linux_sys_getresuid_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 561,
                            (Char const   *)"vgSysWrap_linux_sys_getresuid_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"getresuid(euid)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(vki_uid_t *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(vki_uid_t *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_uid_t *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 561,
                            (Char const   *)"vgSysWrap_linux_sys_getresuid_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 561,
                            (Char const   *)"vgSysWrap_linux_sys_getresuid_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"getresuid(suid)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(vki_uid_t *));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"getresuid(ruid)",
                                             arrghs->arg1,
                                             (SizeT )sizeof(vki_uid_t ));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"getresuid(euid)",
                                             arrghs->arg2,
                                             (SizeT )sizeof(vki_uid_t ));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"getresuid(suid)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(vki_uid_t ));
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_getresuid_after(ThreadId tid , SyscallArgs *arrghs ,
                                         SyscallStatus *status ) 
{ 
  Bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  UWord tmp___2 ;

  {
  if ((unsigned int )status->what == 1U) {
    tmp = sr_isError(status->sres);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
  } else {
    tmp___0 = 0;
  }
  tmp___1 = __builtin_expect((long )tmp___0, 1L);
  if (tmp___1) {

  } else {
    vgPlain_assert_fail((Bool )1, (Char const   *)"SUCCESS",
                        (Char const   *)"m_syswrap/syswrap-linux.c", 568,
                        (Char const   *)"vgSysWrap_linux_sys_getresuid_after",
                        "");
  }
  tmp___2 = getRES(status);
  if (tmp___2 == 0UL) {
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg1,
                                                (SizeT )sizeof(vki_uid_t ));
      } else {

      }
      break;
    }
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg2,
                                                (SizeT )sizeof(vki_uid_t ));
      } else {

      }
      break;
    }
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                                (SizeT )sizeof(vki_uid_t ));
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_setresgid16_before(ThreadId tid ,
                                            SyscallArgLayout *layout ,
                                            SyscallArgs *arrghs ,
                                            SyscallStatus *status ,
                                            UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_setresgid16 ( %ld, %ld, %ld )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_old_gid_t ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_old_gid_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 581,
                            (Char const   *)"vgSysWrap_linux_sys_setresgid16_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 581,
                            (Char const   *)"vgSysWrap_linux_sys_setresgid16_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"setresgid16(rgid)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_old_gid_t ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(vki_old_gid_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_old_gid_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 581,
                            (Char const   *)"vgSysWrap_linux_sys_setresgid16_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 581,
                            (Char const   *)"vgSysWrap_linux_sys_setresgid16_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"setresgid16(egid)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(vki_old_gid_t ));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(vki_old_gid_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_old_gid_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 581,
                            (Char const   *)"vgSysWrap_linux_sys_setresgid16_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 581,
                            (Char const   *)"vgSysWrap_linux_sys_setresgid16_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"setresgid16(sgid)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(vki_old_gid_t ));
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_setresgid_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_setresgid ( %ld, %ld, %ld )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_gid_t ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_gid_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 588,
                            (Char const   *)"vgSysWrap_linux_sys_setresgid_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 588,
                            (Char const   *)"vgSysWrap_linux_sys_setresgid_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"setresgid(rgid)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_gid_t ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(vki_gid_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_gid_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 588,
                            (Char const   *)"vgSysWrap_linux_sys_setresgid_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 588,
                            (Char const   *)"vgSysWrap_linux_sys_setresgid_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"setresgid(egid)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(vki_gid_t ));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(vki_gid_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_gid_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 588,
                            (Char const   *)"vgSysWrap_linux_sys_setresgid_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 588,
                            (Char const   *)"vgSysWrap_linux_sys_setresgid_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"setresgid(sgid)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(vki_gid_t ));
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_getresgid16_before(ThreadId tid ,
                                            SyscallArgLayout *layout ,
                                            SyscallArgs *arrghs ,
                                            SyscallStatus *status ,
                                            UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_getresgid16 ( %#lx, %#lx, %#lx )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_old_gid_t *) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_old_gid_t *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 596,
                            (Char const   *)"vgSysWrap_linux_sys_getresgid16_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 596,
                            (Char const   *)"vgSysWrap_linux_sys_getresgid16_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"getresgid16(rgid)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_old_gid_t *));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(vki_old_gid_t *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_old_gid_t *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 596,
                            (Char const   *)"vgSysWrap_linux_sys_getresgid16_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 596,
                            (Char const   *)"vgSysWrap_linux_sys_getresgid16_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"getresgid16(egid)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(vki_old_gid_t *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(vki_old_gid_t *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_old_gid_t *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 596,
                            (Char const   *)"vgSysWrap_linux_sys_getresgid16_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 596,
                            (Char const   *)"vgSysWrap_linux_sys_getresgid16_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"getresgid16(sgid)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(vki_old_gid_t *));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"getresgid16(rgid)",
                                             arrghs->arg1,
                                             (SizeT )sizeof(vki_old_gid_t ));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"getresgid16(egid)",
                                             arrghs->arg2,
                                             (SizeT )sizeof(vki_old_gid_t ));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"getresgid16(sgid)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(vki_old_gid_t ));
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_getresgid16_after(ThreadId tid , SyscallArgs *arrghs ,
                                           SyscallStatus *status ) 
{ 
  Bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  UWord tmp___2 ;

  {
  if ((unsigned int )status->what == 1U) {
    tmp = sr_isError(status->sres);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
  } else {
    tmp___0 = 0;
  }
  tmp___1 = __builtin_expect((long )tmp___0, 1L);
  if (tmp___1) {

  } else {
    vgPlain_assert_fail((Bool )1, (Char const   *)"SUCCESS",
                        (Char const   *)"m_syswrap/syswrap-linux.c", 603,
                        (Char const   *)"vgSysWrap_linux_sys_getresgid16_after",
                        "");
  }
  tmp___2 = getRES(status);
  if (tmp___2 == 0UL) {
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg1,
                                                (SizeT )sizeof(vki_old_gid_t ));
      } else {

      }
      break;
    }
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg2,
                                                (SizeT )sizeof(vki_old_gid_t ));
      } else {

      }
      break;
    }
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                                (SizeT )sizeof(vki_old_gid_t ));
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_getresgid_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_getresgid ( %#lx, %#lx, %#lx )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_gid_t *) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_gid_t *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 615,
                            (Char const   *)"vgSysWrap_linux_sys_getresgid_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 615,
                            (Char const   *)"vgSysWrap_linux_sys_getresgid_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"getresgid(rgid)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_gid_t *));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(vki_gid_t *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_gid_t *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 615,
                            (Char const   *)"vgSysWrap_linux_sys_getresgid_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 615,
                            (Char const   *)"vgSysWrap_linux_sys_getresgid_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"getresgid(egid)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(vki_gid_t *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(vki_gid_t *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_gid_t *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 615,
                            (Char const   *)"vgSysWrap_linux_sys_getresgid_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 615,
                            (Char const   *)"vgSysWrap_linux_sys_getresgid_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"getresgid(sgid)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(vki_gid_t *));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"getresgid(rgid)",
                                             arrghs->arg1,
                                             (SizeT )sizeof(vki_gid_t ));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"getresgid(egid)",
                                             arrghs->arg2,
                                             (SizeT )sizeof(vki_gid_t ));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"getresgid(sgid)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(vki_gid_t ));
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_getresgid_after(ThreadId tid , SyscallArgs *arrghs ,
                                         SyscallStatus *status ) 
{ 
  Bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  UWord tmp___2 ;

  {
  if ((unsigned int )status->what == 1U) {
    tmp = sr_isError(status->sres);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
  } else {
    tmp___0 = 0;
  }
  tmp___1 = __builtin_expect((long )tmp___0, 1L);
  if (tmp___1) {

  } else {
    vgPlain_assert_fail((Bool )1, (Char const   *)"SUCCESS",
                        (Char const   *)"m_syswrap/syswrap-linux.c", 622,
                        (Char const   *)"vgSysWrap_linux_sys_getresgid_after",
                        "");
  }
  tmp___2 = getRES(status);
  if (tmp___2 == 0UL) {
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg1,
                                                (SizeT )sizeof(vki_gid_t ));
      } else {

      }
      break;
    }
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg2,
                                                (SizeT )sizeof(vki_gid_t ));
      } else {

      }
      break;
    }
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                                (SizeT )sizeof(vki_gid_t ));
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_exit_group_before(ThreadId tid ,
                                           SyscallArgLayout *layout ,
                                           SyscallArgs *arrghs ,
                                           SyscallStatus *status , UWord *flags ) 
{ 
  ThreadId t ;
  ThreadState *tst ;
  Int here ;
  long tmp ;
  long tmp___0 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("exit_group( %ld )", arrghs->arg1);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 640,
                            (Char const   *)"vgSysWrap_linux_sys_exit_group_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 640,
                            (Char const   *)"vgSysWrap_linux_sys_exit_group_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"exit_group(status)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  tst = vgPlain_get_ThreadState(tid);
  t = (ThreadId )1;
  while (t < 500U) {
    if ((unsigned int )vgPlain_threads[t].status == 0U) {
      goto __Cont;
    } else
    if (vgPlain_threads[t].os_state.threadgroup != tst->os_state.threadgroup) {
      goto __Cont;
    } else {

    }
    vgPlain_threads[t].exitreason = (VgSchedReturnCode )1;
    vgPlain_threads[t].os_state.exitcode = (Word )arrghs->arg1;
    if (t != tid) {
      vgPlain_get_thread_out_of_syscall(t);
    } else {

    }
    __Cont: /* CIL Label */ 
    t ++;
  }
  while (1) {
    status->what = (enum __anonenum_what_129 )1;
    status->sres = vgPlain_mk_SysRes_Success((UWord )0);
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_llseek_before(ThreadId tid , SyscallArgLayout *layout ,
                                       SyscallArgs *arrghs ,
                                       SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;
  Int here___3 ;
  long tmp___7 ;
  long tmp___8 ;
  Word wzz ;
  int tmp___9 ;
  long tmp___10 ;
  Bool tmp___11 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_llseek ( %ld, 0x%lx, 0x%lx, %#lx, %ld )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3, arrghs->arg4, arrghs->arg5);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 672,
                            (Char const   *)"vgSysWrap_linux_sys_llseek_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 672,
                            (Char const   *)"vgSysWrap_linux_sys_llseek_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"llseek(fd)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(unsigned long ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned long) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 672,
                            (Char const   *)"vgSysWrap_linux_sys_llseek_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 672,
                            (Char const   *)"vgSysWrap_linux_sys_llseek_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"llseek(offset_high)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(unsigned long ));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(unsigned long ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned long) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 672,
                            (Char const   *)"vgSysWrap_linux_sys_llseek_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 672,
                            (Char const   *)"vgSysWrap_linux_sys_llseek_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"llseek(offset_low)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(unsigned long ));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(vki_loff_t *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_loff_t *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 672,
                            (Char const   *)"vgSysWrap_linux_sys_llseek_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 672,
                            (Char const   *)"vgSysWrap_linux_sys_llseek_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"llseek(result)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(vki_loff_t *));
      break;
    }
    while (1) {
      here___3 = layout->o_arg5;
      tmp___7 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___7) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 672,
                            (Char const   *)"vgSysWrap_linux_sys_llseek_before",
                            "");
      }
      tmp___8 = __builtin_expect((long )(! (! (here___3 >= 0))), 1L);
      if (tmp___8) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 672,
                            (Char const   *)"vgSysWrap_linux_sys_llseek_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"llseek(whence)",
                                            (PtrdiffT )here___3,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
  } else {

  }
  tmp___11 = vgModuleLocal_fd_allowed((Int )arrghs->arg1,
                                      (Char const   *)"llseek", tid, (Bool )0);
  if (tmp___11) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_write) {
        (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                               (Char *)"llseek(result)",
                                               arrghs->arg4,
                                               (SizeT )sizeof(vki_loff_t ));
      } else {

      }
      break;
    }
  } else {
    while (1) {
      wzz = (Word )9;
      if (wzz >= 0L) {
        if (wzz < 10000L) {
          tmp___9 = 1;
        } else {
          tmp___9 = 0;
        }
      } else {
        tmp___9 = 0;
      }
      tmp___10 = __builtin_expect((long )tmp___9, 1L);
      if (tmp___10) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"wzz >= 0 && wzz < 10000",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 674,
                            (Char const   *)"vgSysWrap_linux_sys_llseek_before",
                            "");
      }
      status->what = (enum __anonenum_what_129 )1;
      status->sres = vgPlain_mk_SysRes_Error((UWord )wzz);
      break;
    }
  }
  return;
}
}
void vgSysWrap_linux_sys_llseek_after(ThreadId tid , SyscallArgs *arrghs ,
                                      SyscallStatus *status ) 
{ 
  Bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  UWord tmp___2 ;

  {
  if ((unsigned int )status->what == 1U) {
    tmp = sr_isError(status->sres);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
  } else {
    tmp___0 = 0;
  }
  tmp___1 = __builtin_expect((long )tmp___0, 1L);
  if (tmp___1) {

  } else {
    vgPlain_assert_fail((Bool )1, (Char const   *)"SUCCESS",
                        (Char const   *)"m_syswrap/syswrap-linux.c", 680,
                        (Char const   *)"vgSysWrap_linux_sys_llseek_after", "");
  }
  tmp___2 = getRES(status);
  if (tmp___2 == 0UL) {
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg4,
                                                (SizeT )sizeof(vki_loff_t ));
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_adjtimex_before(ThreadId tid ,
                                         SyscallArgLayout *layout ,
                                         SyscallArgs *arrghs ,
                                         SyscallStatus *status , UWord *flags ) 
{ 
  struct vki_timex *tx ;
  Int here ;
  long tmp ;
  long tmp___0 ;

  {
  tx = (struct vki_timex *)arrghs->arg1;
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_adjtimex ( %#lx )", arrghs->arg1);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(struct timex *) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct timex *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 689,
                            (Char const   *)"vgSysWrap_linux_sys_adjtimex_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 689,
                            (Char const   *)"vgSysWrap_linux_sys_adjtimex_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"adjtimex(buf)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(struct timex *));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"adjtimex(timex->modes)",
                                            arrghs->arg1,
                                            (SizeT )sizeof(tx->modes));
    } else {

    }
    break;
  }
  if (tx->modes & 32768U) {
    if (! (tx->modes & 8192U)) {
      while (1) {
        if (vgPlain_tdict.track_pre_mem_read) {
          (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                                (Char *)"adjtimex(timex->offset)",
                                                (Addr )(& tx->offset),
                                                (SizeT )sizeof(tx->offset));
        } else {

        }
        break;
      }
    } else {

    }
  } else {
    if (tx->modes & 1U) {
      while (1) {
        if (vgPlain_tdict.track_pre_mem_read) {
          (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                                (Char *)"adjtimex(timex->offset)",
                                                (Addr )(& tx->offset),
                                                (SizeT )sizeof(tx->offset));
        } else {

        }
        break;
      }
    } else {

    }
    if (tx->modes & 2U) {
      while (1) {
        if (vgPlain_tdict.track_pre_mem_read) {
          (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                                (Char *)"adjtimex(timex->freq)",
                                                (Addr )(& tx->freq),
                                                (SizeT )sizeof(tx->freq));
        } else {

        }
        break;
      }
    } else {

    }
    if (tx->modes & 4U) {
      while (1) {
        if (vgPlain_tdict.track_pre_mem_read) {
          (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                                (Char *)"adjtimex(timex->maxerror)",
                                                (Addr )(& tx->maxerror),
                                                (SizeT )sizeof(tx->maxerror));
        } else {

        }
        break;
      }
    } else {

    }
    if (tx->modes & 8U) {
      while (1) {
        if (vgPlain_tdict.track_pre_mem_read) {
          (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                                (Char *)"adjtimex(timex->esterror)",
                                                (Addr )(& tx->esterror),
                                                (SizeT )sizeof(tx->esterror));
        } else {

        }
        break;
      }
    } else {

    }
    if (tx->modes & 16U) {
      while (1) {
        if (vgPlain_tdict.track_pre_mem_read) {
          (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                                (Char *)"adjtimex(timex->status)",
                                                (Addr )(& tx->status),
                                                (SizeT )sizeof(tx->status));
        } else {

        }
        break;
      }
    } else {

    }
    if (tx->modes & 160U) {
      while (1) {
        if (vgPlain_tdict.track_pre_mem_read) {
          (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                                (Char *)"adjtimex(timex->constant)",
                                                (Addr )(& tx->constant),
                                                (SizeT )sizeof(tx->constant));
        } else {

        }
        break;
      }
    } else {

    }
    if (tx->modes & 16384U) {
      while (1) {
        if (vgPlain_tdict.track_pre_mem_read) {
          (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                                (Char *)"adjtimex(timex->tick)",
                                                (Addr )(& tx->tick),
                                                (SizeT )sizeof(tx->tick));
        } else {

        }
        break;
      }
    } else {

    }
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"adjtimex(timex)",
                                             arrghs->arg1,
                                             (SizeT )sizeof(struct vki_timex ));
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_adjtimex_after(ThreadId tid , SyscallArgs *arrghs ,
                                        SyscallStatus *status ) 
{ 


  {
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg1,
                                              (SizeT )sizeof(struct vki_timex ));
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_ioperm_before(ThreadId tid , SyscallArgLayout *layout ,
                                       SyscallArgs *arrghs ,
                                       SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_ioperm ( %ld, %ld, %ld )", arrghs->arg1, arrghs->arg2,
                   arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(unsigned long ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned long) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 723,
                            (Char const   *)"vgSysWrap_linux_sys_ioperm_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 723,
                            (Char const   *)"vgSysWrap_linux_sys_ioperm_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"ioperm(from)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(unsigned long ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(unsigned long ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned long) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 723,
                            (Char const   *)"vgSysWrap_linux_sys_ioperm_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 723,
                            (Char const   *)"vgSysWrap_linux_sys_ioperm_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"ioperm(num)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(unsigned long ));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 723,
                            (Char const   *)"vgSysWrap_linux_sys_ioperm_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 723,
                            (Char const   *)"vgSysWrap_linux_sys_ioperm_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"ioperm(turn_on)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_syslog_before(ThreadId tid , SyscallArgLayout *layout ,
                                       SyscallArgs *arrghs ,
                                       SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  *flags |= (unsigned long )(1 << 1);
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_syslog (%ld, %#lx, %ld)", arrghs->arg1, arrghs->arg2,
                   arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 730,
                            (Char const   *)"vgSysWrap_linux_sys_syslog_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 730,
                            (Char const   *)"vgSysWrap_linux_sys_syslog_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"syslog(type)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(char *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 730,
                            (Char const   *)"vgSysWrap_linux_sys_syslog_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 730,
                            (Char const   *)"vgSysWrap_linux_sys_syslog_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"syslog(bufp)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(char *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 730,
                            (Char const   *)"vgSysWrap_linux_sys_syslog_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 730,
                            (Char const   *)"vgSysWrap_linux_sys_syslog_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"syslog(len)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  switch (arrghs->arg1) {
  case 4UL: 
  case 3UL: 
  case 2UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"syslog(bufp)",
                                             arrghs->arg2, arrghs->arg3);
    } else {

    }
    break;
  }
  break;
  default: 
  break;
  }
  return;
}
}
void vgSysWrap_linux_sys_syslog_after(ThreadId tid , SyscallArgs *arrghs ,
                                      SyscallStatus *status ) 
{ 


  {
  switch (arrghs->arg1) {
  case 4UL: 
  case 3UL: 
  case 2UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg2,
                                              arrghs->arg3);
    } else {

    }
    break;
  }
  break;
  default: 
  break;
  }
  return;
}
}
void vgSysWrap_linux_sys_vhangup_before(ThreadId tid ,
                                        SyscallArgLayout *layout ,
                                        SyscallArgs *arrghs ,
                                        SyscallStatus *status , UWord *flags ) 
{ 


  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_vhangup ( )");
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_sysinfo_before(ThreadId tid ,
                                        SyscallArgLayout *layout ,
                                        SyscallArgs *arrghs ,
                                        SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_sysinfo ( %#lx )", arrghs->arg1);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(struct sysinfo *) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct sysinfo *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 761,
                            (Char const   *)"vgSysWrap_linux_sys_sysinfo_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 761,
                            (Char const   *)"vgSysWrap_linux_sys_sysinfo_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sysinfo(info)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(struct sysinfo *));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"sysinfo(info)",
                                             arrghs->arg1,
                                             (SizeT )sizeof(struct vki_sysinfo ));
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_sysinfo_after(ThreadId tid , SyscallArgs *arrghs ,
                                       SyscallStatus *status ) 
{ 


  {
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg1,
                                              (SizeT )sizeof(struct vki_sysinfo ));
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_personality_before(ThreadId tid ,
                                            SyscallArgLayout *layout ,
                                            SyscallArgs *arrghs ,
                                            SyscallStatus *status ,
                                            UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_personality ( %llu )", (ULong )arrghs->arg1);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_u_long ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_u_long) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 772,
                            (Char const   *)"vgSysWrap_linux_sys_personality_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 772,
                            (Char const   *)"vgSysWrap_linux_sys_personality_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"personality(persona)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_u_long ));
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_sysctl_before(ThreadId tid , SyscallArgLayout *layout ,
                                       SyscallArgs *arrghs ,
                                       SyscallStatus *status , UWord *flags ) 
{ 
  struct __vki_sysctl_args *args ;
  Int here ;
  long tmp ;
  long tmp___0 ;
  Word wzz ;
  int tmp___1 ;
  long tmp___2 ;
  Bool tmp___3 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_sysctl ( %#lx )", arrghs->arg1);
  } else {

  }
  args = (struct __vki_sysctl_args *)arrghs->arg1;
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(struct __sysctl_args *) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct __sysctl_args *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 780,
                            (Char const   *)"vgSysWrap_linux_sys_sysctl_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 780,
                            (Char const   *)"vgSysWrap_linux_sys_sysctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sysctl(args)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(struct __sysctl_args *));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"sysctl(args)",
                                             arrghs->arg1,
                                             (SizeT )sizeof(struct __vki_sysctl_args ));
    } else {

    }
    break;
  }
  tmp___3 = vgPlain_am_is_valid_for_client(arrghs->arg1,
                                           (SizeT )sizeof(struct __vki_sysctl_args ),
                                           (UInt )1);
  if (tmp___3) {

  } else {
    while (1) {
      wzz = (Word )14;
      if (wzz >= 0L) {
        if (wzz < 10000L) {
          tmp___1 = 1;
        } else {
          tmp___1 = 0;
        }
      } else {
        tmp___1 = 0;
      }
      tmp___2 = __builtin_expect((long )tmp___1, 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"wzz >= 0 && wzz < 10000",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 784,
                            (Char const   *)"vgSysWrap_linux_sys_sysctl_before",
                            "");
      }
      status->what = (enum __anonenum_what_129 )1;
      status->sres = vgPlain_mk_SysRes_Error((UWord )wzz);
      break;
    }
    return;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"sysctl(name)",
                                            (Addr )args->name,
                                            (SizeT )((unsigned int )args->nlen * sizeof(*(args->name))));
    } else {

    }
    break;
  }
  if ((unsigned int )args->newval != (unsigned int )((void *)0)) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"sysctl(newval)",
                                              (Addr )args->newval,
                                              (SizeT )args->newlen);
      } else {

      }
      break;
    }
  } else {

  }
  if ((unsigned int )args->oldlenp != (unsigned int )((void *)0)) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"sysctl(oldlenp)",
                                              (Addr )args->oldlenp,
                                              (SizeT )sizeof(*(args->oldlenp)));
      } else {

      }
      break;
    }
    while (1) {
      if (vgPlain_tdict.track_pre_mem_write) {
        (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                               (Char *)"sysctl(oldval)",
                                               (Addr )args->oldval,
                                               (SizeT )*(args->oldlenp));
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_sysctl_after(ThreadId tid , SyscallArgs *arrghs ,
                                      SyscallStatus *status ) 
{ 
  struct __vki_sysctl_args *args ;

  {
  args = (struct __vki_sysctl_args *)arrghs->arg1;
  if ((unsigned int )args->oldlenp != (unsigned int )((void *)0)) {
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                (Addr )args->oldlenp,
                                                (SizeT )sizeof(*(args->oldlenp)));
      } else {

      }
      break;
    }
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                (Addr )args->oldval,
                                                (SizeT )(1U + *(args->oldlenp)));
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_prctl_before(ThreadId tid , SyscallArgLayout *layout ,
                                      SyscallArgs *arrghs ,
                                      SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;
  Int here___3 ;
  long tmp___7 ;
  long tmp___8 ;
  Int here___4 ;
  long tmp___9 ;
  long tmp___10 ;
  Int here___5 ;
  long tmp___11 ;
  long tmp___12 ;
  Int here___6 ;
  long tmp___13 ;
  long tmp___14 ;
  Int here___7 ;
  long tmp___15 ;
  long tmp___16 ;
  Int here___8 ;
  long tmp___17 ;
  long tmp___18 ;
  Int here___9 ;
  long tmp___19 ;
  long tmp___20 ;
  Int here___10 ;
  long tmp___21 ;
  long tmp___22 ;
  Int here___11 ;
  long tmp___23 ;
  long tmp___24 ;
  Int here___12 ;
  long tmp___25 ;
  long tmp___26 ;
  Int here___13 ;
  long tmp___27 ;
  long tmp___28 ;
  Int here___14 ;
  long tmp___29 ;
  long tmp___30 ;
  Int here___15 ;
  long tmp___31 ;
  long tmp___32 ;
  Int here___16 ;
  long tmp___33 ;
  long tmp___34 ;
  Int here___17 ;
  long tmp___35 ;
  long tmp___36 ;
  Int here___18 ;
  long tmp___37 ;
  long tmp___38 ;
  Int here___19 ;
  long tmp___39 ;
  long tmp___40 ;
  Int here___20 ;
  long tmp___41 ;
  long tmp___42 ;
  Int here___21 ;
  long tmp___43 ;
  long tmp___44 ;
  Int here___22 ;
  long tmp___45 ;
  long tmp___46 ;
  Int here___23 ;
  long tmp___47 ;
  long tmp___48 ;
  Int here___24 ;
  long tmp___49 ;
  long tmp___50 ;
  Int here___25 ;
  long tmp___51 ;
  long tmp___52 ;
  Int here___26 ;
  long tmp___53 ;
  long tmp___54 ;
  Int here___27 ;
  long tmp___55 ;
  long tmp___56 ;
  Int here___28 ;
  long tmp___57 ;
  long tmp___58 ;
  Int here___29 ;
  long tmp___59 ;
  long tmp___60 ;
  Int here___30 ;
  long tmp___61 ;
  long tmp___62 ;
  Int here___31 ;
  long tmp___63 ;
  long tmp___64 ;
  Int here___32 ;
  long tmp___65 ;
  long tmp___66 ;
  Int here___33 ;
  long tmp___67 ;
  long tmp___68 ;
  Int here___34 ;
  long tmp___69 ;
  long tmp___70 ;
  Int here___35 ;
  long tmp___71 ;
  long tmp___72 ;
  Int here___36 ;
  long tmp___73 ;
  long tmp___74 ;

  {
  *flags |= (unsigned long )(1 << 1);
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_prctl ( %ld, %ld, %ld, %ld, %ld )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3, arrghs->arg4, arrghs->arg5);
  } else {

  }
  switch (arrghs->arg1) {
  case 1UL: 
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 812,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 812,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"prctl(option)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 812,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 812,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"prctl(signal)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  break;
  case 2UL: 
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___1 = layout->o_arg1;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 815,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 815,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"prctl(option)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___2 = layout->o_arg2;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(int *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 815,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 815,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"prctl(signal)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(int *));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"prctl(get-death-signal)",
                                             arrghs->arg2, (SizeT )sizeof(Int ));
    } else {

    }
    break;
  }
  break;
  case 3UL: 
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___3 = layout->o_arg1;
      tmp___7 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___7) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 819,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      tmp___8 = __builtin_expect((long )(! (! (here___3 >= 0))), 1L);
      if (tmp___8) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 819,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"prctl(option)",
                                            (PtrdiffT )here___3,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  break;
  case 4UL: 
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___4 = layout->o_arg1;
      tmp___9 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___9) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 822,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      tmp___10 = __builtin_expect((long )(! (! (here___4 >= 0))), 1L);
      if (tmp___10) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 822,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"prctl(option)",
                                            (PtrdiffT )here___4,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___5 = layout->o_arg2;
      tmp___11 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___11) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 822,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      tmp___12 = __builtin_expect((long )(! (! (here___5 >= 0))), 1L);
      if (tmp___12) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 822,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"prctl(dump)",
                                            (PtrdiffT )here___5,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  break;
  case 5UL: 
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___6 = layout->o_arg1;
      tmp___13 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___13) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 825,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      tmp___14 = __builtin_expect((long )(! (! (here___6 >= 0))), 1L);
      if (tmp___14) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 825,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"prctl(option)",
                                            (PtrdiffT )here___6,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___7 = layout->o_arg2;
      tmp___15 = __builtin_expect((long )(! (! (sizeof(int *) <= sizeof(UWord )))),
                                  1L);
      if (tmp___15) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 825,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      tmp___16 = __builtin_expect((long )(! (! (here___7 >= 0))), 1L);
      if (tmp___16) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 825,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"prctl(value)",
                                            (PtrdiffT )here___7,
                                            (SizeT )sizeof(int *));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"prctl(get-unalign)",
                                             arrghs->arg2, (SizeT )sizeof(Int ));
    } else {

    }
    break;
  }
  break;
  case 6UL: 
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___8 = layout->o_arg1;
      tmp___17 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___17) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 829,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      tmp___18 = __builtin_expect((long )(! (! (here___8 >= 0))), 1L);
      if (tmp___18) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 829,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"prctl(option)",
                                            (PtrdiffT )here___8,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___9 = layout->o_arg2;
      tmp___19 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___19) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 829,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      tmp___20 = __builtin_expect((long )(! (! (here___9 >= 0))), 1L);
      if (tmp___20) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 829,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"prctl(value)",
                                            (PtrdiffT )here___9,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  break;
  case 7UL: 
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___10 = layout->o_arg1;
      tmp___21 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___21) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 832,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      tmp___22 = __builtin_expect((long )(! (! (here___10 >= 0))), 1L);
      if (tmp___22) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 832,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"prctl(option)",
                                            (PtrdiffT )here___10,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  break;
  case 8UL: 
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___11 = layout->o_arg1;
      tmp___23 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___23) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 835,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      tmp___24 = __builtin_expect((long )(! (! (here___11 >= 0))), 1L);
      if (tmp___24) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 835,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"prctl(option)",
                                            (PtrdiffT )here___11,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___12 = layout->o_arg2;
      tmp___25 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___25) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 835,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      tmp___26 = __builtin_expect((long )(! (! (here___12 >= 0))), 1L);
      if (tmp___26) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 835,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"prctl(keepcaps)",
                                            (PtrdiffT )here___12,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  break;
  case 9UL: 
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___13 = layout->o_arg1;
      tmp___27 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___27) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 838,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      tmp___28 = __builtin_expect((long )(! (! (here___13 >= 0))), 1L);
      if (tmp___28) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 838,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"prctl(option)",
                                            (PtrdiffT )here___13,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___14 = layout->o_arg2;
      tmp___29 = __builtin_expect((long )(! (! (sizeof(int *) <= sizeof(UWord )))),
                                  1L);
      if (tmp___29) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 838,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      tmp___30 = __builtin_expect((long )(! (! (here___14 >= 0))), 1L);
      if (tmp___30) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 838,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"prctl(value)",
                                            (PtrdiffT )here___14,
                                            (SizeT )sizeof(int *));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"prctl(get-fpemu)",
                                             arrghs->arg2, (SizeT )sizeof(Int ));
    } else {

    }
    break;
  }
  break;
  case 10UL: 
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___15 = layout->o_arg1;
      tmp___31 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___31) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 842,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      tmp___32 = __builtin_expect((long )(! (! (here___15 >= 0))), 1L);
      if (tmp___32) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 842,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"prctl(option)",
                                            (PtrdiffT )here___15,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___16 = layout->o_arg2;
      tmp___33 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___33) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 842,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      tmp___34 = __builtin_expect((long )(! (! (here___16 >= 0))), 1L);
      if (tmp___34) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 842,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"prctl(value)",
                                            (PtrdiffT )here___16,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  break;
  case 11UL: 
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___17 = layout->o_arg1;
      tmp___35 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___35) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 845,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      tmp___36 = __builtin_expect((long )(! (! (here___17 >= 0))), 1L);
      if (tmp___36) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 845,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"prctl(option)",
                                            (PtrdiffT )here___17,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___18 = layout->o_arg2;
      tmp___37 = __builtin_expect((long )(! (! (sizeof(int *) <= sizeof(UWord )))),
                                  1L);
      if (tmp___37) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 845,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      tmp___38 = __builtin_expect((long )(! (! (here___18 >= 0))), 1L);
      if (tmp___38) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 845,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"prctl(value)",
                                            (PtrdiffT )here___18,
                                            (SizeT )sizeof(int *));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"prctl(get-fpexc)",
                                             arrghs->arg2, (SizeT )sizeof(Int ));
    } else {

    }
    break;
  }
  break;
  case 12UL: 
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___19 = layout->o_arg1;
      tmp___39 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___39) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 849,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      tmp___40 = __builtin_expect((long )(! (! (here___19 >= 0))), 1L);
      if (tmp___40) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 849,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"prctl(option)",
                                            (PtrdiffT )here___19,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___20 = layout->o_arg2;
      tmp___41 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___41) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 849,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      tmp___42 = __builtin_expect((long )(! (! (here___20 >= 0))), 1L);
      if (tmp___42) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 849,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"prctl(value)",
                                            (PtrdiffT )here___20,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  break;
  case 13UL: 
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___21 = layout->o_arg1;
      tmp___43 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___43) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 852,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      tmp___44 = __builtin_expect((long )(! (! (here___21 >= 0))), 1L);
      if (tmp___44) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 852,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"prctl(option)",
                                            (PtrdiffT )here___21,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  break;
  case 14UL: 
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___22 = layout->o_arg1;
      tmp___45 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___45) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 855,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      tmp___46 = __builtin_expect((long )(! (! (here___22 >= 0))), 1L);
      if (tmp___46) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 855,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"prctl(option)",
                                            (PtrdiffT )here___22,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___23 = layout->o_arg2;
      tmp___47 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___47) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 855,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      tmp___48 = __builtin_expect((long )(! (! (here___23 >= 0))), 1L);
      if (tmp___48) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 855,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"prctl(timing)",
                                            (PtrdiffT )here___23,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  break;
  case 15UL: 
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___24 = layout->o_arg1;
      tmp___49 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___49) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 858,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      tmp___50 = __builtin_expect((long )(! (! (here___24 >= 0))), 1L);
      if (tmp___50) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 858,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"prctl(option)",
                                            (PtrdiffT )here___24,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___25 = layout->o_arg2;
      tmp___51 = __builtin_expect((long )(! (! (sizeof(char *) <= sizeof(UWord )))),
                                  1L);
      if (tmp___51) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 858,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      tmp___52 = __builtin_expect((long )(! (! (here___25 >= 0))), 1L);
      if (tmp___52) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 858,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"prctl(name)",
                                            (PtrdiffT )here___25,
                                            (SizeT )sizeof(char *));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"prctl(set-name)",
                                                   arrghs->arg2);
    } else {

    }
    break;
  }
  break;
  case 16UL: 
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___26 = layout->o_arg1;
      tmp___53 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___53) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 862,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      tmp___54 = __builtin_expect((long )(! (! (here___26 >= 0))), 1L);
      if (tmp___54) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 862,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"prctl(option)",
                                            (PtrdiffT )here___26,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___27 = layout->o_arg2;
      tmp___55 = __builtin_expect((long )(! (! (sizeof(char *) <= sizeof(UWord )))),
                                  1L);
      if (tmp___55) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 862,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      tmp___56 = __builtin_expect((long )(! (! (here___27 >= 0))), 1L);
      if (tmp___56) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 862,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"prctl(name)",
                                            (PtrdiffT )here___27,
                                            (SizeT )sizeof(char *));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"prctl(get-name)",
                                             arrghs->arg2, (SizeT )16);
    } else {

    }
    break;
  }
  break;
  case 19UL: 
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___28 = layout->o_arg1;
      tmp___57 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___57) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 866,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      tmp___58 = __builtin_expect((long )(! (! (here___28 >= 0))), 1L);
      if (tmp___58) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 866,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"prctl(option)",
                                            (PtrdiffT )here___28,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___29 = layout->o_arg2;
      tmp___59 = __builtin_expect((long )(! (! (sizeof(int *) <= sizeof(UWord )))),
                                  1L);
      if (tmp___59) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 866,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      tmp___60 = __builtin_expect((long )(! (! (here___29 >= 0))), 1L);
      if (tmp___60) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 866,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"prctl(value)",
                                            (PtrdiffT )here___29,
                                            (SizeT )sizeof(int *));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"prctl(get-endian)",
                                             arrghs->arg2, (SizeT )sizeof(Int ));
    } else {

    }
    break;
  }
  break;
  case 20UL: 
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___30 = layout->o_arg1;
      tmp___61 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___61) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 870,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      tmp___62 = __builtin_expect((long )(! (! (here___30 >= 0))), 1L);
      if (tmp___62) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 870,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"prctl(option)",
                                            (PtrdiffT )here___30,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___31 = layout->o_arg2;
      tmp___63 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___63) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 870,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      tmp___64 = __builtin_expect((long )(! (! (here___31 >= 0))), 1L);
      if (tmp___64) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 870,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"prctl(value)",
                                            (PtrdiffT )here___31,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  break;
  default: 
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___32 = layout->o_arg1;
      tmp___65 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___65) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 875,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      tmp___66 = __builtin_expect((long )(! (! (here___32 >= 0))), 1L);
      if (tmp___66) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 875,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"prctl(option)",
                                            (PtrdiffT )here___32,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___33 = layout->o_arg2;
      tmp___67 = __builtin_expect((long )(! (! (sizeof(unsigned long ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___67) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned long) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 875,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      tmp___68 = __builtin_expect((long )(! (! (here___33 >= 0))), 1L);
      if (tmp___68) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 875,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"prctl(arg2)",
                                            (PtrdiffT )here___33,
                                            (SizeT )sizeof(unsigned long ));
      break;
    }
    while (1) {
      here___34 = layout->o_arg3;
      tmp___69 = __builtin_expect((long )(! (! (sizeof(unsigned long ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___69) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned long) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 875,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      tmp___70 = __builtin_expect((long )(! (! (here___34 >= 0))), 1L);
      if (tmp___70) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 875,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"prctl(arg3)",
                                            (PtrdiffT )here___34,
                                            (SizeT )sizeof(unsigned long ));
      break;
    }
    while (1) {
      here___35 = layout->o_arg4;
      tmp___71 = __builtin_expect((long )(! (! (sizeof(unsigned long ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___71) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned long) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 875,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      tmp___72 = __builtin_expect((long )(! (! (here___35 >= 0))), 1L);
      if (tmp___72) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 875,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"prctl(arg4)",
                                            (PtrdiffT )here___35,
                                            (SizeT )sizeof(unsigned long ));
      break;
    }
    while (1) {
      here___36 = layout->o_arg5;
      tmp___73 = __builtin_expect((long )(! (! (sizeof(unsigned long ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___73) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned long) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 875,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      tmp___74 = __builtin_expect((long )(! (! (here___36 >= 0))), 1L);
      if (tmp___74) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 875,
                            (Char const   *)"vgSysWrap_linux_sys_prctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"prctl(arg5)",
                                            (PtrdiffT )here___36,
                                            (SizeT )sizeof(unsigned long ));
      break;
    }
  } else {

  }
  break;
  }
  return;
}
}
void vgSysWrap_linux_sys_prctl_after(ThreadId tid , SyscallArgs *arrghs ,
                                     SyscallStatus *status ) 
{ 


  {
  switch (arrghs->arg1) {
  case 2UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg2,
                                              (SizeT )sizeof(Int ));
    } else {

    }
    break;
  }
  break;
  case 5UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg2,
                                              (SizeT )sizeof(Int ));
    } else {

    }
    break;
  }
  break;
  case 9UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg2,
                                              (SizeT )sizeof(Int ));
    } else {

    }
    break;
  }
  break;
  case 11UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg2,
                                              (SizeT )sizeof(Int ));
    } else {

    }
    break;
  }
  break;
  case 16UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg2,
                                              (SizeT )16);
    } else {

    }
    break;
  }
  break;
  case 19UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg2,
                                              (SizeT )sizeof(Int ));
    } else {

    }
    break;
  }
  break;
  }
  return;
}
}
void vgSysWrap_linux_sys_sendfile_before(ThreadId tid ,
                                         SyscallArgLayout *layout ,
                                         SyscallArgs *arrghs ,
                                         SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;

  {
  *flags |= (unsigned long )(1 << 1);
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_sendfile ( %ld, %ld, %#lx, %lu )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3, arrghs->arg4);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 909,
                            (Char const   *)"vgSysWrap_linux_sys_sendfile_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 909,
                            (Char const   *)"vgSysWrap_linux_sys_sendfile_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sendfile(out_fd)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 909,
                            (Char const   *)"vgSysWrap_linux_sys_sendfile_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 909,
                            (Char const   *)"vgSysWrap_linux_sys_sendfile_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sendfile(in_fd)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(vki_off_t *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_off_t *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 909,
                            (Char const   *)"vgSysWrap_linux_sys_sendfile_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 909,
                            (Char const   *)"vgSysWrap_linux_sys_sendfile_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sendfile(offset)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(vki_off_t *));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(vki_size_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_size_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 909,
                            (Char const   *)"vgSysWrap_linux_sys_sendfile_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 909,
                            (Char const   *)"vgSysWrap_linux_sys_sendfile_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sendfile(count)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(vki_size_t ));
      break;
    }
  } else {

  }
  if (arrghs->arg3 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_write) {
        (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                               (Char *)"sendfile(offset)",
                                               arrghs->arg3,
                                               (SizeT )sizeof(vki_off_t ));
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_sendfile_after(ThreadId tid , SyscallArgs *arrghs ,
                                        SyscallStatus *status ) 
{ 


  {
  if (arrghs->arg3 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                                (SizeT )sizeof(vki_off_t ));
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_sendfile64_before(ThreadId tid ,
                                           SyscallArgLayout *layout ,
                                           SyscallArgs *arrghs ,
                                           SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;

  {
  *flags |= (unsigned long )(1 << 1);
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sendfile64 ( %ld, %ld, %#lx, %lu )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3, arrghs->arg4);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 926,
                            (Char const   *)"vgSysWrap_linux_sys_sendfile64_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 926,
                            (Char const   *)"vgSysWrap_linux_sys_sendfile64_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sendfile64(out_fd)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 926,
                            (Char const   *)"vgSysWrap_linux_sys_sendfile64_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 926,
                            (Char const   *)"vgSysWrap_linux_sys_sendfile64_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sendfile64(in_fd)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(vki_loff_t *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_loff_t *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 926,
                            (Char const   *)"vgSysWrap_linux_sys_sendfile64_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 926,
                            (Char const   *)"vgSysWrap_linux_sys_sendfile64_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sendfile64(offset)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(vki_loff_t *));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(vki_size_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_size_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 926,
                            (Char const   *)"vgSysWrap_linux_sys_sendfile64_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 926,
                            (Char const   *)"vgSysWrap_linux_sys_sendfile64_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sendfile64(count)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(vki_size_t ));
      break;
    }
  } else {

  }
  if (arrghs->arg3 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_write) {
        (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                               (Char *)"sendfile64(offset)",
                                               arrghs->arg3,
                                               (SizeT )sizeof(vki_loff_t ));
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_sendfile64_after(ThreadId tid , SyscallArgs *arrghs ,
                                          SyscallStatus *status ) 
{ 


  {
  if (arrghs->arg3 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                                (SizeT )sizeof(vki_loff_t ));
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_futex_before(ThreadId tid , SyscallArgLayout *layout ,
                                      SyscallArgs *arrghs ,
                                      SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;
  Int here___3 ;
  long tmp___7 ;
  long tmp___8 ;
  Int here___4 ;
  long tmp___9 ;
  long tmp___10 ;
  Int here___5 ;
  long tmp___11 ;
  long tmp___12 ;
  Int here___6 ;
  long tmp___13 ;
  long tmp___14 ;
  Int here___7 ;
  long tmp___15 ;
  long tmp___16 ;
  Int here___8 ;
  long tmp___17 ;
  long tmp___18 ;
  Int here___9 ;
  long tmp___19 ;
  long tmp___20 ;
  Int here___10 ;
  long tmp___21 ;
  long tmp___22 ;
  Int here___11 ;
  long tmp___23 ;
  long tmp___24 ;
  Int here___12 ;
  long tmp___25 ;
  long tmp___26 ;
  Int here___13 ;
  long tmp___27 ;
  long tmp___28 ;
  Int here___14 ;
  long tmp___29 ;
  long tmp___30 ;
  Int here___15 ;
  long tmp___31 ;
  long tmp___32 ;
  Int here___16 ;
  long tmp___33 ;
  long tmp___34 ;
  Int here___17 ;
  long tmp___35 ;
  long tmp___36 ;
  Int here___18 ;
  long tmp___37 ;
  long tmp___38 ;
  Int here___19 ;
  long tmp___39 ;
  long tmp___40 ;
  Int here___20 ;
  long tmp___41 ;
  long tmp___42 ;
  Int here___21 ;
  long tmp___43 ;
  long tmp___44 ;
  Int here___22 ;
  long tmp___45 ;
  long tmp___46 ;
  Int here___23 ;
  long tmp___47 ;
  long tmp___48 ;
  Int here___24 ;
  long tmp___49 ;
  long tmp___50 ;
  Int here___25 ;
  long tmp___51 ;
  long tmp___52 ;
  Int here___26 ;
  long tmp___53 ;
  long tmp___54 ;
  Int here___27 ;
  long tmp___55 ;
  long tmp___56 ;
  Int here___28 ;
  long tmp___57 ;
  long tmp___58 ;
  Int here___29 ;
  long tmp___59 ;
  long tmp___60 ;
  Int here___30 ;
  long tmp___61 ;
  long tmp___62 ;
  Word wzz ;
  int tmp___63 ;
  long tmp___64 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_futex ( %#lx, %ld, %ld, %#lx, %#lx )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3, arrghs->arg4, arrghs->arg5);
  } else {

  }
  switch (arrghs->arg2 & 4294966911UL) {
  case 12UL: 
  case 5UL: 
  case 4UL: 
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_u32 *) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_u32 *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 956,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 956,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"futex(futex)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_u32 *));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 956,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 956,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"futex(op)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 956,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 956,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"futex(val)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(struct timespec *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct timespec *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 956,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 956,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"futex(utime)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(struct timespec *));
      break;
    }
    while (1) {
      here___3 = layout->o_arg5;
      tmp___7 = __builtin_expect((long )(! (! (sizeof(vki_u32 *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___7) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_u32 *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 956,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      tmp___8 = __builtin_expect((long )(! (! (here___3 >= 0))), 1L);
      if (tmp___8) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 956,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"futex(uaddr2)",
                                            (PtrdiffT )here___3,
                                            (SizeT )sizeof(vki_u32 *));
      break;
    }
    while (1) {
      here___4 = layout->o_arg6;
      tmp___9 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___9) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 956,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      tmp___10 = __builtin_expect((long )(! (! (here___4 >= 0))), 1L);
      if (tmp___10) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 956,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"futex(val3)",
                                            (PtrdiffT )here___4,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  break;
  case 11UL: 
  case 3UL: 
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___5 = layout->o_arg1;
      tmp___11 = __builtin_expect((long )(! (! (sizeof(vki_u32 *) <= sizeof(UWord )))),
                                  1L);
      if (tmp___11) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_u32 *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 962,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      tmp___12 = __builtin_expect((long )(! (! (here___5 >= 0))), 1L);
      if (tmp___12) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 962,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"futex(futex)",
                                            (PtrdiffT )here___5,
                                            (SizeT )sizeof(vki_u32 *));
      break;
    }
    while (1) {
      here___6 = layout->o_arg2;
      tmp___13 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___13) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 962,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      tmp___14 = __builtin_expect((long )(! (! (here___6 >= 0))), 1L);
      if (tmp___14) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 962,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"futex(op)",
                                            (PtrdiffT )here___6,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___7 = layout->o_arg3;
      tmp___15 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___15) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 962,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      tmp___16 = __builtin_expect((long )(! (! (here___7 >= 0))), 1L);
      if (tmp___16) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 962,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"futex(val)",
                                            (PtrdiffT )here___7,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___8 = layout->o_arg4;
      tmp___17 = __builtin_expect((long )(! (! (sizeof(struct timespec *) <= sizeof(UWord )))),
                                  1L);
      if (tmp___17) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct timespec *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 962,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      tmp___18 = __builtin_expect((long )(! (! (here___8 >= 0))), 1L);
      if (tmp___18) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 962,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"futex(utime)",
                                            (PtrdiffT )here___8,
                                            (SizeT )sizeof(struct timespec *));
      break;
    }
    while (1) {
      here___9 = layout->o_arg5;
      tmp___19 = __builtin_expect((long )(! (! (sizeof(vki_u32 *) <= sizeof(UWord )))),
                                  1L);
      if (tmp___19) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_u32 *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 962,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      tmp___20 = __builtin_expect((long )(! (! (here___9 >= 0))), 1L);
      if (tmp___20) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 962,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"futex(uaddr2)",
                                            (PtrdiffT )here___9,
                                            (SizeT )sizeof(vki_u32 *));
      break;
    }
  } else {

  }
  break;
  case 9UL: 
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___10 = layout->o_arg1;
      tmp___21 = __builtin_expect((long )(! (! (sizeof(vki_u32 *) <= sizeof(UWord )))),
                                  1L);
      if (tmp___21) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_u32 *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 967,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      tmp___22 = __builtin_expect((long )(! (! (here___10 >= 0))), 1L);
      if (tmp___22) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 967,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"futex(futex)",
                                            (PtrdiffT )here___10,
                                            (SizeT )sizeof(vki_u32 *));
      break;
    }
    while (1) {
      here___11 = layout->o_arg2;
      tmp___23 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___23) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 967,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      tmp___24 = __builtin_expect((long )(! (! (here___11 >= 0))), 1L);
      if (tmp___24) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 967,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"futex(op)",
                                            (PtrdiffT )here___11,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___12 = layout->o_arg3;
      tmp___25 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___25) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 967,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      tmp___26 = __builtin_expect((long )(! (! (here___12 >= 0))), 1L);
      if (tmp___26) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 967,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"futex(val)",
                                            (PtrdiffT )here___12,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___13 = layout->o_arg4;
      tmp___27 = __builtin_expect((long )(! (! (sizeof(struct timespec *) <= sizeof(UWord )))),
                                  1L);
      if (tmp___27) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct timespec *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 967,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      tmp___28 = __builtin_expect((long )(! (! (here___13 >= 0))), 1L);
      if (tmp___28) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 967,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"futex(utime)",
                                            (PtrdiffT )here___13,
                                            (SizeT )sizeof(struct timespec *));
      break;
    }
    while (1) {
      here___14 = layout->o_arg5;
      tmp___29 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___29) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 967,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      tmp___30 = __builtin_expect((long )(! (! (here___14 >= 0))), 1L);
      if (tmp___30) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 967,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"futex(dummy)",
                                            (PtrdiffT )here___14,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___15 = layout->o_arg6;
      tmp___31 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___31) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 967,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      tmp___32 = __builtin_expect((long )(! (! (here___15 >= 0))), 1L);
      if (tmp___32) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 967,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"futex(val3)",
                                            (PtrdiffT )here___15,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  break;
  case 10UL: 
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___16 = layout->o_arg1;
      tmp___33 = __builtin_expect((long )(! (! (sizeof(vki_u32 *) <= sizeof(UWord )))),
                                  1L);
      if (tmp___33) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_u32 *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 972,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      tmp___34 = __builtin_expect((long )(! (! (here___16 >= 0))), 1L);
      if (tmp___34) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 972,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"futex(futex)",
                                            (PtrdiffT )here___16,
                                            (SizeT )sizeof(vki_u32 *));
      break;
    }
    while (1) {
      here___17 = layout->o_arg2;
      tmp___35 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___35) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 972,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      tmp___36 = __builtin_expect((long )(! (! (here___17 >= 0))), 1L);
      if (tmp___36) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 972,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"futex(op)",
                                            (PtrdiffT )here___17,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___18 = layout->o_arg3;
      tmp___37 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___37) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 972,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      tmp___38 = __builtin_expect((long )(! (! (here___18 >= 0))), 1L);
      if (tmp___38) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 972,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"futex(val)",
                                            (PtrdiffT )here___18,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___19 = layout->o_arg4;
      tmp___39 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___39) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 972,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      tmp___40 = __builtin_expect((long )(! (! (here___19 >= 0))), 1L);
      if (tmp___40) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 972,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"futex(dummy)",
                                            (PtrdiffT )here___19,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___20 = layout->o_arg5;
      tmp___41 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___41) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 972,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      tmp___42 = __builtin_expect((long )(! (! (here___20 >= 0))), 1L);
      if (tmp___42) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 972,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"futex(dummy2)",
                                            (PtrdiffT )here___20,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___21 = layout->o_arg6;
      tmp___43 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___43) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 972,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      tmp___44 = __builtin_expect((long )(! (! (here___21 >= 0))), 1L);
      if (tmp___44) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 972,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"futex(val3)",
                                            (PtrdiffT )here___21,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  break;
  case 6UL: 
  case 0UL: 
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___22 = layout->o_arg1;
      tmp___45 = __builtin_expect((long )(! (! (sizeof(vki_u32 *) <= sizeof(UWord )))),
                                  1L);
      if (tmp___45) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_u32 *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 978,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      tmp___46 = __builtin_expect((long )(! (! (here___22 >= 0))), 1L);
      if (tmp___46) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 978,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"futex(futex)",
                                            (PtrdiffT )here___22,
                                            (SizeT )sizeof(vki_u32 *));
      break;
    }
    while (1) {
      here___23 = layout->o_arg2;
      tmp___47 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___47) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 978,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      tmp___48 = __builtin_expect((long )(! (! (here___23 >= 0))), 1L);
      if (tmp___48) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 978,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"futex(op)",
                                            (PtrdiffT )here___23,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___24 = layout->o_arg3;
      tmp___49 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___49) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 978,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      tmp___50 = __builtin_expect((long )(! (! (here___24 >= 0))), 1L);
      if (tmp___50) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 978,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"futex(val)",
                                            (PtrdiffT )here___24,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___25 = layout->o_arg4;
      tmp___51 = __builtin_expect((long )(! (! (sizeof(struct timespec *) <= sizeof(UWord )))),
                                  1L);
      if (tmp___51) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct timespec *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 978,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      tmp___52 = __builtin_expect((long )(! (! (here___25 >= 0))), 1L);
      if (tmp___52) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 978,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"futex(utime)",
                                            (PtrdiffT )here___25,
                                            (SizeT )sizeof(struct timespec *));
      break;
    }
  } else {

  }
  break;
  case 8UL: 
  case 2UL: 
  case 1UL: 
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___26 = layout->o_arg1;
      tmp___53 = __builtin_expect((long )(! (! (sizeof(vki_u32 *) <= sizeof(UWord )))),
                                  1L);
      if (tmp___53) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_u32 *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 984,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      tmp___54 = __builtin_expect((long )(! (! (here___26 >= 0))), 1L);
      if (tmp___54) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 984,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"futex(futex)",
                                            (PtrdiffT )here___26,
                                            (SizeT )sizeof(vki_u32 *));
      break;
    }
    while (1) {
      here___27 = layout->o_arg2;
      tmp___55 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___55) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 984,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      tmp___56 = __builtin_expect((long )(! (! (here___27 >= 0))), 1L);
      if (tmp___56) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 984,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"futex(op)",
                                            (PtrdiffT )here___27,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___28 = layout->o_arg3;
      tmp___57 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___57) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 984,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      tmp___58 = __builtin_expect((long )(! (! (here___28 >= 0))), 1L);
      if (tmp___58) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 984,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"futex(val)",
                                            (PtrdiffT )here___28,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  break;
  default: 
  case 7UL: 
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___29 = layout->o_arg1;
      tmp___59 = __builtin_expect((long )(! (! (sizeof(vki_u32 *) <= sizeof(UWord )))),
                                  1L);
      if (tmp___59) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_u32 *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 988,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      tmp___60 = __builtin_expect((long )(! (! (here___29 >= 0))), 1L);
      if (tmp___60) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 988,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"futex(futex)",
                                            (PtrdiffT )here___29,
                                            (SizeT )sizeof(vki_u32 *));
      break;
    }
    while (1) {
      here___30 = layout->o_arg2;
      tmp___61 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___61) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 988,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      tmp___62 = __builtin_expect((long )(! (! (here___30 >= 0))), 1L);
      if (tmp___62) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 988,
                            (Char const   *)"vgSysWrap_linux_sys_futex_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"futex(op)",
                                            (PtrdiffT )here___30,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  break;
  }
  *flags |= (unsigned long )(1 << 1);
  switch (arrghs->arg2 & 4294966911UL) {
  case 11UL: 
  case 9UL: 
  case 6UL: 
  case 0UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"futex(futex)",
                                            arrghs->arg1, (SizeT )sizeof(Int ));
    } else {

    }
    break;
  }
  if (arrghs->arg4 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"futex(timeout)",
                                              arrghs->arg4,
                                              (SizeT )sizeof(struct vki_timespec ));
      } else {

      }
      break;
    }
  } else {

  }
  break;
  case 5UL: 
  case 12UL: 
  case 4UL: 
  case 3UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"futex(futex)",
                                            arrghs->arg1, (SizeT )sizeof(Int ));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"futex(futex2)",
                                            arrghs->arg5, (SizeT )sizeof(Int ));
    } else {

    }
    break;
  }
  break;
  case 7UL: 
  case 8UL: 
  case 2UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"futex(futex)",
                                            arrghs->arg1, (SizeT )sizeof(Int ));
    } else {

    }
    break;
  }
  break;
  case 10UL: 
  case 1UL: 
  break;
  default: 
  while (1) {
    wzz = (Word )38;
    if (wzz >= 0L) {
      if (wzz < 10000L) {
        tmp___63 = 1;
      } else {
        tmp___63 = 0;
      }
    } else {
      tmp___63 = 0;
    }
    tmp___64 = __builtin_expect((long )tmp___63, 1L);
    if (tmp___64) {

    } else {
      vgPlain_assert_fail((Bool )1, (Char const   *)"wzz >= 0 && wzz < 10000",
                          (Char const   *)"m_syswrap/syswrap-linux.c", 1024,
                          (Char const   *)"vgSysWrap_linux_sys_futex_before", "");
    }
    status->what = (enum __anonenum_what_129 )1;
    status->sres = vgPlain_mk_SysRes_Error((UWord )wzz);
    break;
  }
  break;
  }
  return;
}
}
void vgSysWrap_linux_sys_futex_after(ThreadId tid , SyscallArgs *arrghs ,
                                     SyscallStatus *status ) 
{ 
  Bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  UWord tmp___2 ;
  Word wzz ;
  int tmp___3 ;
  long tmp___4 ;
  UWord tmp___5 ;
  UWord tmp___6 ;
  Bool tmp___7 ;

  {
  if ((unsigned int )status->what == 1U) {
    tmp = sr_isError(status->sres);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
  } else {
    tmp___0 = 0;
  }
  tmp___1 = __builtin_expect((long )tmp___0, 1L);
  if (tmp___1) {

  } else {
    vgPlain_assert_fail((Bool )1, (Char const   *)"SUCCESS",
                        (Char const   *)"m_syswrap/syswrap-linux.c", 1030,
                        (Char const   *)"vgSysWrap_linux_sys_futex_after", "");
  }
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg1,
                                              (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  if (arrghs->arg2 == 2UL) {
    tmp___6 = getRES(status);
    tmp___7 = vgModuleLocal_fd_allowed((Int )tmp___6, (Char const   *)"futex",
                                       tid, (Bool )1);
    if (tmp___7) {
      if (vgPlain_clo_track_fds) {
        tmp___5 = getRES(status);
        vgModuleLocal_record_fd_open_nameless(tid, (Int )tmp___5);
      } else {

      }
    } else {
      tmp___2 = getRES(status);
      vgPlain_close((Int )tmp___2);
      while (1) {
        wzz = (Word )24;
        if (wzz >= 0L) {
          if (wzz < 10000L) {
            tmp___3 = 1;
          } else {
            tmp___3 = 0;
          }
        } else {
          tmp___3 = 0;
        }
        tmp___4 = __builtin_expect((long )tmp___3, 1L);
        if (tmp___4) {

        } else {
          vgPlain_assert_fail((Bool )1,
                              (Char const   *)"wzz >= 0 && wzz < 10000",
                              (Char const   *)"m_syswrap/syswrap-linux.c", 1035,
                              (Char const   *)"vgSysWrap_linux_sys_futex_after",
                              "");
        }
        status->what = (enum __anonenum_what_129 )1;
        status->sres = vgPlain_mk_SysRes_Error((UWord )wzz);
        break;
      }
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_set_robust_list_before(ThreadId tid ,
                                                SyscallArgLayout *layout ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ,
                                                UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_set_robust_list ( %#lx, %ld )", arrghs->arg1,
                   arrghs->arg2);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(struct vki_robust_list_head *) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct vki_robust_list_head *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1047,
                            (Char const   *)"vgSysWrap_linux_sys_set_robust_list_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1047,
                            (Char const   *)"vgSysWrap_linux_sys_set_robust_list_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"set_robust_list(head)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(struct vki_robust_list_head *));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(vki_size_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_size_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1047,
                            (Char const   *)"vgSysWrap_linux_sys_set_robust_list_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1047,
                            (Char const   *)"vgSysWrap_linux_sys_set_robust_list_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"set_robust_list(len)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(vki_size_t ));
      break;
    }
  } else {

  }
  if (arrghs->arg1 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"set_robust_list(head)",
                                              arrghs->arg1, arrghs->arg2);
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_get_robust_list_before(ThreadId tid ,
                                                SyscallArgLayout *layout ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ,
                                                UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_get_robust_list ( %ld, %#lx, %ld )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1062,
                            (Char const   *)"vgSysWrap_linux_sys_get_robust_list_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1062,
                            (Char const   *)"vgSysWrap_linux_sys_get_robust_list_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"get_robust_list(pid)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(struct vki_robust_list_head **) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct vki_robust_list_head **) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1062,
                            (Char const   *)"vgSysWrap_linux_sys_get_robust_list_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1062,
                            (Char const   *)"vgSysWrap_linux_sys_get_robust_list_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"get_robust_list(head_ptr)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(struct vki_robust_list_head **));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(vki_size_t *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_size_t *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1062,
                            (Char const   *)"vgSysWrap_linux_sys_get_robust_list_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1062,
                            (Char const   *)"vgSysWrap_linux_sys_get_robust_list_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"get_robust_list(len_ptr)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(vki_size_t *));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"get_robust_list(head_ptr)",
                                             arrghs->arg2,
                                             (SizeT )sizeof(struct vki_robust_list_head *));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"get_robust_list(len_ptr)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(struct vki_size_t *));
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_get_robust_list_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) 
{ 


  {
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg2,
                                              (SizeT )sizeof(struct vki_robust_list_head *));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(struct vki_size_t *));
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_pselect6_before(ThreadId tid ,
                                         SyscallArgLayout *layout ,
                                         SyscallArgs *arrghs ,
                                         SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;
  Int here___3 ;
  long tmp___7 ;
  long tmp___8 ;
  Int here___4 ;
  long tmp___9 ;
  long tmp___10 ;

  {
  *flags |= (unsigned long )(1 << 1);
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_pselect6 ( %ld, %#lx, %#lx, %#lx, %#lx, %#lx )",
                   arrghs->arg1, arrghs->arg2, arrghs->arg3, arrghs->arg4,
                   arrghs->arg5, arrghs->arg6);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1081,
                            (Char const   *)"vgSysWrap_linux_sys_pselect6_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1081,
                            (Char const   *)"vgSysWrap_linux_sys_pselect6_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"pselect6(n)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(vki_fd_set *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_fd_set *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1081,
                            (Char const   *)"vgSysWrap_linux_sys_pselect6_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1081,
                            (Char const   *)"vgSysWrap_linux_sys_pselect6_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"pselect6(readfds)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(vki_fd_set *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(vki_fd_set *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_fd_set *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1081,
                            (Char const   *)"vgSysWrap_linux_sys_pselect6_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1081,
                            (Char const   *)"vgSysWrap_linux_sys_pselect6_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"pselect6(writefds)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(vki_fd_set *));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(vki_fd_set *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_fd_set *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1081,
                            (Char const   *)"vgSysWrap_linux_sys_pselect6_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1081,
                            (Char const   *)"vgSysWrap_linux_sys_pselect6_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"pselect6(exceptfds)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(vki_fd_set *));
      break;
    }
    while (1) {
      here___3 = layout->o_arg5;
      tmp___7 = __builtin_expect((long )(! (! (sizeof(struct vki_timeval *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___7) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct vki_timeval *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1081,
                            (Char const   *)"vgSysWrap_linux_sys_pselect6_before",
                            "");
      }
      tmp___8 = __builtin_expect((long )(! (! (here___3 >= 0))), 1L);
      if (tmp___8) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1081,
                            (Char const   *)"vgSysWrap_linux_sys_pselect6_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"pselect6(timeout)",
                                            (PtrdiffT )here___3,
                                            (SizeT )sizeof(struct vki_timeval *));
      break;
    }
    while (1) {
      here___4 = layout->o_arg6;
      tmp___9 = __builtin_expect((long )(! (! (sizeof(void *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___9) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(void *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1081,
                            (Char const   *)"vgSysWrap_linux_sys_pselect6_before",
                            "");
      }
      tmp___10 = __builtin_expect((long )(! (! (here___4 >= 0))), 1L);
      if (tmp___10) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1081,
                            (Char const   *)"vgSysWrap_linux_sys_pselect6_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"pselect6(sig)",
                                            (PtrdiffT )here___4,
                                            (SizeT )sizeof(void *));
      break;
    }
  } else {

  }
  if (arrghs->arg2 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"pselect6(readfds)",
                                              arrghs->arg2, arrghs->arg1 / 8UL);
      } else {

      }
      break;
    }
  } else {

  }
  if (arrghs->arg3 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"pselect6(writefds)",
                                              arrghs->arg3, arrghs->arg1 / 8UL);
      } else {

      }
      break;
    }
  } else {

  }
  if (arrghs->arg4 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"pselect6(exceptfds)",
                                              arrghs->arg4, arrghs->arg1 / 8UL);
      } else {

      }
      break;
    }
  } else {

  }
  if (arrghs->arg5 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"pselect6(timeout)",
                                              arrghs->arg5,
                                              (SizeT )sizeof(struct vki_timeval ));
      } else {

      }
      break;
    }
  } else {

  }
  if (arrghs->arg6 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"pselect6(sig)",
                                              arrghs->arg6,
                                              (SizeT )(sizeof(void *) + sizeof(vki_size_t )));
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_ppoll_before(ThreadId tid , SyscallArgLayout *layout ,
                                      SyscallArgs *arrghs ,
                                      SyscallStatus *status , UWord *flags ) 
{ 
  UInt i ;
  struct vki_pollfd *ufds ;
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;
  Int here___3 ;
  long tmp___7 ;
  long tmp___8 ;

  {
  ufds = (struct vki_pollfd *)arrghs->arg1;
  *flags |= (unsigned long )(1 << 1);
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_ppoll ( %#lx, %ld, %#lx, %#lx, %llu )\n", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3, arrghs->arg4,
                   (ULong )arrghs->arg5);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(struct vki_pollfd *) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct vki_pollfd *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1107,
                            (Char const   *)"vgSysWrap_linux_sys_ppoll_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1107,
                            (Char const   *)"vgSysWrap_linux_sys_ppoll_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"ppoll(ufds)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(struct vki_pollfd *));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1107,
                            (Char const   *)"vgSysWrap_linux_sys_ppoll_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1107,
                            (Char const   *)"vgSysWrap_linux_sys_ppoll_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"ppoll(nfds)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(struct vki_timespec *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct vki_timespec *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1107,
                            (Char const   *)"vgSysWrap_linux_sys_ppoll_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1107,
                            (Char const   *)"vgSysWrap_linux_sys_ppoll_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"ppoll(tsp)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(struct vki_timespec *));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(vki_sigset_t *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_sigset_t *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1107,
                            (Char const   *)"vgSysWrap_linux_sys_ppoll_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1107,
                            (Char const   *)"vgSysWrap_linux_sys_ppoll_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"ppoll(sigmask)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(vki_sigset_t *));
      break;
    }
    while (1) {
      here___3 = layout->o_arg5;
      tmp___7 = __builtin_expect((long )(! (! (sizeof(vki_size_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___7) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_size_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1107,
                            (Char const   *)"vgSysWrap_linux_sys_ppoll_before",
                            "");
      }
      tmp___8 = __builtin_expect((long )(! (! (here___3 >= 0))), 1L);
      if (tmp___8) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1107,
                            (Char const   *)"vgSysWrap_linux_sys_ppoll_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"ppoll(sigsetsize)",
                                            (PtrdiffT )here___3,
                                            (SizeT )sizeof(vki_size_t ));
      break;
    }
  } else {

  }
  i = (UInt )0;
  while ((UWord )i < arrghs->arg2) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"ppoll(ufds.fd)",
                                              (Addr )(& (ufds + i)->fd),
                                              (SizeT )sizeof((ufds + i)->fd));
      } else {

      }
      break;
    }
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"ppoll(ufds.events)",
                                              (Addr )(& (ufds + i)->events),
                                              (SizeT )sizeof((ufds + i)->events));
      } else {

      }
      break;
    }
    while (1) {
      if (vgPlain_tdict.track_pre_mem_write) {
        (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                               (Char *)"ppoll(ufd.reventss)",
                                               (Addr )(& (ufds + i)->revents),
                                               (SizeT )sizeof((ufds + i)->revents));
      } else {

      }
      break;
    }
    i ++;
  }
  if (arrghs->arg3) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"ppoll(tsp)",
                                              arrghs->arg3,
                                              (SizeT )sizeof(struct vki_timespec ));
      } else {

      }
      break;
    }
  } else {

  }
  if (arrghs->arg4) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"ppoll(sigmask)",
                                              arrghs->arg4,
                                              (SizeT )sizeof(vki_sigset_t ));
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_ppoll_after(ThreadId tid , SyscallArgs *arrghs ,
                                     SyscallStatus *status ) 
{ 
  UInt i ;
  struct vki_pollfd *ufds ;
  UWord tmp ;

  {
  tmp = getRES(status);
  if (tmp > 0UL) {
    ufds = (struct vki_pollfd *)arrghs->arg1;
    i = (UInt )0;
    while ((UWord )i < arrghs->arg2) {
      while (1) {
        if (vgPlain_tdict.track_post_mem_write) {
          (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                  (Addr )(& (ufds + i)->revents),
                                                  (SizeT )sizeof((ufds + i)->revents));
        } else {

        }
        break;
      }
      i ++;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_epoll_create_before(ThreadId tid ,
                                             SyscallArgLayout *layout ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ,
                                             UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_epoll_create ( %ld )", arrghs->arg1);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1142,
                            (Char const   *)"vgSysWrap_linux_sys_epoll_create_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1142,
                            (Char const   *)"vgSysWrap_linux_sys_epoll_create_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"epoll_create(size)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_epoll_create_after(ThreadId tid , SyscallArgs *arrghs ,
                                            SyscallStatus *status ) 
{ 
  Bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  UWord tmp___2 ;
  Word wzz ;
  int tmp___3 ;
  long tmp___4 ;
  UWord tmp___5 ;
  UWord tmp___6 ;
  Bool tmp___7 ;

  {
  if ((unsigned int )status->what == 1U) {
    tmp = sr_isError(status->sres);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
  } else {
    tmp___0 = 0;
  }
  tmp___1 = __builtin_expect((long )tmp___0, 1L);
  if (tmp___1) {

  } else {
    vgPlain_assert_fail((Bool )1, (Char const   *)"SUCCESS",
                        (Char const   *)"m_syswrap/syswrap-linux.c", 1146,
                        (Char const   *)"vgSysWrap_linux_sys_epoll_create_after",
                        "");
  }
  tmp___6 = getRES(status);
  tmp___7 = vgModuleLocal_fd_allowed((Int )tmp___6,
                                     (Char const   *)"epoll_create", tid,
                                     (Bool )1);
  if (tmp___7) {
    if (vgPlain_clo_track_fds) {
      tmp___5 = getRES(status);
      vgModuleLocal_record_fd_open_nameless(tid, (Int )tmp___5);
    } else {

    }
  } else {
    tmp___2 = getRES(status);
    vgPlain_close((Int )tmp___2);
    while (1) {
      wzz = (Word )24;
      if (wzz >= 0L) {
        if (wzz < 10000L) {
          tmp___3 = 1;
        } else {
          tmp___3 = 0;
        }
      } else {
        tmp___3 = 0;
      }
      tmp___4 = __builtin_expect((long )tmp___3, 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"wzz >= 0 && wzz < 10000",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1149,
                            (Char const   *)"vgSysWrap_linux_sys_epoll_create_after",
                            "");
      }
      status->what = (enum __anonenum_what_129 )1;
      status->sres = vgPlain_mk_SysRes_Error((UWord )wzz);
      break;
    }
  }
  return;
}
}
void vgSysWrap_linux_sys_epoll_create1_before(ThreadId tid ,
                                              SyscallArgLayout *layout ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ,
                                              UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_epoll_create1 ( %ld )", arrghs->arg1);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1159,
                            (Char const   *)"vgSysWrap_linux_sys_epoll_create1_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1159,
                            (Char const   *)"vgSysWrap_linux_sys_epoll_create1_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"epoll_create1(flags)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_epoll_create1_after(ThreadId tid ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ) 
{ 
  Bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  UWord tmp___2 ;
  Word wzz ;
  int tmp___3 ;
  long tmp___4 ;
  UWord tmp___5 ;
  UWord tmp___6 ;
  Bool tmp___7 ;

  {
  if ((unsigned int )status->what == 1U) {
    tmp = sr_isError(status->sres);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
  } else {
    tmp___0 = 0;
  }
  tmp___1 = __builtin_expect((long )tmp___0, 1L);
  if (tmp___1) {

  } else {
    vgPlain_assert_fail((Bool )1, (Char const   *)"SUCCESS",
                        (Char const   *)"m_syswrap/syswrap-linux.c", 1163,
                        (Char const   *)"vgSysWrap_linux_sys_epoll_create1_after",
                        "");
  }
  tmp___6 = getRES(status);
  tmp___7 = vgModuleLocal_fd_allowed((Int )tmp___6,
                                     (Char const   *)"epoll_create1", tid,
                                     (Bool )1);
  if (tmp___7) {
    if (vgPlain_clo_track_fds) {
      tmp___5 = getRES(status);
      vgModuleLocal_record_fd_open_nameless(tid, (Int )tmp___5);
    } else {

    }
  } else {
    tmp___2 = getRES(status);
    vgPlain_close((Int )tmp___2);
    while (1) {
      wzz = (Word )24;
      if (wzz >= 0L) {
        if (wzz < 10000L) {
          tmp___3 = 1;
        } else {
          tmp___3 = 0;
        }
      } else {
        tmp___3 = 0;
      }
      tmp___4 = __builtin_expect((long )tmp___3, 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"wzz >= 0 && wzz < 10000",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1166,
                            (Char const   *)"vgSysWrap_linux_sys_epoll_create1_after",
                            "");
      }
      status->what = (enum __anonenum_what_129 )1;
      status->sres = vgPlain_mk_SysRes_Error((UWord )wzz);
      break;
    }
  }
  return;
}
}
void vgSysWrap_linux_sys_epoll_ctl_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) ;
static HChar const   *epoll_ctl_s[3]  = {      "EPOLL_CTL_ADD",      "EPOLL_CTL_DEL",      "EPOLL_CTL_MOD"};
void vgSysWrap_linux_sys_epoll_ctl_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) 
{ 
  HChar const   *tmp ;
  Int here ;
  long tmp___0 ;
  long tmp___1 ;
  Int here___0 ;
  long tmp___2 ;
  long tmp___3 ;
  Int here___1 ;
  long tmp___4 ;
  long tmp___5 ;
  Int here___2 ;
  long tmp___6 ;
  long tmp___7 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    if (arrghs->arg2 < 3UL) {
      tmp = epoll_ctl_s[arrghs->arg2];
    } else {
      tmp = "?";
    }
    vgPlain_printf("sys_epoll_ctl ( %ld, %s, %ld, %#lx )", arrghs->arg1, tmp,
                   arrghs->arg3, arrghs->arg4);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp___0 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1183,
                            (Char const   *)"vgSysWrap_linux_sys_epoll_ctl_before",
                            "");
      }
      tmp___1 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1183,
                            (Char const   *)"vgSysWrap_linux_sys_epoll_ctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"epoll_ctl(epfd)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___2 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1183,
                            (Char const   *)"vgSysWrap_linux_sys_epoll_ctl_before",
                            "");
      }
      tmp___3 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1183,
                            (Char const   *)"vgSysWrap_linux_sys_epoll_ctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"epoll_ctl(op)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___4 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1183,
                            (Char const   *)"vgSysWrap_linux_sys_epoll_ctl_before",
                            "");
      }
      tmp___5 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1183,
                            (Char const   *)"vgSysWrap_linux_sys_epoll_ctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"epoll_ctl(fd)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___6 = __builtin_expect((long )(! (! (sizeof(struct vki_epoll_event *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct vki_epoll_event *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1183,
                            (Char const   *)"vgSysWrap_linux_sys_epoll_ctl_before",
                            "");
      }
      tmp___7 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___7) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1183,
                            (Char const   *)"vgSysWrap_linux_sys_epoll_ctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"epoll_ctl(event)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(struct vki_epoll_event *));
      break;
    }
  } else {

  }
  if (arrghs->arg2 != 2UL) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"epoll_ctl(event)",
                                              arrghs->arg4,
                                              (SizeT )sizeof(struct vki_epoll_event ));
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_epoll_wait_before(ThreadId tid ,
                                           SyscallArgLayout *layout ,
                                           SyscallArgs *arrghs ,
                                           SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;

  {
  *flags |= (unsigned long )(1 << 1);
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_epoll_wait ( %ld, %#lx, %ld, %ld )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3, arrghs->arg4);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1194,
                            (Char const   *)"vgSysWrap_linux_sys_epoll_wait_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1194,
                            (Char const   *)"vgSysWrap_linux_sys_epoll_wait_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"epoll_wait(epfd)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(struct vki_epoll_event *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct vki_epoll_event *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1194,
                            (Char const   *)"vgSysWrap_linux_sys_epoll_wait_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1194,
                            (Char const   *)"vgSysWrap_linux_sys_epoll_wait_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"epoll_wait(events)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(struct vki_epoll_event *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1194,
                            (Char const   *)"vgSysWrap_linux_sys_epoll_wait_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1194,
                            (Char const   *)"vgSysWrap_linux_sys_epoll_wait_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"epoll_wait(maxevents)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1194,
                            (Char const   *)"vgSysWrap_linux_sys_epoll_wait_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1194,
                            (Char const   *)"vgSysWrap_linux_sys_epoll_wait_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"epoll_wait(timeout)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"epoll_wait(events)",
                                             arrghs->arg2,
                                             (UWord )sizeof(struct vki_epoll_event ) * arrghs->arg3);
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_epoll_wait_after(ThreadId tid , SyscallArgs *arrghs ,
                                          SyscallStatus *status ) 
{ 
  Bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  UWord tmp___2 ;
  UWord tmp___3 ;

  {
  if ((unsigned int )status->what == 1U) {
    tmp = sr_isError(status->sres);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
  } else {
    tmp___0 = 0;
  }
  tmp___1 = __builtin_expect((long )tmp___0, 1L);
  if (tmp___1) {

  } else {
    vgPlain_assert_fail((Bool )1, (Char const   *)"SUCCESS",
                        (Char const   *)"m_syswrap/syswrap-linux.c", 1199,
                        (Char const   *)"vgSysWrap_linux_sys_epoll_wait_after",
                        "");
  }
  tmp___3 = getRES(status);
  if (tmp___3 > 0UL) {
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        tmp___2 = getRES(status);
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg2,
                                                (UWord )sizeof(struct vki_epoll_event ) * tmp___2);
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_epoll_pwait_before(ThreadId tid ,
                                            SyscallArgLayout *layout ,
                                            SyscallArgs *arrghs ,
                                            SyscallStatus *status ,
                                            UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;
  Int here___3 ;
  long tmp___7 ;
  long tmp___8 ;
  Int here___4 ;
  long tmp___9 ;
  long tmp___10 ;

  {
  *flags |= (unsigned long )(1 << 1);
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_epoll_pwait ( %ld, %#lx, %ld, %ld, %#lx, %llu )",
                   arrghs->arg1, arrghs->arg2, arrghs->arg3, arrghs->arg4,
                   arrghs->arg5, (ULong )arrghs->arg6);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1211,
                            (Char const   *)"vgSysWrap_linux_sys_epoll_pwait_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1211,
                            (Char const   *)"vgSysWrap_linux_sys_epoll_pwait_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"epoll_pwait(epfd)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(struct vki_epoll_event *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct vki_epoll_event *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1211,
                            (Char const   *)"vgSysWrap_linux_sys_epoll_pwait_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1211,
                            (Char const   *)"vgSysWrap_linux_sys_epoll_pwait_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"epoll_pwait(events)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(struct vki_epoll_event *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1211,
                            (Char const   *)"vgSysWrap_linux_sys_epoll_pwait_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1211,
                            (Char const   *)"vgSysWrap_linux_sys_epoll_pwait_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"epoll_pwait(maxevents)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1211,
                            (Char const   *)"vgSysWrap_linux_sys_epoll_pwait_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1211,
                            (Char const   *)"vgSysWrap_linux_sys_epoll_pwait_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"epoll_pwait(timeout)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___3 = layout->o_arg5;
      tmp___7 = __builtin_expect((long )(! (! (sizeof(vki_sigset_t *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___7) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_sigset_t *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1211,
                            (Char const   *)"vgSysWrap_linux_sys_epoll_pwait_before",
                            "");
      }
      tmp___8 = __builtin_expect((long )(! (! (here___3 >= 0))), 1L);
      if (tmp___8) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1211,
                            (Char const   *)"vgSysWrap_linux_sys_epoll_pwait_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"epoll_pwait(sigmask)",
                                            (PtrdiffT )here___3,
                                            (SizeT )sizeof(vki_sigset_t *));
      break;
    }
    while (1) {
      here___4 = layout->o_arg6;
      tmp___9 = __builtin_expect((long )(! (! (sizeof(vki_size_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___9) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_size_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1211,
                            (Char const   *)"vgSysWrap_linux_sys_epoll_pwait_before",
                            "");
      }
      tmp___10 = __builtin_expect((long )(! (! (here___4 >= 0))), 1L);
      if (tmp___10) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1211,
                            (Char const   *)"vgSysWrap_linux_sys_epoll_pwait_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"epoll_pwait(sigsetsize)",
                                            (PtrdiffT )here___4,
                                            (SizeT )sizeof(vki_size_t ));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"epoll_pwait(events)",
                                             arrghs->arg2,
                                             (UWord )sizeof(struct vki_epoll_event ) * arrghs->arg3);
    } else {

    }
    break;
  }
  if (arrghs->arg4) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"epoll_pwait(sigmask)",
                                              arrghs->arg5,
                                              (SizeT )sizeof(vki_sigset_t ));
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_epoll_pwait_after(ThreadId tid , SyscallArgs *arrghs ,
                                           SyscallStatus *status ) 
{ 
  Bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  UWord tmp___2 ;
  UWord tmp___3 ;

  {
  if ((unsigned int )status->what == 1U) {
    tmp = sr_isError(status->sres);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
  } else {
    tmp___0 = 0;
  }
  tmp___1 = __builtin_expect((long )tmp___0, 1L);
  if (tmp___1) {

  } else {
    vgPlain_assert_fail((Bool )1, (Char const   *)"SUCCESS",
                        (Char const   *)"m_syswrap/syswrap-linux.c", 1218,
                        (Char const   *)"vgSysWrap_linux_sys_epoll_pwait_after",
                        "");
  }
  tmp___3 = getRES(status);
  if (tmp___3 > 0UL) {
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        tmp___2 = getRES(status);
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg2,
                                                (UWord )sizeof(struct vki_epoll_event ) * tmp___2);
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_eventfd_before(ThreadId tid ,
                                        SyscallArgLayout *layout ,
                                        SyscallArgs *arrghs ,
                                        SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_eventfd ( %lu )", arrghs->arg1);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1226,
                            (Char const   *)"vgSysWrap_linux_sys_eventfd_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1226,
                            (Char const   *)"vgSysWrap_linux_sys_eventfd_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sys_eventfd(count)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_eventfd_after(ThreadId tid , SyscallArgs *arrghs ,
                                       SyscallStatus *status ) 
{ 
  UWord tmp ;
  Word wzz ;
  int tmp___0 ;
  long tmp___1 ;
  UWord tmp___2 ;
  UWord tmp___3 ;
  Bool tmp___4 ;

  {
  tmp___3 = getRES(status);
  tmp___4 = vgModuleLocal_fd_allowed((Int )tmp___3, (Char const   *)"eventfd",
                                     tid, (Bool )1);
  if (tmp___4) {
    if (vgPlain_clo_track_fds) {
      tmp___2 = getRES(status);
      vgModuleLocal_record_fd_open_nameless(tid, (Int )tmp___2);
    } else {

    }
  } else {
    tmp = getRES(status);
    vgPlain_close((Int )tmp);
    while (1) {
      wzz = (Word )24;
      if (wzz >= 0L) {
        if (wzz < 10000L) {
          tmp___0 = 1;
        } else {
          tmp___0 = 0;
        }
      } else {
        tmp___0 = 0;
      }
      tmp___1 = __builtin_expect((long )tmp___0, 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"wzz >= 0 && wzz < 10000",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1232,
                            (Char const   *)"vgSysWrap_linux_sys_eventfd_after",
                            "");
      }
      status->what = (enum __anonenum_what_129 )1;
      status->sres = vgPlain_mk_SysRes_Error((UWord )wzz);
      break;
    }
  }
  return;
}
}
void vgSysWrap_linux_sys_eventfd2_before(ThreadId tid ,
                                         SyscallArgLayout *layout ,
                                         SyscallArgs *arrghs ,
                                         SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_eventfd2 ( %lu, %ld )", arrghs->arg1, arrghs->arg2);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1242,
                            (Char const   *)"vgSysWrap_linux_sys_eventfd2_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1242,
                            (Char const   *)"vgSysWrap_linux_sys_eventfd2_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sys_eventfd2(count)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1242,
                            (Char const   *)"vgSysWrap_linux_sys_eventfd2_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1242,
                            (Char const   *)"vgSysWrap_linux_sys_eventfd2_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sys_eventfd2(flags)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_eventfd2_after(ThreadId tid , SyscallArgs *arrghs ,
                                        SyscallStatus *status ) 
{ 
  UWord tmp ;
  Word wzz ;
  int tmp___0 ;
  long tmp___1 ;
  UWord tmp___2 ;
  UWord tmp___3 ;
  Bool tmp___4 ;

  {
  tmp___3 = getRES(status);
  tmp___4 = vgModuleLocal_fd_allowed((Int )tmp___3, (Char const   *)"eventfd2",
                                     tid, (Bool )1);
  if (tmp___4) {
    if (vgPlain_clo_track_fds) {
      tmp___2 = getRES(status);
      vgModuleLocal_record_fd_open_nameless(tid, (Int )tmp___2);
    } else {

    }
  } else {
    tmp = getRES(status);
    vgPlain_close((Int )tmp);
    while (1) {
      wzz = (Word )24;
      if (wzz >= 0L) {
        if (wzz < 10000L) {
          tmp___0 = 1;
        } else {
          tmp___0 = 0;
        }
      } else {
        tmp___0 = 0;
      }
      tmp___1 = __builtin_expect((long )tmp___0, 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"wzz >= 0 && wzz < 10000",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1248,
                            (Char const   *)"vgSysWrap_linux_sys_eventfd2_after",
                            "");
      }
      status->what = (enum __anonenum_what_129 )1;
      status->sres = vgPlain_mk_SysRes_Error((UWord )wzz);
      break;
    }
  }
  return;
}
}
void vgSysWrap_linux_sys_fallocate_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;
  Int here___3 ;
  long tmp___7 ;
  long tmp___8 ;
  Int here___4 ;
  long tmp___9 ;
  long tmp___10 ;
  Word wzz ;
  int tmp___11 ;
  long tmp___12 ;
  Bool tmp___13 ;

  {
  *flags |= (unsigned long )(1 << 1);
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_fallocate ( %ld, %ld, %lld, %lld )", arrghs->arg1,
                   arrghs->arg2,
                   (ULong )arrghs->arg3 | ((ULong )arrghs->arg4 << 32),
                   (ULong )arrghs->arg5 | ((ULong )arrghs->arg6 << 32));
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1264,
                            (Char const   *)"vgSysWrap_linux_sys_fallocate_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1264,
                            (Char const   *)"vgSysWrap_linux_sys_fallocate_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fallocate(fd)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1264,
                            (Char const   *)"vgSysWrap_linux_sys_fallocate_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1264,
                            (Char const   *)"vgSysWrap_linux_sys_fallocate_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fallocate(mode)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1264,
                            (Char const   *)"vgSysWrap_linux_sys_fallocate_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1264,
                            (Char const   *)"vgSysWrap_linux_sys_fallocate_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fallocate(offset_low)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1264,
                            (Char const   *)"vgSysWrap_linux_sys_fallocate_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1264,
                            (Char const   *)"vgSysWrap_linux_sys_fallocate_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fallocate(offset_high)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
    while (1) {
      here___3 = layout->o_arg5;
      tmp___7 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___7) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1264,
                            (Char const   *)"vgSysWrap_linux_sys_fallocate_before",
                            "");
      }
      tmp___8 = __builtin_expect((long )(! (! (here___3 >= 0))), 1L);
      if (tmp___8) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1264,
                            (Char const   *)"vgSysWrap_linux_sys_fallocate_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fallocate(len_low)",
                                            (PtrdiffT )here___3,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
    while (1) {
      here___4 = layout->o_arg6;
      tmp___9 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___9) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1264,
                            (Char const   *)"vgSysWrap_linux_sys_fallocate_before",
                            "");
      }
      tmp___10 = __builtin_expect((long )(! (! (here___4 >= 0))), 1L);
      if (tmp___10) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1264,
                            (Char const   *)"vgSysWrap_linux_sys_fallocate_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fallocate(len_high)",
                                            (PtrdiffT )here___4,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
  } else {

  }
  tmp___13 = vgModuleLocal_fd_allowed((Int )arrghs->arg1,
                                      (Char const   *)"fallocate", tid, (Bool )0);
  if (tmp___13) {

  } else {
    while (1) {
      wzz = (Word )9;
      if (wzz >= 0L) {
        if (wzz < 10000L) {
          tmp___11 = 1;
        } else {
          tmp___11 = 0;
        }
      } else {
        tmp___11 = 0;
      }
      tmp___12 = __builtin_expect((long )tmp___11, 1L);
      if (tmp___12) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"wzz >= 0 && wzz < 10000",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1274,
                            (Char const   *)"vgSysWrap_linux_sys_fallocate_before",
                            "");
      }
      status->what = (enum __anonenum_what_129 )1;
      status->sres = vgPlain_mk_SysRes_Error((UWord )wzz);
      break;
    }
  }
  return;
}
}
void vgSysWrap_linux_sys_prlimit64_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_prlimit64 ( %ld, %ld, %#lx, %#lx )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3, arrghs->arg4);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_pid_t ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_pid_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1283,
                            (Char const   *)"vgSysWrap_linux_sys_prlimit64_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1283,
                            (Char const   *)"vgSysWrap_linux_sys_prlimit64_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"prlimit64(pid)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_pid_t ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1283,
                            (Char const   *)"vgSysWrap_linux_sys_prlimit64_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1283,
                            (Char const   *)"vgSysWrap_linux_sys_prlimit64_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"prlimit64(resource)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(struct rlimit64  const  *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const struct rlimit64 *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1283,
                            (Char const   *)"vgSysWrap_linux_sys_prlimit64_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1283,
                            (Char const   *)"vgSysWrap_linux_sys_prlimit64_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"prlimit64(new_rlim)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(struct rlimit64  const  *));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(struct rlimit64 *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct rlimit64 *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1283,
                            (Char const   *)"vgSysWrap_linux_sys_prlimit64_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1283,
                            (Char const   *)"vgSysWrap_linux_sys_prlimit64_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"prlimit64(old_rlim)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(struct rlimit64 *));
      break;
    }
  } else {

  }
  if (arrghs->arg3) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"rlimit64(new_rlim)",
                                              arrghs->arg3,
                                              (SizeT )sizeof(struct vki_rlimit64 ));
      } else {

      }
      break;
    }
  } else {

  }
  if (arrghs->arg4) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_write) {
        (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                               (Char *)"rlimit64(old_rlim)",
                                               arrghs->arg4,
                                               (SizeT )sizeof(struct vki_rlimit64 ));
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_prlimit64_after(ThreadId tid , SyscallArgs *arrghs ,
                                         SyscallStatus *status ) 
{ 


  {
  if (arrghs->arg4) {
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg4,
                                                (SizeT )sizeof(struct vki_rlimit64 ));
      } else {

      }
      break;
    }
    switch (arrghs->arg2) {
    case 7UL: 
    ((struct vki_rlimit64 *)arrghs->arg4)->rlim_cur = (__vki_u64 )vgPlain_fd_soft_limit;
    ((struct vki_rlimit64 *)arrghs->arg4)->rlim_max = (__vki_u64 )vgPlain_fd_hard_limit;
    break;
    case 2UL: 
    ((struct vki_rlimit64 *)arrghs->arg4)->rlim_cur = (__vki_u64 )vgPlain_client_rlimit_data.rlim_cur;
    ((struct vki_rlimit64 *)arrghs->arg4)->rlim_max = (__vki_u64 )vgPlain_client_rlimit_data.rlim_max;
    break;
    case 3UL: 
    ((struct vki_rlimit64 *)arrghs->arg4)->rlim_cur = (__vki_u64 )vgPlain_client_rlimit_stack.rlim_cur;
    ((struct vki_rlimit64 *)arrghs->arg4)->rlim_max = (__vki_u64 )vgPlain_client_rlimit_stack.rlim_max;
    break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_gettid_before(ThreadId tid , SyscallArgLayout *layout ,
                                       SyscallArgs *arrghs ,
                                       SyscallStatus *status , UWord *flags ) 
{ 


  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_gettid ()");
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_set_tid_address_before(ThreadId tid ,
                                                SyscallArgLayout *layout ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ,
                                                UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_set_tid_address ( %#lx )", arrghs->arg1);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int *) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1327,
                            (Char const   *)"vgSysWrap_linux_sys_set_tid_address_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1327,
                            (Char const   *)"vgSysWrap_linux_sys_set_tid_address_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"set_tid_address(tidptr)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int *));
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_tkill_before(ThreadId tid , SyscallArgLayout *layout ,
                                      SyscallArgs *arrghs ,
                                      SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Word wzz ;
  int tmp___3 ;
  long tmp___4 ;
  Bool tmp___5 ;
  Bool tmp___6 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_tgkill ( %ld, %ld )", arrghs->arg1, arrghs->arg2);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1333,
                            (Char const   *)"vgSysWrap_linux_sys_tkill_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1333,
                            (Char const   *)"vgSysWrap_linux_sys_tkill_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"tkill(tid)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1333,
                            (Char const   *)"vgSysWrap_linux_sys_tkill_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1333,
                            (Char const   *)"vgSysWrap_linux_sys_tkill_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"tkill(sig)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  tmp___5 = vgModuleLocal_client_signal_OK((Int )arrghs->arg2);
  if (tmp___5) {

  } else {
    while (1) {
      wzz = (Word )22;
      if (wzz >= 0L) {
        if (wzz < 10000L) {
          tmp___3 = 1;
        } else {
          tmp___3 = 0;
        }
      } else {
        tmp___3 = 0;
      }
      tmp___4 = __builtin_expect((long )tmp___3, 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"wzz >= 0 && wzz < 10000",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1335,
                            (Char const   *)"vgSysWrap_linux_sys_tkill_before",
                            "");
      }
      status->what = (enum __anonenum_what_129 )1;
      status->sres = vgPlain_mk_SysRes_Error((UWord )wzz);
      break;
    }
    return;
  }
  *flags |= (unsigned long )(1 << 3);
  if (vgPlain_clo_trace_signals) {
    vgPlain_message((VgMsgKind )2, "tkill: sending signal %ld to pid %ld\n",
                    arrghs->arg2, arrghs->arg1);
  } else {

  }
  if (arrghs->arg2 == 9UL) {
    tmp___6 = vgModuleLocal_do_sigkill((Int )arrghs->arg1, -1);
    if (tmp___6) {
      while (1) {
        status->what = (enum __anonenum_what_129 )1;
        status->sres = vgPlain_mk_SysRes_Success((UWord )0);
        break;
      }
      return;
    } else {

    }
  } else {

  }
  *flags |= (unsigned long )(1 << 1);
  return;
}
}
void vgSysWrap_linux_sys_tkill_after(ThreadId tid , SyscallArgs *arrghs ,
                                     SyscallStatus *status ) 
{ 


  {
  if (vgPlain_clo_trace_signals) {
    vgPlain_message((VgMsgKind )2, "tkill: sent signal %ld to pid %ld\n",
                    arrghs->arg2, arrghs->arg1);
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_tgkill_before(ThreadId tid , SyscallArgLayout *layout ,
                                       SyscallArgs *arrghs ,
                                       SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Word wzz ;
  int tmp___5 ;
  long tmp___6 ;
  Bool tmp___7 ;
  Bool tmp___8 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_tgkill ( %ld, %ld, %ld )", arrghs->arg1, arrghs->arg2,
                   arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1374,
                            (Char const   *)"vgSysWrap_linux_sys_tgkill_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1374,
                            (Char const   *)"vgSysWrap_linux_sys_tgkill_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"tgkill(tgid)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1374,
                            (Char const   *)"vgSysWrap_linux_sys_tgkill_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1374,
                            (Char const   *)"vgSysWrap_linux_sys_tgkill_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"tgkill(tid)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1374,
                            (Char const   *)"vgSysWrap_linux_sys_tgkill_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1374,
                            (Char const   *)"vgSysWrap_linux_sys_tgkill_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"tgkill(sig)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  tmp___7 = vgModuleLocal_client_signal_OK((Int )arrghs->arg3);
  if (tmp___7) {

  } else {
    while (1) {
      wzz = (Word )22;
      if (wzz >= 0L) {
        if (wzz < 10000L) {
          tmp___5 = 1;
        } else {
          tmp___5 = 0;
        }
      } else {
        tmp___5 = 0;
      }
      tmp___6 = __builtin_expect((long )tmp___5, 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"wzz >= 0 && wzz < 10000",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1376,
                            (Char const   *)"vgSysWrap_linux_sys_tgkill_before",
                            "");
      }
      status->what = (enum __anonenum_what_129 )1;
      status->sres = vgPlain_mk_SysRes_Error((UWord )wzz);
      break;
    }
    return;
  }
  *flags |= (unsigned long )(1 << 3);
  if (vgPlain_clo_trace_signals) {
    vgPlain_message((VgMsgKind )2,
                    "tgkill: sending signal %ld to pid %ld/%ld\n", arrghs->arg3,
                    arrghs->arg1, arrghs->arg2);
  } else {

  }
  if (arrghs->arg3 == 9UL) {
    tmp___8 = vgModuleLocal_do_sigkill((Int )arrghs->arg2, (Int )arrghs->arg1);
    if (tmp___8) {
      while (1) {
        status->what = (enum __anonenum_what_129 )1;
        status->sres = vgPlain_mk_SysRes_Success((UWord )0);
        break;
      }
      return;
    } else {

    }
  } else {

  }
  *flags |= (unsigned long )(1 << 1);
  return;
}
}
void vgSysWrap_linux_sys_tgkill_after(ThreadId tid , SyscallArgs *arrghs ,
                                      SyscallStatus *status ) 
{ 


  {
  if (vgPlain_clo_trace_signals) {
    vgPlain_message((VgMsgKind )2, "tgkill: sent signal %ld to pid %ld/%ld\n",
                    arrghs->arg3, arrghs->arg1, arrghs->arg2);
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_fadvise64_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;
  Int here___3 ;
  long tmp___7 ;
  long tmp___8 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_fadvise64 ( %ld, %lld, %lu, %ld )", arrghs->arg1,
                   (ULong )arrghs->arg2 | ((ULong )arrghs->arg3 << 32),
                   arrghs->arg4, arrghs->arg5);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1424,
                            (Char const   *)"vgSysWrap_linux_sys_fadvise64_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1424,
                            (Char const   *)"vgSysWrap_linux_sys_fadvise64_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fadvise64(fd)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(vki_u32 ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_u32) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1424,
                            (Char const   *)"vgSysWrap_linux_sys_fadvise64_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1424,
                            (Char const   *)"vgSysWrap_linux_sys_fadvise64_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fadvise64(offset_low)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(vki_u32 ));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(vki_u32 ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_u32) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1424,
                            (Char const   *)"vgSysWrap_linux_sys_fadvise64_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1424,
                            (Char const   *)"vgSysWrap_linux_sys_fadvise64_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fadvise64(offset_high)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(vki_u32 ));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(vki_size_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_size_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1424,
                            (Char const   *)"vgSysWrap_linux_sys_fadvise64_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1424,
                            (Char const   *)"vgSysWrap_linux_sys_fadvise64_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fadvise64(len)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(vki_size_t ));
      break;
    }
    while (1) {
      here___3 = layout->o_arg5;
      tmp___7 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___7) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1424,
                            (Char const   *)"vgSysWrap_linux_sys_fadvise64_before",
                            "");
      }
      tmp___8 = __builtin_expect((long )(! (! (here___3 >= 0))), 1L);
      if (tmp___8) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1424,
                            (Char const   *)"vgSysWrap_linux_sys_fadvise64_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fadvise64(advice)",
                                            (PtrdiffT )here___3,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_fadvise64_64_before(ThreadId tid ,
                                             SyscallArgLayout *layout ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ,
                                             UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;
  Int here___3 ;
  long tmp___7 ;
  long tmp___8 ;
  Int here___4 ;
  long tmp___9 ;
  long tmp___10 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_fadvise64_64 ( %ld, %lld, %lld, %ld )", arrghs->arg1,
                   (ULong )arrghs->arg2 | ((ULong )arrghs->arg3 << 32),
                   (ULong )arrghs->arg4 | ((ULong )arrghs->arg5 << 32),
                   arrghs->arg6);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1433,
                            (Char const   *)"vgSysWrap_linux_sys_fadvise64_64_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1433,
                            (Char const   *)"vgSysWrap_linux_sys_fadvise64_64_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fadvise64_64(fd)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(vki_u32 ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_u32) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1433,
                            (Char const   *)"vgSysWrap_linux_sys_fadvise64_64_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1433,
                            (Char const   *)"vgSysWrap_linux_sys_fadvise64_64_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fadvise64_64(offset_low)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(vki_u32 ));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(vki_u32 ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_u32) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1433,
                            (Char const   *)"vgSysWrap_linux_sys_fadvise64_64_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1433,
                            (Char const   *)"vgSysWrap_linux_sys_fadvise64_64_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fadvise64_64(offset_high)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(vki_u32 ));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(vki_u32 ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_u32) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1433,
                            (Char const   *)"vgSysWrap_linux_sys_fadvise64_64_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1433,
                            (Char const   *)"vgSysWrap_linux_sys_fadvise64_64_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fadvise64_64(len_low)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(vki_u32 ));
      break;
    }
    while (1) {
      here___3 = layout->o_arg5;
      tmp___7 = __builtin_expect((long )(! (! (sizeof(vki_u32 ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___7) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_u32) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1433,
                            (Char const   *)"vgSysWrap_linux_sys_fadvise64_64_before",
                            "");
      }
      tmp___8 = __builtin_expect((long )(! (! (here___3 >= 0))), 1L);
      if (tmp___8) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1433,
                            (Char const   *)"vgSysWrap_linux_sys_fadvise64_64_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fadvise64_64(len_high)",
                                            (PtrdiffT )here___3,
                                            (SizeT )sizeof(vki_u32 ));
      break;
    }
    while (1) {
      here___4 = layout->o_arg6;
      tmp___9 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___9) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1433,
                            (Char const   *)"vgSysWrap_linux_sys_fadvise64_64_before",
                            "");
      }
      tmp___10 = __builtin_expect((long )(! (! (here___4 >= 0))), 1L);
      if (tmp___10) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1433,
                            (Char const   *)"vgSysWrap_linux_sys_fadvise64_64_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fadvise64_64(advice)",
                                            (PtrdiffT )here___4,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_io_setup_before(ThreadId tid ,
                                         SyscallArgLayout *layout ,
                                         SyscallArgs *arrghs ,
                                         SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_io_setup ( %lu, %#lx )", arrghs->arg1, arrghs->arg2);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1448,
                            (Char const   *)"vgSysWrap_linux_sys_io_setup_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1448,
                            (Char const   *)"vgSysWrap_linux_sys_io_setup_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"io_setup(nr_events)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(vki_aio_context_t *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_aio_context_t *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1448,
                            (Char const   *)"vgSysWrap_linux_sys_io_setup_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1448,
                            (Char const   *)"vgSysWrap_linux_sys_io_setup_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"io_setup(ctxp)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(vki_aio_context_t *));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"io_setup(ctxp)",
                                             arrghs->arg2,
                                             (SizeT )sizeof(vki_aio_context_t ));
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_io_setup_after(ThreadId tid , SyscallArgs *arrghs ,
                                        SyscallStatus *status ) 
{ 
  SizeT size ;
  struct vki_aio_ring *r ;
  Bool tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  size = ((((UWord )sizeof(struct vki_aio_ring ) + arrghs->arg1 * (UWord )sizeof(struct vki_io_event )) + (1UL << 12)) - 1UL) & ~ ((1UL << 12) - 1UL);
  r = *((struct vki_aio_ring **)arrghs->arg2);
  tmp = vgModuleLocal_valid_client_addr((Addr )r, size, tid,
                                        (Char const   *)"io_setup");
  if (tmp) {
    tmp___0 = 1;
  } else {
    tmp___0 = 0;
  }
  tmp___1 = __builtin_expect((long )tmp___0, 1L);
  if (tmp___1) {

  } else {
    vgPlain_assert_fail((Bool )1,
                        (Char const   *)"ML_(valid_client_addr)((Addr)r, size, tid, \"io_setup\")",
                        (Char const   *)"m_syswrap/syswrap-linux.c", 1460,
                        (Char const   *)"vgSysWrap_linux_sys_io_setup_after", "");
  }
  vgModuleLocal_notify_core_and_tool_of_mmap((Addr )r, size, (UInt )3,
                                             (UInt )32, -1, (Off64T )0);
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg2,
                                              (SizeT )sizeof(vki_aio_context_t ));
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_io_destroy_before(ThreadId tid ,
                                           SyscallArgLayout *layout ,
                                           SyscallArgs *arrghs ,
                                           SyscallStatus *status , UWord *flags ) 
{ 
  SizeT size ;
  Int here ;
  long tmp ;
  long tmp___0 ;
  struct vki_aio_ring *r ;
  Bool tmp___1 ;
  Bool d ;
  Bool tmp___2 ;
  Bool tmp___3 ;
  UWord tmp___4 ;

  {
  size = (SizeT )0;
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_io_destroy ( %llu )", (ULong )arrghs->arg1);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_aio_context_t ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_aio_context_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1482,
                            (Char const   *)"vgSysWrap_linux_sys_io_destroy_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1482,
                            (Char const   *)"vgSysWrap_linux_sys_io_destroy_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"io_destroy(ctx)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_aio_context_t ));
      break;
    }
  } else {

  }
  tmp___1 = vgModuleLocal_safe_to_deref((void *)arrghs->arg1,
                                        (SizeT )sizeof(struct vki_aio_ring ));
  if (tmp___1) {
    r = (struct vki_aio_ring *)arrghs->arg1;
    size = (((unsigned long )(sizeof(struct vki_aio_ring ) + r->nr * sizeof(struct vki_io_event )) + (1UL << 12)) - 1UL) & ~ ((1UL << 12) - 1UL);
  } else {

  }
  while (1) {
    status->what = (enum __anonenum_what_129 )1;
    status->sres = vgPlain_do_syscall((UWord )arrghs->sysno, arrghs->arg1,
                                      (UWord )0, (UWord )0, (UWord )0,
                                      (UWord )0, (UWord )0, (UWord )0, (UWord )0);
    break;
  }
  if ((unsigned int )status->what == 1U) {
    tmp___3 = sr_isError(status->sres);
    if (tmp___3) {

    } else {
      tmp___4 = getRES(status);
      if (tmp___4 == 0UL) {
        tmp___2 = vgPlain_am_notify_munmap(arrghs->arg1, size);
        d = tmp___2;
        while (1) {
          if (vgPlain_tdict.track_die_mem_munmap) {
            (*(vgPlain_tdict.track_die_mem_munmap))(arrghs->arg1, size);
          } else {

          }
          break;
        }
        if (d) {
          vgPlain_discard_translations((Addr64 )arrghs->arg1, (ULong )size,
                                       (HChar *)"PRE(sys_io_destroy)");
        } else {

        }
      } else {

      }
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_io_getevents_before(ThreadId tid ,
                                             SyscallArgLayout *layout ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ,
                                             UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;
  Int here___3 ;
  long tmp___7 ;
  long tmp___8 ;

  {
  *flags |= (unsigned long )(1 << 1);
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_io_getevents ( %llu, %lld, %lld, %#lx, %#lx )",
                   (ULong )arrghs->arg1, (Long )arrghs->arg2,
                   (Long )arrghs->arg3, arrghs->arg4, arrghs->arg5);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_aio_context_t ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_aio_context_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1511,
                            (Char const   *)"vgSysWrap_linux_sys_io_getevents_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1511,
                            (Char const   *)"vgSysWrap_linux_sys_io_getevents_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"io_getevents(ctx_id)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_aio_context_t ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(long ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(long) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1511,
                            (Char const   *)"vgSysWrap_linux_sys_io_getevents_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1511,
                            (Char const   *)"vgSysWrap_linux_sys_io_getevents_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"io_getevents(min_nr)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(long ));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(long ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(long) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1511,
                            (Char const   *)"vgSysWrap_linux_sys_io_getevents_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1511,
                            (Char const   *)"vgSysWrap_linux_sys_io_getevents_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"io_getevents(nr)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(long ));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(struct io_event *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct io_event *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1511,
                            (Char const   *)"vgSysWrap_linux_sys_io_getevents_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1511,
                            (Char const   *)"vgSysWrap_linux_sys_io_getevents_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"io_getevents(events)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(struct io_event *));
      break;
    }
    while (1) {
      here___3 = layout->o_arg5;
      tmp___7 = __builtin_expect((long )(! (! (sizeof(struct timespec *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___7) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct timespec *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1511,
                            (Char const   *)"vgSysWrap_linux_sys_io_getevents_before",
                            "");
      }
      tmp___8 = __builtin_expect((long )(! (! (here___3 >= 0))), 1L);
      if (tmp___8) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1511,
                            (Char const   *)"vgSysWrap_linux_sys_io_getevents_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"io_getevents(timeout)",
                                            (PtrdiffT )here___3,
                                            (SizeT )sizeof(struct timespec *));
      break;
    }
  } else {

  }
  if (arrghs->arg3 > 0UL) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_write) {
        (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                               (Char *)"io_getevents(events)",
                                               arrghs->arg4,
                                               (UWord )sizeof(struct vki_io_event ) * arrghs->arg3);
      } else {

      }
      break;
    }
  } else {

  }
  if (arrghs->arg5 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"io_getevents(timeout)",
                                              arrghs->arg5,
                                              (SizeT )sizeof(struct vki_timespec ));
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_io_getevents_after(ThreadId tid , SyscallArgs *arrghs ,
                                            SyscallStatus *status ) 
{ 
  Int i ;
  Bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  UWord tmp___2 ;
  struct vki_io_event  const  *vev ;
  struct vki_iocb  const  *cb ;
  struct vki_iovec *vec ;
  Int remains ;
  Int j ;
  Int nReadThisBuf ;
  UWord tmp___3 ;
  UWord tmp___4 ;

  {
  if ((unsigned int )status->what == 1U) {
    tmp = sr_isError(status->sres);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
  } else {
    tmp___0 = 0;
  }
  tmp___1 = __builtin_expect((long )tmp___0, 1L);
  if (tmp___1) {

  } else {
    vgPlain_assert_fail((Bool )1, (Char const   *)"SUCCESS",
                        (Char const   *)"m_syswrap/syswrap-linux.c", 1522,
                        (Char const   *)"vgSysWrap_linux_sys_io_getevents_after",
                        "");
  }
  tmp___4 = getRES(status);
  if (tmp___4 > 0UL) {
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        tmp___2 = getRES(status);
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg4,
                                                (UWord )sizeof(struct vki_io_event ) * tmp___2);
      } else {

      }
      break;
    }
    i = 0;
    while (1) {
      tmp___3 = getRES(status);
      if ((UWord )i < tmp___3) {

      } else {
        break;
      }
      vev = (struct vki_io_event  const  *)((struct vki_io_event *)arrghs->arg4 + i);
      cb = (struct vki_iocb  const  *)((struct vki_iocb *)((Addr )vev->obj));
      switch ((int const   )cb->aio_lio_opcode) {
      case 0: 
      if (vev->result > 0LL) {
        while (1) {
          if (vgPlain_tdict.track_post_mem_write) {
            (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                    (Addr )cb->aio_buf,
                                                    (SizeT )vev->result);
          } else {

          }
          break;
        }
      } else {

      }
      break;
      case 1: 
      break;
      case 2: 
      break;
      case 3: 
      break;
      case 7: 
      if (vev->result > 0LL) {
        vec = (struct vki_iovec *)((Addr )cb->aio_buf);
        remains = (Int )vev->result;
        j = 0;
        while ((__vki_u64 const   )j < cb->aio_nbytes) {
          nReadThisBuf = (Int )(vec + j)->iov_len;
          if (nReadThisBuf > remains) {
            nReadThisBuf = remains;
          } else {

          }
          while (1) {
            if (vgPlain_tdict.track_post_mem_write) {
              (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                      (Addr )(vec + j)->iov_base,
                                                      (SizeT )nReadThisBuf);
            } else {

            }
            break;
          }
          remains -= nReadThisBuf;
          if (remains < 0) {
            vgPlain_core_panic((Char *)"io_getevents(PREADV): remains < 0");
          } else {

          }
          j ++;
        }
      } else {

      }
      break;
      case 8: 
      break;
      default: 
      vgPlain_message((VgMsgKind )2,
                      "Warning: unhandled io_getevents opcode: %u\n",
                      (int const   )cb->aio_lio_opcode);
      break;
      }
      i ++;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_io_submit_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) 
{ 
  Int i ;
  Int j ;
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  struct vki_iocb *cb ;
  struct vki_iovec *iov ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_io_submit ( %llu, %ld, %#lx )", (ULong )arrghs->arg1,
                   arrghs->arg2, arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_aio_context_t ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_aio_context_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1580,
                            (Char const   *)"vgSysWrap_linux_sys_io_submit_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1580,
                            (Char const   *)"vgSysWrap_linux_sys_io_submit_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"io_submit(ctx_id)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_aio_context_t ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(long ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(long) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1580,
                            (Char const   *)"vgSysWrap_linux_sys_io_submit_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1580,
                            (Char const   *)"vgSysWrap_linux_sys_io_submit_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"io_submit(nr)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(long ));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(struct iocb **) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct iocb **) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1580,
                            (Char const   *)"vgSysWrap_linux_sys_io_submit_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1580,
                            (Char const   *)"vgSysWrap_linux_sys_io_submit_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"io_submit(iocbpp)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(struct iocb **));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"io_submit(iocbpp)",
                                            arrghs->arg3,
                                            arrghs->arg2 * (UWord )sizeof(struct vki_iocb *));
    } else {

    }
    break;
  }
  if (arrghs->arg3 != 0UL) {
    i = 0;
    while ((UWord )i < arrghs->arg2) {
      cb = *((struct vki_iocb **)arrghs->arg3 + i);
      while (1) {
        if (vgPlain_tdict.track_pre_mem_read) {
          (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                                (Char *)"io_submit(iocb)",
                                                (Addr )cb,
                                                (SizeT )sizeof(struct vki_iocb ));
        } else {

        }
        break;
      }
      switch ((int )cb->aio_lio_opcode) {
      case 0: 
      while (1) {
        if (vgPlain_tdict.track_pre_mem_write) {
          (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                                 (Char *)"io_submit(PREAD)",
                                                 (Addr )cb->aio_buf,
                                                 (SizeT )cb->aio_nbytes);
        } else {

        }
        break;
      }
      break;
      case 1: 
      while (1) {
        if (vgPlain_tdict.track_pre_mem_read) {
          (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                                (Char *)"io_submit(PWRITE)",
                                                (Addr )cb->aio_buf,
                                                (SizeT )cb->aio_nbytes);
        } else {

        }
        break;
      }
      break;
      case 2: 
      break;
      case 3: 
      break;
      case 7: 
      iov = (struct vki_iovec *)((Addr )cb->aio_buf);
      while (1) {
        if (vgPlain_tdict.track_pre_mem_read) {
          (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                                (Char *)"io_submit(PREADV)",
                                                (Addr )cb->aio_buf,
                                                (SizeT )(cb->aio_nbytes * (__vki_u64 )sizeof(struct vki_iovec )));
        } else {

        }
        break;
      }
      j = 0;
      while ((__vki_u64 )j < cb->aio_nbytes) {
        while (1) {
          if (vgPlain_tdict.track_pre_mem_write) {
            (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                                   (Char *)"io_submit(PREADV(iov[i]))",
                                                   (Addr )(iov + j)->iov_base,
                                                   (SizeT )(iov + j)->iov_len);
          } else {

          }
          break;
        }
        j ++;
      }
      break;
      case 8: 
      iov = (struct vki_iovec *)((Addr )cb->aio_buf);
      while (1) {
        if (vgPlain_tdict.track_pre_mem_read) {
          (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                                (Char *)"io_submit(PWRITEV)",
                                                (Addr )cb->aio_buf,
                                                (SizeT )(cb->aio_nbytes * (__vki_u64 )sizeof(struct vki_iovec )));
        } else {

        }
        break;
      }
      j = 0;
      while ((__vki_u64 )j < cb->aio_nbytes) {
        while (1) {
          if (vgPlain_tdict.track_pre_mem_read) {
            (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                                  (Char *)"io_submit(PWRITEV(iov[i]))",
                                                  (Addr )(iov + j)->iov_base,
                                                  (SizeT )(iov + j)->iov_len);
          } else {

          }
          break;
        }
        j ++;
      }
      break;
      default: 
      vgPlain_message((VgMsgKind )2,
                      "Warning: unhandled io_submit opcode: %u\n",
                      (int )cb->aio_lio_opcode);
      break;
      }
      i ++;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_io_cancel_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_io_cancel ( %llu, %#lx, %#lx )", (ULong )arrghs->arg1,
                   arrghs->arg2, arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_aio_context_t ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_aio_context_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1631,
                            (Char const   *)"vgSysWrap_linux_sys_io_cancel_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1631,
                            (Char const   *)"vgSysWrap_linux_sys_io_cancel_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"io_cancel(ctx_id)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_aio_context_t ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(struct iocb *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct iocb *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1631,
                            (Char const   *)"vgSysWrap_linux_sys_io_cancel_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1631,
                            (Char const   *)"vgSysWrap_linux_sys_io_cancel_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"io_cancel(iocb)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(struct iocb *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(struct io_event *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct io_event *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1631,
                            (Char const   *)"vgSysWrap_linux_sys_io_cancel_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1631,
                            (Char const   *)"vgSysWrap_linux_sys_io_cancel_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"io_cancel(result)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(struct io_event *));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"io_cancel(iocb)",
                                            arrghs->arg2,
                                            (SizeT )sizeof(struct vki_iocb ));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"io_cancel(result)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(struct vki_io_event ));
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_io_cancel_after(ThreadId tid , SyscallArgs *arrghs ,
                                         SyscallStatus *status ) 
{ 


  {
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(struct vki_io_event ));
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_mbind_before(ThreadId tid , SyscallArgLayout *layout ,
                                      SyscallArgs *arrghs ,
                                      SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;
  Int here___3 ;
  long tmp___7 ;
  long tmp___8 ;
  Int here___4 ;
  long tmp___9 ;
  long tmp___10 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_mbind ( %#lx, %lu, %ld, %#lx, %lu, %lu )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3, arrghs->arg4, arrghs->arg5,
                   arrghs->arg6);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(unsigned long ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned long) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1650,
                            (Char const   *)"vgSysWrap_linux_sys_mbind_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1650,
                            (Char const   *)"vgSysWrap_linux_sys_mbind_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"mbind(start)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(unsigned long ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(unsigned long ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned long) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1650,
                            (Char const   *)"vgSysWrap_linux_sys_mbind_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1650,
                            (Char const   *)"vgSysWrap_linux_sys_mbind_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"mbind(len)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(unsigned long ));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(unsigned long ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned long) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1650,
                            (Char const   *)"vgSysWrap_linux_sys_mbind_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1650,
                            (Char const   *)"vgSysWrap_linux_sys_mbind_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"mbind(policy)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(unsigned long ));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(unsigned long *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned long *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1650,
                            (Char const   *)"vgSysWrap_linux_sys_mbind_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1650,
                            (Char const   *)"vgSysWrap_linux_sys_mbind_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"mbind(nodemask)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(unsigned long *));
      break;
    }
    while (1) {
      here___3 = layout->o_arg5;
      tmp___7 = __builtin_expect((long )(! (! (sizeof(unsigned long ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___7) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned long) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1650,
                            (Char const   *)"vgSysWrap_linux_sys_mbind_before",
                            "");
      }
      tmp___8 = __builtin_expect((long )(! (! (here___3 >= 0))), 1L);
      if (tmp___8) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1650,
                            (Char const   *)"vgSysWrap_linux_sys_mbind_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"mbind(maxnode)",
                                            (PtrdiffT )here___3,
                                            (SizeT )sizeof(unsigned long ));
      break;
    }
    while (1) {
      here___4 = layout->o_arg6;
      tmp___9 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___9) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1650,
                            (Char const   *)"vgSysWrap_linux_sys_mbind_before",
                            "");
      }
      tmp___10 = __builtin_expect((long )(! (! (here___4 >= 0))), 1L);
      if (tmp___10) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1650,
                            (Char const   *)"vgSysWrap_linux_sys_mbind_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"mbind(flags)",
                                            (PtrdiffT )here___4,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
  } else {

  }
  if (arrghs->arg1 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"mbind(nodemask)",
                                              arrghs->arg4,
                                              ((((arrghs->arg5 - 1UL) + (UWord )(sizeof(UWord ) * 8U)) - 1UL) & ~ ((Addr )(sizeof(UWord ) * 8U) - 1UL)) / 8UL);
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_set_mempolicy_before(ThreadId tid ,
                                              SyscallArgLayout *layout ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ,
                                              UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_set_mempolicy ( %ld, %#lx, %ld )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1661,
                            (Char const   *)"vgSysWrap_linux_sys_set_mempolicy_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1661,
                            (Char const   *)"vgSysWrap_linux_sys_set_mempolicy_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"set_mempolicy(policy)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(unsigned long *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned long *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1661,
                            (Char const   *)"vgSysWrap_linux_sys_set_mempolicy_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1661,
                            (Char const   *)"vgSysWrap_linux_sys_set_mempolicy_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"set_mempolicy(nodemask)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(unsigned long *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(unsigned long ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned long) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1661,
                            (Char const   *)"vgSysWrap_linux_sys_set_mempolicy_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1661,
                            (Char const   *)"vgSysWrap_linux_sys_set_mempolicy_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"set_mempolicy(maxnode)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(unsigned long ));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"set_mempolicy(nodemask)",
                                            arrghs->arg2,
                                            ((((arrghs->arg3 - 1UL) + (UWord )(sizeof(UWord ) * 8U)) - 1UL) & ~ ((Addr )(sizeof(UWord ) * 8U) - 1UL)) / 8UL);
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_get_mempolicy_before(ThreadId tid ,
                                              SyscallArgLayout *layout ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ,
                                              UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;
  Int here___3 ;
  long tmp___7 ;
  long tmp___8 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_get_mempolicy ( %#lx, %#lx, %ld, %#lx, %lx )",
                   arrghs->arg1, arrghs->arg2, arrghs->arg3, arrghs->arg4,
                   arrghs->arg5);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int *) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1672,
                            (Char const   *)"vgSysWrap_linux_sys_get_mempolicy_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1672,
                            (Char const   *)"vgSysWrap_linux_sys_get_mempolicy_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"get_mempolicy(policy)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int *));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(unsigned long *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned long *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1672,
                            (Char const   *)"vgSysWrap_linux_sys_get_mempolicy_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1672,
                            (Char const   *)"vgSysWrap_linux_sys_get_mempolicy_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"get_mempolicy(nodemask)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(unsigned long *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(unsigned long ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned long) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1672,
                            (Char const   *)"vgSysWrap_linux_sys_get_mempolicy_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1672,
                            (Char const   *)"vgSysWrap_linux_sys_get_mempolicy_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"get_mempolicy(maxnode)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(unsigned long ));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(unsigned long ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned long) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1672,
                            (Char const   *)"vgSysWrap_linux_sys_get_mempolicy_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1672,
                            (Char const   *)"vgSysWrap_linux_sys_get_mempolicy_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"get_mempolicy(addr)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(unsigned long ));
      break;
    }
    while (1) {
      here___3 = layout->o_arg5;
      tmp___7 = __builtin_expect((long )(! (! (sizeof(unsigned long ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___7) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned long) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1672,
                            (Char const   *)"vgSysWrap_linux_sys_get_mempolicy_before",
                            "");
      }
      tmp___8 = __builtin_expect((long )(! (! (here___3 >= 0))), 1L);
      if (tmp___8) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1672,
                            (Char const   *)"vgSysWrap_linux_sys_get_mempolicy_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"get_mempolicy(flags)",
                                            (PtrdiffT )here___3,
                                            (SizeT )sizeof(unsigned long ));
      break;
    }
  } else {

  }
  if (arrghs->arg1 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_write) {
        (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                               (Char *)"get_mempolicy(policy)",
                                               arrghs->arg1,
                                               (SizeT )sizeof(Int ));
      } else {

      }
      break;
    }
  } else {

  }
  if (arrghs->arg2 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_write) {
        (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                               (Char *)"get_mempolicy(nodemask)",
                                               arrghs->arg2,
                                               ((((arrghs->arg3 - 1UL) + (UWord )(sizeof(UWord ) * 8U)) - 1UL) & ~ ((Addr )(sizeof(UWord ) * 8U) - 1UL)) / 8UL);
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_get_mempolicy_after(ThreadId tid ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ) 
{ 


  {
  if (arrghs->arg1 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg1,
                                                (SizeT )sizeof(Int ));
      } else {

      }
      break;
    }
  } else {

  }
  if (arrghs->arg2 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg2,
                                                ((((arrghs->arg3 - 1UL) + (UWord )(sizeof(UWord ) * 8U)) - 1UL) & ~ ((Addr )(sizeof(UWord ) * 8U) - 1UL)) / 8UL);
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_inotify_init_before(ThreadId tid ,
                                             SyscallArgLayout *layout ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ,
                                             UWord *flags ) 
{ 


  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_inotify_init ( )");
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_inotify_init_after(ThreadId tid , SyscallArgs *arrghs ,
                                            SyscallStatus *status ) 
{ 
  Bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  UWord tmp___2 ;
  Word wzz ;
  int tmp___3 ;
  long tmp___4 ;
  UWord tmp___5 ;
  UWord tmp___6 ;
  Bool tmp___7 ;

  {
  if ((unsigned int )status->what == 1U) {
    tmp = sr_isError(status->sres);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
  } else {
    tmp___0 = 0;
  }
  tmp___1 = __builtin_expect((long )tmp___0, 1L);
  if (tmp___1) {

  } else {
    vgPlain_assert_fail((Bool )1, (Char const   *)"SUCCESS",
                        (Char const   *)"m_syswrap/syswrap-linux.c", 1698,
                        (Char const   *)"vgSysWrap_linux_sys_inotify_init_after",
                        "");
  }
  tmp___6 = getRES(status);
  tmp___7 = vgModuleLocal_fd_allowed((Int )tmp___6,
                                     (Char const   *)"inotify_init", tid,
                                     (Bool )1);
  if (tmp___7) {
    if (vgPlain_clo_track_fds) {
      tmp___5 = getRES(status);
      vgModuleLocal_record_fd_open_nameless(tid, (Int )tmp___5);
    } else {

    }
  } else {
    tmp___2 = getRES(status);
    vgPlain_close((Int )tmp___2);
    while (1) {
      wzz = (Word )24;
      if (wzz >= 0L) {
        if (wzz < 10000L) {
          tmp___3 = 1;
        } else {
          tmp___3 = 0;
        }
      } else {
        tmp___3 = 0;
      }
      tmp___4 = __builtin_expect((long )tmp___3, 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"wzz >= 0 && wzz < 10000",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1701,
                            (Char const   *)"vgSysWrap_linux_sys_inotify_init_after",
                            "");
      }
      status->what = (enum __anonenum_what_129 )1;
      status->sres = vgPlain_mk_SysRes_Error((UWord )wzz);
      break;
    }
  }
  return;
}
}
void vgSysWrap_linux_sys_inotify_init1_before(ThreadId tid ,
                                              SyscallArgLayout *layout ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ,
                                              UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_inotify_init ( %ld )", arrghs->arg1);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1711,
                            (Char const   *)"vgSysWrap_linux_sys_inotify_init1_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1711,
                            (Char const   *)"vgSysWrap_linux_sys_inotify_init1_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"inotify_init(flag)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_inotify_init1_after(ThreadId tid ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ) 
{ 
  Bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  UWord tmp___2 ;
  Word wzz ;
  int tmp___3 ;
  long tmp___4 ;
  UWord tmp___5 ;
  UWord tmp___6 ;
  Bool tmp___7 ;

  {
  if ((unsigned int )status->what == 1U) {
    tmp = sr_isError(status->sres);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
  } else {
    tmp___0 = 0;
  }
  tmp___1 = __builtin_expect((long )tmp___0, 1L);
  if (tmp___1) {

  } else {
    vgPlain_assert_fail((Bool )1, (Char const   *)"SUCCESS",
                        (Char const   *)"m_syswrap/syswrap-linux.c", 1716,
                        (Char const   *)"vgSysWrap_linux_sys_inotify_init1_after",
                        "");
  }
  tmp___6 = getRES(status);
  tmp___7 = vgModuleLocal_fd_allowed((Int )tmp___6,
                                     (Char const   *)"inotify_init", tid,
                                     (Bool )1);
  if (tmp___7) {
    if (vgPlain_clo_track_fds) {
      tmp___5 = getRES(status);
      vgModuleLocal_record_fd_open_nameless(tid, (Int )tmp___5);
    } else {

    }
  } else {
    tmp___2 = getRES(status);
    vgPlain_close((Int )tmp___2);
    while (1) {
      wzz = (Word )24;
      if (wzz >= 0L) {
        if (wzz < 10000L) {
          tmp___3 = 1;
        } else {
          tmp___3 = 0;
        }
      } else {
        tmp___3 = 0;
      }
      tmp___4 = __builtin_expect((long )tmp___3, 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"wzz >= 0 && wzz < 10000",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1719,
                            (Char const   *)"vgSysWrap_linux_sys_inotify_init1_after",
                            "");
      }
      status->what = (enum __anonenum_what_129 )1;
      status->sres = vgPlain_mk_SysRes_Error((UWord )wzz);
      break;
    }
  }
  return;
}
}
void vgSysWrap_linux_sys_inotify_add_watch_before(ThreadId tid ,
                                                  SyscallArgLayout *layout ,
                                                  SyscallArgs *arrghs ,
                                                  SyscallStatus *status ,
                                                  UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_inotify_add_watch ( %ld, %#lx, %lx )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1729,
                            (Char const   *)"vgSysWrap_linux_sys_inotify_add_watch_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1729,
                            (Char const   *)"vgSysWrap_linux_sys_inotify_add_watch_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"inotify_add_watch(fd)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(char *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1729,
                            (Char const   *)"vgSysWrap_linux_sys_inotify_add_watch_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1729,
                            (Char const   *)"vgSysWrap_linux_sys_inotify_add_watch_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"inotify_add_watch(path)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(char *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1729,
                            (Char const   *)"vgSysWrap_linux_sys_inotify_add_watch_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1729,
                            (Char const   *)"vgSysWrap_linux_sys_inotify_add_watch_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"inotify_add_watch(mask)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"inotify_add_watch(path)",
                                                   arrghs->arg2);
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_inotify_rm_watch_before(ThreadId tid ,
                                                 SyscallArgLayout *layout ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ,
                                                 UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_inotify_rm_watch ( %ld, %lx )", arrghs->arg1,
                   arrghs->arg2);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1736,
                            (Char const   *)"vgSysWrap_linux_sys_inotify_rm_watch_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1736,
                            (Char const   *)"vgSysWrap_linux_sys_inotify_rm_watch_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"inotify_rm_watch(fd)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1736,
                            (Char const   *)"vgSysWrap_linux_sys_inotify_rm_watch_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1736,
                            (Char const   *)"vgSysWrap_linux_sys_inotify_rm_watch_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"inotify_rm_watch(wd)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_mq_open_before(ThreadId tid ,
                                        SyscallArgLayout *layout ,
                                        SyscallArgs *arrghs ,
                                        SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;
  struct vki_mq_attr  const  *attr ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_mq_open( %#lx(%s), %ld, %lld, %#lx )", arrghs->arg1,
                   (char *)arrghs->arg1, arrghs->arg2, (ULong )arrghs->arg3,
                   arrghs->arg4);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(char const   *) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1749,
                            (Char const   *)"vgSysWrap_linux_sys_mq_open_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1749,
                            (Char const   *)"vgSysWrap_linux_sys_mq_open_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"mq_open(name)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(char const   *));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1749,
                            (Char const   *)"vgSysWrap_linux_sys_mq_open_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1749,
                            (Char const   *)"vgSysWrap_linux_sys_mq_open_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"mq_open(oflag)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(vki_mode_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_mode_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1749,
                            (Char const   *)"vgSysWrap_linux_sys_mq_open_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1749,
                            (Char const   *)"vgSysWrap_linux_sys_mq_open_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"mq_open(mode)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(vki_mode_t ));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(struct mq_attr *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct mq_attr *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1749,
                            (Char const   *)"vgSysWrap_linux_sys_mq_open_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1749,
                            (Char const   *)"vgSysWrap_linux_sys_mq_open_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"mq_open(attr)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(struct mq_attr *));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"mq_open(name)",
                                                   arrghs->arg1);
    } else {

    }
    break;
  }
  if ((arrghs->arg2 & 64UL) != 0UL) {
    if (arrghs->arg4 != 0UL) {
      attr = (struct vki_mq_attr  const  *)((struct vki_mq_attr *)arrghs->arg4);
      while (1) {
        if (vgPlain_tdict.track_pre_mem_read) {
          (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                                (Char *)"mq_open(attr->mq_maxmsg)",
                                                (Addr )(& attr->mq_maxmsg),
                                                (SizeT )sizeof(attr->mq_maxmsg));
        } else {

        }
        break;
      }
      while (1) {
        if (vgPlain_tdict.track_pre_mem_read) {
          (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                                (Char *)"mq_open(attr->mq_msgsize)",
                                                (Addr )(& attr->mq_msgsize),
                                                (SizeT )sizeof(attr->mq_msgsize));
        } else {

        }
        break;
      }
    } else {

    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_mq_open_after(ThreadId tid , SyscallArgs *arrghs ,
                                       SyscallStatus *status ) 
{ 
  Bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  UWord tmp___2 ;
  Word wzz ;
  int tmp___3 ;
  long tmp___4 ;
  UWord tmp___5 ;
  UWord tmp___6 ;
  Bool tmp___7 ;

  {
  if ((unsigned int )status->what == 1U) {
    tmp = sr_isError(status->sres);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
  } else {
    tmp___0 = 0;
  }
  tmp___1 = __builtin_expect((long )tmp___0, 1L);
  if (tmp___1) {

  } else {
    vgPlain_assert_fail((Bool )1, (Char const   *)"SUCCESS",
                        (Char const   *)"m_syswrap/syswrap-linux.c", 1761,
                        (Char const   *)"vgSysWrap_linux_sys_mq_open_after", "");
  }
  tmp___6 = getRES(status);
  tmp___7 = vgModuleLocal_fd_allowed((Int )tmp___6, (Char const   *)"mq_open",
                                     tid, (Bool )1);
  if (tmp___7) {
    if (vgPlain_clo_track_fds) {
      tmp___5 = getRES(status);
      vgModuleLocal_record_fd_open_with_given_name(tid, (Int )tmp___5,
                                                   (char *)((Char *)arrghs->arg1));
    } else {

    }
  } else {
    tmp___2 = getRES(status);
    vgPlain_close((Int )tmp___2);
    while (1) {
      wzz = (Word )24;
      if (wzz >= 0L) {
        if (wzz < 10000L) {
          tmp___3 = 1;
        } else {
          tmp___3 = 0;
        }
      } else {
        tmp___3 = 0;
      }
      tmp___4 = __builtin_expect((long )tmp___3, 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"wzz >= 0 && wzz < 10000",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1764,
                            (Char const   *)"vgSysWrap_linux_sys_mq_open_after",
                            "");
      }
      status->what = (enum __anonenum_what_129 )1;
      status->sres = vgPlain_mk_SysRes_Error((UWord )wzz);
      break;
    }
  }
  return;
}
}
void vgSysWrap_linux_sys_mq_unlink_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_mq_unlink ( %#lx(%s) )", arrghs->arg1,
                   (char *)arrghs->arg1);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(char const   *) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1774,
                            (Char const   *)"vgSysWrap_linux_sys_mq_unlink_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1774,
                            (Char const   *)"vgSysWrap_linux_sys_mq_unlink_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"mq_unlink(name)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(char const   *));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"mq_unlink(name)",
                                                   arrghs->arg1);
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_mq_timedsend_before(ThreadId tid ,
                                             SyscallArgLayout *layout ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ,
                                             UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;
  Int here___3 ;
  long tmp___7 ;
  long tmp___8 ;
  Word wzz ;
  int tmp___9 ;
  long tmp___10 ;
  Bool tmp___11 ;

  {
  *flags |= (unsigned long )(1 << 1);
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_mq_timedsend ( %ld, %#lx, %llu, %ld, %#lx )",
                   arrghs->arg1, arrghs->arg2, (ULong )arrghs->arg3,
                   arrghs->arg4, arrghs->arg5);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_mqd_t ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_mqd_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1785,
                            (Char const   *)"vgSysWrap_linux_sys_mq_timedsend_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1785,
                            (Char const   *)"vgSysWrap_linux_sys_mq_timedsend_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"mq_timedsend(mqdes)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_mqd_t ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(char const   *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1785,
                            (Char const   *)"vgSysWrap_linux_sys_mq_timedsend_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1785,
                            (Char const   *)"vgSysWrap_linux_sys_mq_timedsend_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"mq_timedsend(msg_ptr)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(char const   *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(vki_size_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_size_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1785,
                            (Char const   *)"vgSysWrap_linux_sys_mq_timedsend_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1785,
                            (Char const   *)"vgSysWrap_linux_sys_mq_timedsend_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"mq_timedsend(msg_len)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(vki_size_t ));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1785,
                            (Char const   *)"vgSysWrap_linux_sys_mq_timedsend_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1785,
                            (Char const   *)"vgSysWrap_linux_sys_mq_timedsend_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"mq_timedsend(msg_prio)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
    while (1) {
      here___3 = layout->o_arg5;
      tmp___7 = __builtin_expect((long )(! (! (sizeof(struct timespec  const  *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___7) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const struct timespec *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1785,
                            (Char const   *)"vgSysWrap_linux_sys_mq_timedsend_before",
                            "");
      }
      tmp___8 = __builtin_expect((long )(! (! (here___3 >= 0))), 1L);
      if (tmp___8) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1785,
                            (Char const   *)"vgSysWrap_linux_sys_mq_timedsend_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"mq_timedsend(abs_timeout)",
                                            (PtrdiffT )here___3,
                                            (SizeT )sizeof(struct timespec  const  *));
      break;
    }
  } else {

  }
  tmp___11 = vgModuleLocal_fd_allowed((Int )arrghs->arg1,
                                      (Char const   *)"mq_timedsend", tid,
                                      (Bool )0);
  if (tmp___11) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"mq_timedsend(msg_ptr)",
                                              arrghs->arg2, arrghs->arg3);
      } else {

      }
      break;
    }
    if (arrghs->arg5 != 0UL) {
      while (1) {
        if (vgPlain_tdict.track_pre_mem_read) {
          (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                                (Char *)"mq_timedsend(abs_timeout)",
                                                arrghs->arg5,
                                                (SizeT )sizeof(struct vki_timespec ));
        } else {

        }
        break;
      }
    } else {

    }
  } else {
    while (1) {
      wzz = (Word )9;
      if (wzz >= 0L) {
        if (wzz < 10000L) {
          tmp___9 = 1;
        } else {
          tmp___9 = 0;
        }
      } else {
        tmp___9 = 0;
      }
      tmp___10 = __builtin_expect((long )tmp___9, 1L);
      if (tmp___10) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"wzz >= 0 && wzz < 10000",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1787,
                            (Char const   *)"vgSysWrap_linux_sys_mq_timedsend_before",
                            "");
      }
      status->what = (enum __anonenum_what_129 )1;
      status->sres = vgPlain_mk_SysRes_Error((UWord )wzz);
      break;
    }
  }
  return;
}
}
void vgSysWrap_linux_sys_mq_timedreceive_before(ThreadId tid ,
                                                SyscallArgLayout *layout ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ,
                                                UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;
  Int here___3 ;
  long tmp___7 ;
  long tmp___8 ;
  Word wzz ;
  int tmp___9 ;
  long tmp___10 ;
  Bool tmp___11 ;

  {
  *flags |= (unsigned long )(1 << 1);
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_mq_timedreceive( %ld, %#lx, %llu, %#lx, %#lx )",
                   arrghs->arg1, arrghs->arg2, (ULong )arrghs->arg3,
                   arrghs->arg4, arrghs->arg5);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_mqd_t ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_mqd_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1804,
                            (Char const   *)"vgSysWrap_linux_sys_mq_timedreceive_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1804,
                            (Char const   *)"vgSysWrap_linux_sys_mq_timedreceive_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"mq_timedreceive(mqdes)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_mqd_t ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(char *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1804,
                            (Char const   *)"vgSysWrap_linux_sys_mq_timedreceive_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1804,
                            (Char const   *)"vgSysWrap_linux_sys_mq_timedreceive_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"mq_timedreceive(msg_ptr)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(char *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(vki_size_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_size_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1804,
                            (Char const   *)"vgSysWrap_linux_sys_mq_timedreceive_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1804,
                            (Char const   *)"vgSysWrap_linux_sys_mq_timedreceive_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"mq_timedreceive(msg_len)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(vki_size_t ));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(unsigned int *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned int *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1804,
                            (Char const   *)"vgSysWrap_linux_sys_mq_timedreceive_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1804,
                            (Char const   *)"vgSysWrap_linux_sys_mq_timedreceive_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"mq_timedreceive(msg_prio)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(unsigned int *));
      break;
    }
    while (1) {
      here___3 = layout->o_arg5;
      tmp___7 = __builtin_expect((long )(! (! (sizeof(struct timespec  const  *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___7) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const struct timespec *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1804,
                            (Char const   *)"vgSysWrap_linux_sys_mq_timedreceive_before",
                            "");
      }
      tmp___8 = __builtin_expect((long )(! (! (here___3 >= 0))), 1L);
      if (tmp___8) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1804,
                            (Char const   *)"vgSysWrap_linux_sys_mq_timedreceive_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"mq_timedreceive(abs_timeout)",
                                            (PtrdiffT )here___3,
                                            (SizeT )sizeof(struct timespec  const  *));
      break;
    }
  } else {

  }
  tmp___11 = vgModuleLocal_fd_allowed((Int )arrghs->arg1,
                                      (Char const   *)"mq_timedreceive", tid,
                                      (Bool )0);
  if (tmp___11) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_write) {
        (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                               (Char *)"mq_timedreceive(msg_ptr)",
                                               arrghs->arg2, arrghs->arg3);
      } else {

      }
      break;
    }
    if (arrghs->arg4 != 0UL) {
      while (1) {
        if (vgPlain_tdict.track_pre_mem_write) {
          (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                                 (Char *)"mq_timedreceive(msg_prio)",
                                                 arrghs->arg4,
                                                 (SizeT )sizeof(unsigned int ));
        } else {

        }
        break;
      }
    } else {

    }
    if (arrghs->arg5 != 0UL) {
      while (1) {
        if (vgPlain_tdict.track_pre_mem_read) {
          (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                                (Char *)"mq_timedreceive(abs_timeout)",
                                                arrghs->arg5,
                                                (SizeT )sizeof(struct vki_timespec ));
        } else {

        }
        break;
      }
    } else {

    }
  } else {
    while (1) {
      wzz = (Word )9;
      if (wzz >= 0L) {
        if (wzz < 10000L) {
          tmp___9 = 1;
        } else {
          tmp___9 = 0;
        }
      } else {
        tmp___9 = 0;
      }
      tmp___10 = __builtin_expect((long )tmp___9, 1L);
      if (tmp___10) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"wzz >= 0 && wzz < 10000",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1806,
                            (Char const   *)"vgSysWrap_linux_sys_mq_timedreceive_before",
                            "");
      }
      status->what = (enum __anonenum_what_129 )1;
      status->sres = vgPlain_mk_SysRes_Error((UWord )wzz);
      break;
    }
  }
  return;
}
}
void vgSysWrap_linux_sys_mq_timedreceive_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) 
{ 
  UWord tmp ;

  {
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      tmp = getRES(status);
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg2,
                                              tmp);
    } else {

    }
    break;
  }
  if (arrghs->arg4 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg4,
                                                (SizeT )sizeof(unsigned int ));
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_mq_notify_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Word wzz ;
  int tmp___3 ;
  long tmp___4 ;
  Bool tmp___5 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_mq_notify( %ld, %#lx )", arrghs->arg1, arrghs->arg2);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_mqd_t ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_mqd_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1828,
                            (Char const   *)"vgSysWrap_linux_sys_mq_notify_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1828,
                            (Char const   *)"vgSysWrap_linux_sys_mq_notify_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"mq_notify(mqdes)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_mqd_t ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(struct sigevent  const  *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const struct sigevent *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1828,
                            (Char const   *)"vgSysWrap_linux_sys_mq_notify_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1828,
                            (Char const   *)"vgSysWrap_linux_sys_mq_notify_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"mq_notify(notification)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(struct sigevent  const  *));
      break;
    }
  } else {

  }
  tmp___5 = vgModuleLocal_fd_allowed((Int )arrghs->arg1,
                                     (Char const   *)"mq_notify", tid, (Bool )0);
  if (tmp___5) {
    if (arrghs->arg2 != 0UL) {
      while (1) {
        if (vgPlain_tdict.track_pre_mem_read) {
          (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                                (Char *)"mq_notify(notification)",
                                                arrghs->arg2,
                                                (SizeT )sizeof(struct vki_sigevent ));
        } else {

        }
        break;
      }
    } else {

    }
  } else {
    while (1) {
      wzz = (Word )9;
      if (wzz >= 0L) {
        if (wzz < 10000L) {
          tmp___3 = 1;
        } else {
          tmp___3 = 0;
        }
      } else {
        tmp___3 = 0;
      }
      tmp___4 = __builtin_expect((long )tmp___3, 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"wzz >= 0 && wzz < 10000",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1830,
                            (Char const   *)"vgSysWrap_linux_sys_mq_notify_before",
                            "");
      }
      status->what = (enum __anonenum_what_129 )1;
      status->sres = vgPlain_mk_SysRes_Error((UWord )wzz);
      break;
    }
  }
  return;
}
}
void vgSysWrap_linux_sys_mq_getsetattr_before(ThreadId tid ,
                                              SyscallArgLayout *layout ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ,
                                              UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Word wzz ;
  int tmp___5 ;
  long tmp___6 ;
  struct vki_mq_attr  const  *attr ;
  Bool tmp___7 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_mq_getsetattr( %ld, %#lx, %#lx )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_mqd_t ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_mqd_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1841,
                            (Char const   *)"vgSysWrap_linux_sys_mq_getsetattr_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1841,
                            (Char const   *)"vgSysWrap_linux_sys_mq_getsetattr_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"mq_getsetattr(mqdes)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_mqd_t ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(struct mq_attr  const  *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const struct mq_attr *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1841,
                            (Char const   *)"vgSysWrap_linux_sys_mq_getsetattr_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1841,
                            (Char const   *)"vgSysWrap_linux_sys_mq_getsetattr_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"mq_getsetattr(mqstat)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(struct mq_attr  const  *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(struct mq_attr *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct mq_attr *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1841,
                            (Char const   *)"vgSysWrap_linux_sys_mq_getsetattr_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1841,
                            (Char const   *)"vgSysWrap_linux_sys_mq_getsetattr_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"mq_getsetattr(omqstat)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(struct mq_attr *));
      break;
    }
  } else {

  }
  tmp___7 = vgModuleLocal_fd_allowed((Int )arrghs->arg1,
                                     (Char const   *)"mq_getsetattr", tid,
                                     (Bool )0);
  if (tmp___7) {
    if (arrghs->arg2 != 0UL) {
      attr = (struct vki_mq_attr  const  *)((struct vki_mq_attr *)arrghs->arg2);
      while (1) {
        if (vgPlain_tdict.track_pre_mem_read) {
          (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                                (Char *)"mq_getsetattr(mqstat->mq_flags)",
                                                (Addr )(& attr->mq_flags),
                                                (SizeT )sizeof(attr->mq_flags));
        } else {

        }
        break;
      }
    } else {

    }
    if (arrghs->arg3 != 0UL) {
      while (1) {
        if (vgPlain_tdict.track_pre_mem_write) {
          (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                                 (Char *)"mq_getsetattr(omqstat)",
                                                 arrghs->arg3,
                                                 (SizeT )sizeof(struct vki_mq_attr ));
        } else {

        }
        break;
      }
    } else {

    }
  } else {
    while (1) {
      wzz = (Word )9;
      if (wzz >= 0L) {
        if (wzz < 10000L) {
          tmp___5 = 1;
        } else {
          tmp___5 = 0;
        }
      } else {
        tmp___5 = 0;
      }
      tmp___6 = __builtin_expect((long )tmp___5, 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"wzz >= 0 && wzz < 10000",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1843,
                            (Char const   *)"vgSysWrap_linux_sys_mq_getsetattr_before",
                            "");
      }
      status->what = (enum __anonenum_what_129 )1;
      status->sres = vgPlain_mk_SysRes_Error((UWord )wzz);
      break;
    }
  }
  return;
}
}
void vgSysWrap_linux_sys_mq_getsetattr_after(ThreadId tid ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ) 
{ 


  {
  if (arrghs->arg3 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                                (SizeT )sizeof(struct vki_mq_attr ));
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_clock_settime_before(ThreadId tid ,
                                              SyscallArgLayout *layout ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ,
                                              UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_clock_settime( %ld, %#lx )", arrghs->arg1, arrghs->arg2);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_clockid_t ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_clockid_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1869,
                            (Char const   *)"vgSysWrap_linux_sys_clock_settime_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1869,
                            (Char const   *)"vgSysWrap_linux_sys_clock_settime_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"clock_settime(clk_id)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_clockid_t ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(struct timespec  const  *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const struct timespec *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1869,
                            (Char const   *)"vgSysWrap_linux_sys_clock_settime_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1869,
                            (Char const   *)"vgSysWrap_linux_sys_clock_settime_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"clock_settime(tp)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(struct timespec  const  *));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"clock_settime(tp)",
                                            arrghs->arg2,
                                            (SizeT )sizeof(struct vki_timespec ));
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_clock_gettime_before(ThreadId tid ,
                                              SyscallArgLayout *layout ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ,
                                              UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_clock_gettime( %ld, %#lx )", arrghs->arg1, arrghs->arg2);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_clockid_t ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_clockid_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1877,
                            (Char const   *)"vgSysWrap_linux_sys_clock_gettime_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1877,
                            (Char const   *)"vgSysWrap_linux_sys_clock_gettime_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"clock_gettime(clk_id)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_clockid_t ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(struct timespec *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct timespec *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1877,
                            (Char const   *)"vgSysWrap_linux_sys_clock_gettime_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1877,
                            (Char const   *)"vgSysWrap_linux_sys_clock_gettime_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"clock_gettime(tp)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(struct timespec *));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"clock_gettime(tp)",
                                             arrghs->arg2,
                                             (SizeT )sizeof(struct vki_timespec ));
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_clock_gettime_after(ThreadId tid ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ) 
{ 


  {
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg2,
                                              (SizeT )sizeof(struct vki_timespec ));
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_clock_getres_before(ThreadId tid ,
                                             SyscallArgLayout *layout ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ,
                                             UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_clock_getres( %ld, %#lx )", arrghs->arg1, arrghs->arg2);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_clockid_t ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_clockid_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1891,
                            (Char const   *)"vgSysWrap_linux_sys_clock_getres_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1891,
                            (Char const   *)"vgSysWrap_linux_sys_clock_getres_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"clock_getres(clk_id)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_clockid_t ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(struct timespec *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct timespec *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1891,
                            (Char const   *)"vgSysWrap_linux_sys_clock_getres_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1891,
                            (Char const   *)"vgSysWrap_linux_sys_clock_getres_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"clock_getres(res)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(struct timespec *));
      break;
    }
  } else {

  }
  if (arrghs->arg2 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_write) {
        (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                               (Char *)"clock_getres(res)",
                                               arrghs->arg2,
                                               (SizeT )sizeof(struct vki_timespec ));
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_clock_getres_after(ThreadId tid , SyscallArgs *arrghs ,
                                            SyscallStatus *status ) 
{ 


  {
  if (arrghs->arg2 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg2,
                                                (SizeT )sizeof(struct vki_timespec ));
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_clock_nanosleep_before(ThreadId tid ,
                                                SyscallArgLayout *layout ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ,
                                                UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;

  {
  *flags |= (unsigned long )((1 << 1) | (1 << 2));
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_clock_nanosleep( %ld, %ld, %#lx, %#lx )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3, arrghs->arg4);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_clockid_t ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_clockid_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1907,
                            (Char const   *)"vgSysWrap_linux_sys_clock_nanosleep_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1907,
                            (Char const   *)"vgSysWrap_linux_sys_clock_nanosleep_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"clock_nanosleep(clkid)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_clockid_t ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1907,
                            (Char const   *)"vgSysWrap_linux_sys_clock_nanosleep_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1907,
                            (Char const   *)"vgSysWrap_linux_sys_clock_nanosleep_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"clock_nanosleep(flags)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(struct timespec  const  *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const struct timespec *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1907,
                            (Char const   *)"vgSysWrap_linux_sys_clock_nanosleep_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1907,
                            (Char const   *)"vgSysWrap_linux_sys_clock_nanosleep_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"clock_nanosleep(rqtp)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(struct timespec  const  *));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(struct timespec *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct timespec *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1907,
                            (Char const   *)"vgSysWrap_linux_sys_clock_nanosleep_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1907,
                            (Char const   *)"vgSysWrap_linux_sys_clock_nanosleep_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"clock_nanosleep(rmtp)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(struct timespec *));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"clock_nanosleep(rqtp)",
                                            arrghs->arg3,
                                            (SizeT )sizeof(struct vki_timespec ));
    } else {

    }
    break;
  }
  if (arrghs->arg4 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_write) {
        (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                               (Char *)"clock_nanosleep(rmtp)",
                                               arrghs->arg4,
                                               (SizeT )sizeof(struct vki_timespec ));
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_clock_nanosleep_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) 
{ 
  Bool tmp ;
  UWord tmp___0 ;

  {
  if (arrghs->arg4 != 0UL) {
    if ((unsigned int )status->what == 1U) {
      tmp = sr_isError(status->sres);
      if (tmp) {
        tmp___0 = getERR(status);
        if (tmp___0 == 4UL) {
          while (1) {
            if (vgPlain_tdict.track_post_mem_write) {
              (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                      arrghs->arg4,
                                                      (SizeT )sizeof(struct vki_timespec ));
            } else {

            }
            break;
          }
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_timer_create_before(ThreadId tid ,
                                             SyscallArgLayout *layout ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ,
                                             UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_timer_create( %ld, %#lx, %#lx )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_clockid_t ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_clockid_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1927,
                            (Char const   *)"vgSysWrap_linux_sys_timer_create_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1927,
                            (Char const   *)"vgSysWrap_linux_sys_timer_create_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"timer_create(clockid)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_clockid_t ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(struct sigevent *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct sigevent *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1927,
                            (Char const   *)"vgSysWrap_linux_sys_timer_create_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1927,
                            (Char const   *)"vgSysWrap_linux_sys_timer_create_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"timer_create(evp)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(struct sigevent *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(vki_timer_t *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_timer_t *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1927,
                            (Char const   *)"vgSysWrap_linux_sys_timer_create_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1927,
                            (Char const   *)"vgSysWrap_linux_sys_timer_create_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"timer_create(timerid)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(vki_timer_t *));
      break;
    }
  } else {

  }
  if (arrghs->arg2 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"timer_create(evp)",
                                              arrghs->arg2,
                                              (SizeT )sizeof(struct vki_sigevent ));
      } else {

      }
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"timer_create(timerid)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(vki_timer_t ));
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_timer_create_after(ThreadId tid , SyscallArgs *arrghs ,
                                            SyscallStatus *status ) 
{ 


  {
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(vki_timer_t ));
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_timer_settime_before(ThreadId tid ,
                                              SyscallArgLayout *layout ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ,
                                              UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_timer_settime( %lld, %ld, %#lx, %#lx )",
                   (ULong )arrghs->arg1, arrghs->arg2, arrghs->arg3,
                   arrghs->arg4);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_timer_t ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_timer_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1943,
                            (Char const   *)"vgSysWrap_linux_sys_timer_settime_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1943,
                            (Char const   *)"vgSysWrap_linux_sys_timer_settime_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"timer_settime(timerid)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_timer_t ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1943,
                            (Char const   *)"vgSysWrap_linux_sys_timer_settime_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1943,
                            (Char const   *)"vgSysWrap_linux_sys_timer_settime_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"timer_settime(flags)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(struct itimerspec  const  *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const struct itimerspec *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1943,
                            (Char const   *)"vgSysWrap_linux_sys_timer_settime_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1943,
                            (Char const   *)"vgSysWrap_linux_sys_timer_settime_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"timer_settime(value)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(struct itimerspec  const  *));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(struct itimerspec *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct itimerspec *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1943,
                            (Char const   *)"vgSysWrap_linux_sys_timer_settime_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1943,
                            (Char const   *)"vgSysWrap_linux_sys_timer_settime_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"timer_settime(ovalue)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(struct itimerspec *));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"timer_settime(value)",
                                            arrghs->arg3,
                                            (SizeT )sizeof(struct vki_itimerspec ));
    } else {

    }
    break;
  }
  if (arrghs->arg4 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_write) {
        (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                               (Char *)"timer_settime(ovalue)",
                                               arrghs->arg4,
                                               (SizeT )sizeof(struct vki_itimerspec ));
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_timer_settime_after(ThreadId tid ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ) 
{ 


  {
  if (arrghs->arg4 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg4,
                                                (SizeT )sizeof(struct vki_itimerspec ));
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_timer_gettime_before(ThreadId tid ,
                                              SyscallArgLayout *layout ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ,
                                              UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_timer_gettime( %lld, %#lx )", (ULong )arrghs->arg1,
                   arrghs->arg2);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_timer_t ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_timer_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1960,
                            (Char const   *)"vgSysWrap_linux_sys_timer_gettime_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1960,
                            (Char const   *)"vgSysWrap_linux_sys_timer_gettime_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"timer_gettime(timerid)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_timer_t ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(struct itimerspec *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct itimerspec *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1960,
                            (Char const   *)"vgSysWrap_linux_sys_timer_gettime_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1960,
                            (Char const   *)"vgSysWrap_linux_sys_timer_gettime_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"timer_gettime(value)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(struct itimerspec *));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"timer_gettime(value)",
                                             arrghs->arg2,
                                             (SizeT )sizeof(struct vki_itimerspec ));
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_timer_gettime_after(ThreadId tid ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ) 
{ 


  {
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg2,
                                              (SizeT )sizeof(struct vki_itimerspec ));
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_timer_getoverrun_before(ThreadId tid ,
                                                 SyscallArgLayout *layout ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ,
                                                 UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_timer_getoverrun( %#lx )", arrghs->arg1);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_timer_t ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_timer_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1972,
                            (Char const   *)"vgSysWrap_linux_sys_timer_getoverrun_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1972,
                            (Char const   *)"vgSysWrap_linux_sys_timer_getoverrun_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"timer_getoverrun(timerid)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_timer_t ));
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_timer_delete_before(ThreadId tid ,
                                             SyscallArgLayout *layout ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ,
                                             UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_timer_delete( %#lx )", arrghs->arg1);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_timer_t ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_timer_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1978,
                            (Char const   *)"vgSysWrap_linux_sys_timer_delete_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 1978,
                            (Char const   *)"vgSysWrap_linux_sys_timer_delete_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"timer_delete(timerid)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_timer_t ));
      break;
    }
  } else {

  }
  return;
}
}
static Bool linux_kernel_2_6_22(void) ;
static Int result  =    -1;
static Bool linux_kernel_2_6_22(void) 
{ 
  Int fd ;
  Int read ;
  HChar release[64] ;
  SysRes res ;
  Bool tmp ;
  UWord tmp___0 ;
  long tmp___1 ;
  Int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;

  {
  if (result == -1) {
    res = vgPlain_open((Char const   *)"/proc/sys/kernel/osrelease", 0, 0);
    tmp = sr_isError(res);
    if (tmp) {
      return ((Bool )0);
    } else {

    }
    tmp___0 = sr_Res(res);
    fd = (Int )tmp___0;
    read = vgPlain_read(fd, (void *)(release), (Int )(sizeof(release) - 1U));
    tmp___1 = __builtin_expect((long )(! (! (read >= 0))), 1L);
    if (tmp___1) {

    } else {
      vgPlain_assert_fail((Bool )1, (Char const   *)"read >= 0",
                          (Char const   *)"m_syswrap/syswrap-linux.c", 2002,
                          (Char const   *)"linux_kernel_2_6_22", "");
    }
    release[read] = (HChar )0;
    vgPlain_close(fd);
    tmp___2 = vgPlain_strncmp((Char const   *)(release),
                              (Char const   *)"2.6.22", (SizeT )6);
    if (tmp___2 == 0) {
      if ((int )release[6] < 48) {
        tmp___3 = 1;
      } else
      if ((int )release[6] > 57) {
        tmp___3 = 1;
      } else {
        tmp___3 = 0;
      }
    } else {
      tmp___3 = 0;
    }
    result = tmp___3;
  } else {

  }
  if (result == 0) {
    tmp___4 = 1;
  } else
  if (result == 1) {
    tmp___4 = 1;
  } else {
    tmp___4 = 0;
  }
  tmp___5 = __builtin_expect((long )tmp___4, 1L);
  if (tmp___5) {

  } else {
    vgPlain_assert_fail((Bool )1, (Char const   *)"result == 0 || result == 1",
                        (Char const   *)"m_syswrap/syswrap-linux.c", 2009,
                        (Char const   *)"linux_kernel_2_6_22", "");
  }
  return ((Bool )(result == 1));
}
}
void vgSysWrap_linux_sys_timerfd_create_before(ThreadId tid ,
                                               SyscallArgLayout *layout ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ,
                                               UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Word wzz ;
  int tmp___5 ;
  long tmp___6 ;
  Bool tmp___7 ;
  Int here___2 ;
  long tmp___8 ;
  long tmp___9 ;
  Int here___3 ;
  long tmp___10 ;
  long tmp___11 ;
  Bool tmp___12 ;

  {
  tmp___12 = linux_kernel_2_6_22();
  if (tmp___12) {
    if (vgPlain_clo_trace_syscalls) {
      vgPlain_printf("sys_timerfd ( %ld, %ld, %#lx )", arrghs->arg1,
                     arrghs->arg2, arrghs->arg3);
    } else {

    }
    if (vgPlain_tdict.track_pre_reg_read) {
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"(syscallno)",
                                            (PtrdiffT )layout->o_sysno,
                                            (SizeT )sizeof(UWord ));
      while (1) {
        here = layout->o_arg1;
        tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                               1L);
        if (tmp) {

        } else {
          vgPlain_assert_fail((Bool )1,
                              (Char const   *)"sizeof(int) <= sizeof(UWord)",
                              (Char const   *)"m_syswrap/syswrap-linux.c", 2019,
                              (Char const   *)"vgSysWrap_linux_sys_timerfd_create_before",
                              "");
        }
        tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
        if (tmp___0) {

        } else {
          vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                              (Char const   *)"m_syswrap/syswrap-linux.c", 2019,
                              (Char const   *)"vgSysWrap_linux_sys_timerfd_create_before",
                              "");
        }
        (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                              (Char *)"sys_timerfd(fd)",
                                              (PtrdiffT )here,
                                              (SizeT )sizeof(int ));
        break;
      }
      while (1) {
        here___0 = layout->o_arg2;
        tmp___1 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                   1L);
        if (tmp___1) {

        } else {
          vgPlain_assert_fail((Bool )1,
                              (Char const   *)"sizeof(int) <= sizeof(UWord)",
                              (Char const   *)"m_syswrap/syswrap-linux.c", 2019,
                              (Char const   *)"vgSysWrap_linux_sys_timerfd_create_before",
                              "");
        }
        tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
        if (tmp___2) {

        } else {
          vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                              (Char const   *)"m_syswrap/syswrap-linux.c", 2019,
                              (Char const   *)"vgSysWrap_linux_sys_timerfd_create_before",
                              "");
        }
        (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                              (Char *)"sys_timerfd(clockid)",
                                              (PtrdiffT )here___0,
                                              (SizeT )sizeof(int ));
        break;
      }
      while (1) {
        here___1 = layout->o_arg3;
        tmp___3 = __builtin_expect((long )(! (! (sizeof(struct itimerspec  const  *) <= sizeof(UWord )))),
                                   1L);
        if (tmp___3) {

        } else {
          vgPlain_assert_fail((Bool )1,
                              (Char const   *)"sizeof(const struct itimerspec *) <= sizeof(UWord)",
                              (Char const   *)"m_syswrap/syswrap-linux.c", 2019,
                              (Char const   *)"vgSysWrap_linux_sys_timerfd_create_before",
                              "");
        }
        tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
        if (tmp___4) {

        } else {
          vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                              (Char const   *)"m_syswrap/syswrap-linux.c", 2019,
                              (Char const   *)"vgSysWrap_linux_sys_timerfd_create_before",
                              "");
        }
        (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                              (Char *)"sys_timerfd(tmr)",
                                              (PtrdiffT )here___1,
                                              (SizeT )sizeof(struct itimerspec  const  *));
        break;
      }
    } else {

    }
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"timerfd(tmr)",
                                              arrghs->arg3,
                                              (SizeT )sizeof(struct vki_itimerspec ));
      } else {

      }
      break;
    }
    if ((Word )arrghs->arg1 != -1L) {
      tmp___7 = vgModuleLocal_fd_allowed((Int )arrghs->arg1,
                                         (Char const   *)"timerfd", tid,
                                         (Bool )0);
      if (tmp___7) {

      } else {
        while (1) {
          wzz = (Word )9;
          if (wzz >= 0L) {
            if (wzz < 10000L) {
              tmp___5 = 1;
            } else {
              tmp___5 = 0;
            }
          } else {
            tmp___5 = 0;
          }
          tmp___6 = __builtin_expect((long )tmp___5, 1L);
          if (tmp___6) {

          } else {
            vgPlain_assert_fail((Bool )1,
                                (Char const   *)"wzz >= 0 && wzz < 10000",
                                (Char const   *)"m_syswrap/syswrap-linux.c",
                                2023,
                                (Char const   *)"vgSysWrap_linux_sys_timerfd_create_before",
                                "");
          }
          status->what = (enum __anonenum_what_129 )1;
          status->sres = vgPlain_mk_SysRes_Error((UWord )wzz);
          break;
        }
      }
    } else {

    }
  } else {
    if (vgPlain_clo_trace_syscalls) {
      vgPlain_printf("sys_timerfd_create (%ld, %ld )", arrghs->arg1,
                     arrghs->arg2);
    } else {

    }
    if (vgPlain_tdict.track_pre_reg_read) {
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"(syscallno)",
                                            (PtrdiffT )layout->o_sysno,
                                            (SizeT )sizeof(UWord ));
      while (1) {
        here___2 = layout->o_arg1;
        tmp___8 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                   1L);
        if (tmp___8) {

        } else {
          vgPlain_assert_fail((Bool )1,
                              (Char const   *)"sizeof(int) <= sizeof(UWord)",
                              (Char const   *)"m_syswrap/syswrap-linux.c", 2027,
                              (Char const   *)"vgSysWrap_linux_sys_timerfd_create_before",
                              "");
        }
        tmp___9 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
        if (tmp___9) {

        } else {
          vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                              (Char const   *)"m_syswrap/syswrap-linux.c", 2027,
                              (Char const   *)"vgSysWrap_linux_sys_timerfd_create_before",
                              "");
        }
        (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                              (Char *)"timerfd_create(clockid)",
                                              (PtrdiffT )here___2,
                                              (SizeT )sizeof(int ));
        break;
      }
      while (1) {
        here___3 = layout->o_arg2;
        tmp___10 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                    1L);
        if (tmp___10) {

        } else {
          vgPlain_assert_fail((Bool )1,
                              (Char const   *)"sizeof(int) <= sizeof(UWord)",
                              (Char const   *)"m_syswrap/syswrap-linux.c", 2027,
                              (Char const   *)"vgSysWrap_linux_sys_timerfd_create_before",
                              "");
        }
        tmp___11 = __builtin_expect((long )(! (! (here___3 >= 0))), 1L);
        if (tmp___11) {

        } else {
          vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                              (Char const   *)"m_syswrap/syswrap-linux.c", 2027,
                              (Char const   *)"vgSysWrap_linux_sys_timerfd_create_before",
                              "");
        }
        (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                              (Char *)"timerfd_create(flags)",
                                              (PtrdiffT )here___3,
                                              (SizeT )sizeof(int ));
        break;
      }
    } else {

    }
  }
  return;
}
}
void vgSysWrap_linux_sys_timerfd_create_after(ThreadId tid ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ) 
{ 
  UWord tmp ;
  Word wzz ;
  int tmp___0 ;
  long tmp___1 ;
  UWord tmp___2 ;
  UWord tmp___3 ;
  Bool tmp___4 ;
  UWord tmp___5 ;
  Word wzz___0 ;
  int tmp___6 ;
  long tmp___7 ;
  UWord tmp___8 ;
  UWord tmp___9 ;
  Bool tmp___10 ;
  Bool tmp___11 ;

  {
  tmp___11 = linux_kernel_2_6_22();
  if (tmp___11) {
    tmp___3 = getRES(status);
    tmp___4 = vgModuleLocal_fd_allowed((Int )tmp___3, (Char const   *)"timerfd",
                                       tid, (Bool )1);
    if (tmp___4) {
      if (vgPlain_clo_track_fds) {
        tmp___2 = getRES(status);
        vgModuleLocal_record_fd_open_nameless(tid, (Int )tmp___2);
      } else {

      }
    } else {
      tmp = getRES(status);
      vgPlain_close((Int )tmp);
      while (1) {
        wzz = (Word )24;
        if (wzz >= 0L) {
          if (wzz < 10000L) {
            tmp___0 = 1;
          } else {
            tmp___0 = 0;
          }
        } else {
          tmp___0 = 0;
        }
        tmp___1 = __builtin_expect((long )tmp___0, 1L);
        if (tmp___1) {

        } else {
          vgPlain_assert_fail((Bool )1,
                              (Char const   *)"wzz >= 0 && wzz < 10000",
                              (Char const   *)"m_syswrap/syswrap-linux.c", 2037,
                              (Char const   *)"vgSysWrap_linux_sys_timerfd_create_after",
                              "");
        }
        status->what = (enum __anonenum_what_129 )1;
        status->sres = vgPlain_mk_SysRes_Error((UWord )wzz);
        break;
      }
    }
  } else {
    tmp___9 = getRES(status);
    tmp___10 = vgModuleLocal_fd_allowed((Int )tmp___9,
                                        (Char const   *)"timerfd_create", tid,
                                        (Bool )1);
    if (tmp___10) {
      if (vgPlain_clo_track_fds) {
        tmp___8 = getRES(status);
        vgModuleLocal_record_fd_open_nameless(tid, (Int )tmp___8);
      } else {

      }
    } else {
      tmp___5 = getRES(status);
      vgPlain_close((Int )tmp___5);
      while (1) {
        wzz___0 = (Word )24;
        if (wzz___0 >= 0L) {
          if (wzz___0 < 10000L) {
            tmp___6 = 1;
          } else {
            tmp___6 = 0;
          }
        } else {
          tmp___6 = 0;
        }
        tmp___7 = __builtin_expect((long )tmp___6, 1L);
        if (tmp___7) {

        } else {
          vgPlain_assert_fail((Bool )1,
                              (Char const   *)"wzz >= 0 && wzz < 10000",
                              (Char const   *)"m_syswrap/syswrap-linux.c", 2048,
                              (Char const   *)"vgSysWrap_linux_sys_timerfd_create_after",
                              "");
        }
        status->what = (enum __anonenum_what_129 )1;
        status->sres = vgPlain_mk_SysRes_Error((UWord )wzz___0);
        break;
      }
    }
  }
  return;
}
}
void vgSysWrap_linux_sys_timerfd_gettime_before(ThreadId tid ,
                                                SyscallArgLayout *layout ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ,
                                                UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Word wzz ;
  int tmp___3 ;
  long tmp___4 ;
  Bool tmp___5 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_timerfd_gettime ( %ld, %#lx )", arrghs->arg1,
                   arrghs->arg2);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2061,
                            (Char const   *)"vgSysWrap_linux_sys_timerfd_gettime_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2061,
                            (Char const   *)"vgSysWrap_linux_sys_timerfd_gettime_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"timerfd_gettime(ufd)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(struct vki_itimerspec *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct vki_itimerspec*) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2061,
                            (Char const   *)"vgSysWrap_linux_sys_timerfd_gettime_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2061,
                            (Char const   *)"vgSysWrap_linux_sys_timerfd_gettime_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"timerfd_gettime(otmr)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(struct vki_itimerspec *));
      break;
    }
  } else {

  }
  tmp___5 = vgModuleLocal_fd_allowed((Int )arrghs->arg1,
                                     (Char const   *)"timerfd_gettime", tid,
                                     (Bool )0);
  if (tmp___5) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_write) {
        (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                               (Char *)"timerfd_gettime(result)",
                                               arrghs->arg2,
                                               (SizeT )sizeof(struct vki_itimerspec ));
      } else {

      }
      break;
    }
  } else {
    while (1) {
      wzz = (Word )9;
      if (wzz >= 0L) {
        if (wzz < 10000L) {
          tmp___3 = 1;
        } else {
          tmp___3 = 0;
        }
      } else {
        tmp___3 = 0;
      }
      tmp___4 = __builtin_expect((long )tmp___3, 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"wzz >= 0 && wzz < 10000",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2063,
                            (Char const   *)"vgSysWrap_linux_sys_timerfd_gettime_before",
                            "");
      }
      status->what = (enum __anonenum_what_129 )1;
      status->sres = vgPlain_mk_SysRes_Error((UWord )wzz);
      break;
    }
  }
  return;
}
}
void vgSysWrap_linux_sys_timerfd_gettime_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) 
{ 
  UWord tmp ;

  {
  tmp = getRES(status);
  if (tmp == 0UL) {
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg2,
                                                (SizeT )sizeof(struct vki_itimerspec ));
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_timerfd_settime_before(ThreadId tid ,
                                                SyscallArgLayout *layout ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ,
                                                UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;
  Word wzz ;
  int tmp___7 ;
  long tmp___8 ;
  Bool tmp___9 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_timerfd_settime ( %ld, %ld, %#lx, %#lx )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3, arrghs->arg4);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2081,
                            (Char const   *)"vgSysWrap_linux_sys_timerfd_settime_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2081,
                            (Char const   *)"vgSysWrap_linux_sys_timerfd_settime_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"timerfd_settime(ufd)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2081,
                            (Char const   *)"vgSysWrap_linux_sys_timerfd_settime_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2081,
                            (Char const   *)"vgSysWrap_linux_sys_timerfd_settime_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"timerfd_settime(flags)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(struct vki_itimerspec  const  *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const struct vki_itimerspec*) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2081,
                            (Char const   *)"vgSysWrap_linux_sys_timerfd_settime_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2081,
                            (Char const   *)"vgSysWrap_linux_sys_timerfd_settime_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"timerfd_settime(utmr)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(struct vki_itimerspec  const  *));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(struct vki_itimerspec *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct vki_itimerspec*) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2081,
                            (Char const   *)"vgSysWrap_linux_sys_timerfd_settime_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2081,
                            (Char const   *)"vgSysWrap_linux_sys_timerfd_settime_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"timerfd_settime(otmr)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(struct vki_itimerspec *));
      break;
    }
  } else {

  }
  tmp___9 = vgModuleLocal_fd_allowed((Int )arrghs->arg1,
                                     (Char const   *)"timerfd_settime", tid,
                                     (Bool )0);
  if (tmp___9) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"timerfd_settime(result)",
                                              arrghs->arg3,
                                              (SizeT )sizeof(struct vki_itimerspec ));
      } else {

      }
      break;
    }
    if (arrghs->arg4) {
      while (1) {
        if (vgPlain_tdict.track_pre_mem_write) {
          (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                                 (Char *)"timerfd_settime(result)",
                                                 arrghs->arg4,
                                                 (SizeT )sizeof(struct vki_itimerspec ));
        } else {

        }
        break;
      }
    } else {

    }
  } else {
    while (1) {
      wzz = (Word )9;
      if (wzz >= 0L) {
        if (wzz < 10000L) {
          tmp___7 = 1;
        } else {
          tmp___7 = 0;
        }
      } else {
        tmp___7 = 0;
      }
      tmp___8 = __builtin_expect((long )tmp___7, 1L);
      if (tmp___8) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"wzz >= 0 && wzz < 10000",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2083,
                            (Char const   *)"vgSysWrap_linux_sys_timerfd_settime_before",
                            "");
      }
      status->what = (enum __anonenum_what_129 )1;
      status->sres = vgPlain_mk_SysRes_Error((UWord )wzz);
      break;
    }
  }
  return;
}
}
void vgSysWrap_linux_sys_timerfd_settime_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) 
{ 
  UWord tmp ;

  {
  tmp = getRES(status);
  if (tmp == 0UL) {
    if (arrghs->arg4 != 0UL) {
      while (1) {
        if (vgPlain_tdict.track_post_mem_write) {
          (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                  arrghs->arg4,
                                                  (SizeT )sizeof(struct vki_itimerspec ));
        } else {

        }
        break;
      }
    } else {

    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_capget_before(ThreadId tid , SyscallArgLayout *layout ,
                                       SyscallArgs *arrghs ,
                                       SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_capget ( %#lx, %#lx )", arrghs->arg1, arrghs->arg2);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_cap_user_header_t ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_cap_user_header_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2109,
                            (Char const   *)"vgSysWrap_linux_sys_capget_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2109,
                            (Char const   *)"vgSysWrap_linux_sys_capget_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"capget(header)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_cap_user_header_t ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(vki_cap_user_data_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_cap_user_data_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2109,
                            (Char const   *)"vgSysWrap_linux_sys_capget_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2109,
                            (Char const   *)"vgSysWrap_linux_sys_capget_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"capget(data)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(vki_cap_user_data_t ));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"capget(header)",
                                            arrghs->arg1,
                                            (SizeT )sizeof(struct __vki_user_cap_header_struct ));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"capget(data)",
                                             arrghs->arg2,
                                             (SizeT )sizeof(struct __vki_user_cap_data_struct ));
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_capget_after(ThreadId tid , SyscallArgs *arrghs ,
                                      SyscallStatus *status ) 
{ 


  {
  if (arrghs->arg2 != (Addr )((void *)0)) {
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg2,
                                                (SizeT )sizeof(struct __vki_user_cap_data_struct ));
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_capset_before(ThreadId tid , SyscallArgLayout *layout ,
                                       SyscallArgs *arrghs ,
                                       SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_capset ( %#lx, %#lx )", arrghs->arg1, arrghs->arg2);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_cap_user_header_t ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_cap_user_header_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2126,
                            (Char const   *)"vgSysWrap_linux_sys_capset_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2126,
                            (Char const   *)"vgSysWrap_linux_sys_capset_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"capset(header)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_cap_user_header_t ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(vki_cap_user_data_t const   ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const vki_cap_user_data_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2126,
                            (Char const   *)"vgSysWrap_linux_sys_capset_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2126,
                            (Char const   *)"vgSysWrap_linux_sys_capset_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"capset(data)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(vki_cap_user_data_t const   ));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"capset(header)",
                                            arrghs->arg1,
                                            (SizeT )sizeof(struct __vki_user_cap_header_struct ));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"capset(data)",
                                            arrghs->arg2,
                                            (SizeT )sizeof(struct __vki_user_cap_data_struct ));
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_getuid16_before(ThreadId tid ,
                                         SyscallArgLayout *layout ,
                                         SyscallArgs *arrghs ,
                                         SyscallStatus *status , UWord *flags ) 
{ 


  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_getuid16 ( )");
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_setuid16_before(ThreadId tid ,
                                         SyscallArgLayout *layout ,
                                         SyscallArgs *arrghs ,
                                         SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_setuid16 ( %ld )", arrghs->arg1);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_old_uid_t ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_old_uid_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2146,
                            (Char const   *)"vgSysWrap_linux_sys_setuid16_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2146,
                            (Char const   *)"vgSysWrap_linux_sys_setuid16_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"setuid16(uid)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_old_uid_t ));
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_getgid16_before(ThreadId tid ,
                                         SyscallArgLayout *layout ,
                                         SyscallArgs *arrghs ,
                                         SyscallStatus *status , UWord *flags ) 
{ 


  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_getgid16 ( )");
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_setgid16_before(ThreadId tid ,
                                         SyscallArgLayout *layout ,
                                         SyscallArgs *arrghs ,
                                         SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_setgid16 ( %ld )", arrghs->arg1);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_old_gid_t ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_old_gid_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2158,
                            (Char const   *)"vgSysWrap_linux_sys_setgid16_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2158,
                            (Char const   *)"vgSysWrap_linux_sys_setgid16_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"setgid16(gid)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_old_gid_t ));
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_geteuid16_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) 
{ 


  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_geteuid16 ( )");
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_getegid16_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) 
{ 


  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_getegid16 ( )");
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_setreuid16_before(ThreadId tid ,
                                           SyscallArgLayout *layout ,
                                           SyscallArgs *arrghs ,
                                           SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("setreuid16 ( 0x%lx, 0x%lx )", arrghs->arg1, arrghs->arg2);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_old_uid_t ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_old_uid_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2176,
                            (Char const   *)"vgSysWrap_linux_sys_setreuid16_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2176,
                            (Char const   *)"vgSysWrap_linux_sys_setreuid16_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"setreuid16(ruid)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_old_uid_t ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(vki_old_uid_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_old_uid_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2176,
                            (Char const   *)"vgSysWrap_linux_sys_setreuid16_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2176,
                            (Char const   *)"vgSysWrap_linux_sys_setreuid16_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"setreuid16(euid)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(vki_old_uid_t ));
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_setregid16_before(ThreadId tid ,
                                           SyscallArgLayout *layout ,
                                           SyscallArgs *arrghs ,
                                           SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_setregid16 ( %ld, %ld )", arrghs->arg1, arrghs->arg2);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_old_gid_t ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_old_gid_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2182,
                            (Char const   *)"vgSysWrap_linux_sys_setregid16_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2182,
                            (Char const   *)"vgSysWrap_linux_sys_setregid16_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"setregid16(rgid)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_old_gid_t ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(vki_old_gid_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_old_gid_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2182,
                            (Char const   *)"vgSysWrap_linux_sys_setregid16_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2182,
                            (Char const   *)"vgSysWrap_linux_sys_setregid16_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"setregid16(egid)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(vki_old_gid_t ));
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_getgroups16_before(ThreadId tid ,
                                            SyscallArgLayout *layout ,
                                            SyscallArgs *arrghs ,
                                            SyscallStatus *status ,
                                            UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_getgroups16 ( %ld, %#lx )", arrghs->arg1, arrghs->arg2);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2188,
                            (Char const   *)"vgSysWrap_linux_sys_getgroups16_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2188,
                            (Char const   *)"vgSysWrap_linux_sys_getgroups16_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"getgroups16(size)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(vki_old_gid_t *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_old_gid_t *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2188,
                            (Char const   *)"vgSysWrap_linux_sys_getgroups16_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2188,
                            (Char const   *)"vgSysWrap_linux_sys_getgroups16_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"getgroups16(list)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(vki_old_gid_t *));
      break;
    }
  } else {

  }
  if (arrghs->arg1 > 0UL) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_write) {
        (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                               (Char *)"getgroups16(list)",
                                               arrghs->arg2,
                                               arrghs->arg1 * (UWord )sizeof(vki_old_gid_t ));
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_getgroups16_after(ThreadId tid , SyscallArgs *arrghs ,
                                           SyscallStatus *status ) 
{ 
  Bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  UWord tmp___2 ;
  UWord tmp___3 ;

  {
  if ((unsigned int )status->what == 1U) {
    tmp = sr_isError(status->sres);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
  } else {
    tmp___0 = 0;
  }
  tmp___1 = __builtin_expect((long )tmp___0, 1L);
  if (tmp___1) {

  } else {
    vgPlain_assert_fail((Bool )1, (Char const   *)"SUCCESS",
                        (Char const   *)"m_syswrap/syswrap-linux.c", 2194,
                        (Char const   *)"vgSysWrap_linux_sys_getgroups16_after",
                        "");
  }
  if (arrghs->arg1 > 0UL) {
    tmp___3 = getRES(status);
    if (tmp___3 > 0UL) {
      while (1) {
        if (vgPlain_tdict.track_post_mem_write) {
          tmp___2 = getRES(status);
          (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                  arrghs->arg2,
                                                  tmp___2 * (UWord )sizeof(vki_old_gid_t ));
        } else {

        }
        break;
      }
    } else {

    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_setgroups16_before(ThreadId tid ,
                                            SyscallArgLayout *layout ,
                                            SyscallArgs *arrghs ,
                                            SyscallStatus *status ,
                                            UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_setgroups16 ( %llu, %#lx )", (ULong )arrghs->arg1,
                   arrghs->arg2);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2202,
                            (Char const   *)"vgSysWrap_linux_sys_setgroups16_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2202,
                            (Char const   *)"vgSysWrap_linux_sys_setgroups16_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"setgroups16(size)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(vki_old_gid_t *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_old_gid_t *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2202,
                            (Char const   *)"vgSysWrap_linux_sys_setgroups16_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2202,
                            (Char const   *)"vgSysWrap_linux_sys_setgroups16_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"setgroups16(list)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(vki_old_gid_t *));
      break;
    }
  } else {

  }
  if (arrghs->arg1 > 0UL) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"setgroups16(list)",
                                              arrghs->arg2,
                                              arrghs->arg1 * (UWord )sizeof(vki_old_gid_t ));
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_chown16_before(ThreadId tid ,
                                        SyscallArgLayout *layout ,
                                        SyscallArgs *arrghs ,
                                        SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_chown16 ( %#lx, 0x%lx, 0x%lx )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(char const   *) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2216,
                            (Char const   *)"vgSysWrap_linux_sys_chown16_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2216,
                            (Char const   *)"vgSysWrap_linux_sys_chown16_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"chown16(path)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(char const   *));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(vki_old_uid_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_old_uid_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2216,
                            (Char const   *)"vgSysWrap_linux_sys_chown16_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2216,
                            (Char const   *)"vgSysWrap_linux_sys_chown16_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"chown16(owner)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(vki_old_uid_t ));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(vki_old_gid_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_old_gid_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2216,
                            (Char const   *)"vgSysWrap_linux_sys_chown16_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2216,
                            (Char const   *)"vgSysWrap_linux_sys_chown16_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"chown16(group)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(vki_old_gid_t ));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"chown16(path)",
                                                   arrghs->arg1);
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_fchown16_before(ThreadId tid ,
                                         SyscallArgLayout *layout ,
                                         SyscallArgs *arrghs ,
                                         SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_fchown16 ( %ld, %ld, %ld )", arrghs->arg1, arrghs->arg2,
                   arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2224,
                            (Char const   *)"vgSysWrap_linux_sys_fchown16_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2224,
                            (Char const   *)"vgSysWrap_linux_sys_fchown16_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fchown16(fd)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(vki_old_uid_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_old_uid_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2224,
                            (Char const   *)"vgSysWrap_linux_sys_fchown16_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2224,
                            (Char const   *)"vgSysWrap_linux_sys_fchown16_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fchown16(owner)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(vki_old_uid_t ));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(vki_old_gid_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_old_gid_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2224,
                            (Char const   *)"vgSysWrap_linux_sys_fchown16_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2224,
                            (Char const   *)"vgSysWrap_linux_sys_fchown16_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fchown16(group)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(vki_old_gid_t ));
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_setxattr_before(ThreadId tid ,
                                         SyscallArgLayout *layout ,
                                         SyscallArgs *arrghs ,
                                         SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;
  Int here___3 ;
  long tmp___7 ;
  long tmp___8 ;

  {
  *flags |= (unsigned long )(1 << 1);
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_setxattr ( %#lx, %#lx, %#lx, %llu, %ld )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3, (ULong )arrghs->arg4,
                   arrghs->arg5);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(char *) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2238,
                            (Char const   *)"vgSysWrap_linux_sys_setxattr_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2238,
                            (Char const   *)"vgSysWrap_linux_sys_setxattr_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"setxattr(path)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(char *));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(char *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2238,
                            (Char const   *)"vgSysWrap_linux_sys_setxattr_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2238,
                            (Char const   *)"vgSysWrap_linux_sys_setxattr_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"setxattr(name)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(char *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(void *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(void *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2238,
                            (Char const   *)"vgSysWrap_linux_sys_setxattr_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2238,
                            (Char const   *)"vgSysWrap_linux_sys_setxattr_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"setxattr(value)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(void *));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(vki_size_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_size_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2238,
                            (Char const   *)"vgSysWrap_linux_sys_setxattr_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2238,
                            (Char const   *)"vgSysWrap_linux_sys_setxattr_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"setxattr(size)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(vki_size_t ));
      break;
    }
    while (1) {
      here___3 = layout->o_arg5;
      tmp___7 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___7) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2238,
                            (Char const   *)"vgSysWrap_linux_sys_setxattr_before",
                            "");
      }
      tmp___8 = __builtin_expect((long )(! (! (here___3 >= 0))), 1L);
      if (tmp___8) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2238,
                            (Char const   *)"vgSysWrap_linux_sys_setxattr_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"setxattr(flags)",
                                            (PtrdiffT )here___3,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"setxattr(path)",
                                                   arrghs->arg1);
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"setxattr(name)",
                                                   arrghs->arg2);
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"setxattr(value)",
                                            arrghs->arg3, arrghs->arg4);
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_lsetxattr_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;
  Int here___3 ;
  long tmp___7 ;
  long tmp___8 ;

  {
  *flags |= (unsigned long )(1 << 1);
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_lsetxattr ( %#lx, %#lx, %#lx, %llu, %ld )",
                   arrghs->arg1, arrghs->arg2, arrghs->arg3,
                   (ULong )arrghs->arg4, arrghs->arg5);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(char *) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2251,
                            (Char const   *)"vgSysWrap_linux_sys_lsetxattr_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2251,
                            (Char const   *)"vgSysWrap_linux_sys_lsetxattr_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"lsetxattr(path)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(char *));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(char *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2251,
                            (Char const   *)"vgSysWrap_linux_sys_lsetxattr_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2251,
                            (Char const   *)"vgSysWrap_linux_sys_lsetxattr_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"lsetxattr(name)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(char *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(void *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(void *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2251,
                            (Char const   *)"vgSysWrap_linux_sys_lsetxattr_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2251,
                            (Char const   *)"vgSysWrap_linux_sys_lsetxattr_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"lsetxattr(value)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(void *));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(vki_size_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_size_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2251,
                            (Char const   *)"vgSysWrap_linux_sys_lsetxattr_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2251,
                            (Char const   *)"vgSysWrap_linux_sys_lsetxattr_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"lsetxattr(size)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(vki_size_t ));
      break;
    }
    while (1) {
      here___3 = layout->o_arg5;
      tmp___7 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___7) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2251,
                            (Char const   *)"vgSysWrap_linux_sys_lsetxattr_before",
                            "");
      }
      tmp___8 = __builtin_expect((long )(! (! (here___3 >= 0))), 1L);
      if (tmp___8) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2251,
                            (Char const   *)"vgSysWrap_linux_sys_lsetxattr_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"lsetxattr(flags)",
                                            (PtrdiffT )here___3,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"lsetxattr(path)",
                                                   arrghs->arg1);
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"lsetxattr(name)",
                                                   arrghs->arg2);
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"lsetxattr(value)",
                                            arrghs->arg3, arrghs->arg4);
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_fsetxattr_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;
  Int here___3 ;
  long tmp___7 ;
  long tmp___8 ;

  {
  *flags |= (unsigned long )(1 << 1);
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_fsetxattr ( %ld, %#lx, %#lx, %llu, %ld )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3, (ULong )arrghs->arg4,
                   arrghs->arg5);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2264,
                            (Char const   *)"vgSysWrap_linux_sys_fsetxattr_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2264,
                            (Char const   *)"vgSysWrap_linux_sys_fsetxattr_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fsetxattr(fd)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(char *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2264,
                            (Char const   *)"vgSysWrap_linux_sys_fsetxattr_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2264,
                            (Char const   *)"vgSysWrap_linux_sys_fsetxattr_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fsetxattr(name)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(char *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(void *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(void *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2264,
                            (Char const   *)"vgSysWrap_linux_sys_fsetxattr_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2264,
                            (Char const   *)"vgSysWrap_linux_sys_fsetxattr_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fsetxattr(value)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(void *));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(vki_size_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_size_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2264,
                            (Char const   *)"vgSysWrap_linux_sys_fsetxattr_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2264,
                            (Char const   *)"vgSysWrap_linux_sys_fsetxattr_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fsetxattr(size)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(vki_size_t ));
      break;
    }
    while (1) {
      here___3 = layout->o_arg5;
      tmp___7 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___7) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2264,
                            (Char const   *)"vgSysWrap_linux_sys_fsetxattr_before",
                            "");
      }
      tmp___8 = __builtin_expect((long )(! (! (here___3 >= 0))), 1L);
      if (tmp___8) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2264,
                            (Char const   *)"vgSysWrap_linux_sys_fsetxattr_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fsetxattr(flags)",
                                            (PtrdiffT )here___3,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"fsetxattr(name)",
                                                   arrghs->arg2);
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"fsetxattr(value)",
                                            arrghs->arg3, arrghs->arg4);
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_getxattr_before(ThreadId tid ,
                                         SyscallArgLayout *layout ,
                                         SyscallArgs *arrghs ,
                                         SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;

  {
  *flags |= (unsigned long )(1 << 1);
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_getxattr ( %#lx, %#lx, %#lx, %llu )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3, (ULong )arrghs->arg4);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(char *) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2274,
                            (Char const   *)"vgSysWrap_linux_sys_getxattr_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2274,
                            (Char const   *)"vgSysWrap_linux_sys_getxattr_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"getxattr(path)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(char *));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(char *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2274,
                            (Char const   *)"vgSysWrap_linux_sys_getxattr_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2274,
                            (Char const   *)"vgSysWrap_linux_sys_getxattr_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"getxattr(name)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(char *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(void *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(void *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2274,
                            (Char const   *)"vgSysWrap_linux_sys_getxattr_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2274,
                            (Char const   *)"vgSysWrap_linux_sys_getxattr_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"getxattr(value)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(void *));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(vki_size_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_size_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2274,
                            (Char const   *)"vgSysWrap_linux_sys_getxattr_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2274,
                            (Char const   *)"vgSysWrap_linux_sys_getxattr_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"getxattr(size)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(vki_size_t ));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"getxattr(path)",
                                                   arrghs->arg1);
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"getxattr(name)",
                                                   arrghs->arg2);
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"getxattr(value)",
                                             arrghs->arg3, arrghs->arg4);
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_getxattr_after(ThreadId tid , SyscallArgs *arrghs ,
                                        SyscallStatus *status ) 
{ 
  Bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  UWord tmp___2 ;
  UWord tmp___3 ;

  {
  if ((unsigned int )status->what == 1U) {
    tmp = sr_isError(status->sres);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
  } else {
    tmp___0 = 0;
  }
  tmp___1 = __builtin_expect((long )tmp___0, 1L);
  if (tmp___1) {

  } else {
    vgPlain_assert_fail((Bool )1, (Char const   *)"SUCCESS",
                        (Char const   *)"m_syswrap/syswrap-linux.c", 2281,
                        (Char const   *)"vgSysWrap_linux_sys_getxattr_after", "");
  }
  tmp___3 = getRES(status);
  if (tmp___3 > 0UL) {
    if (arrghs->arg3 != (Addr )((void *)0)) {
      while (1) {
        if (vgPlain_tdict.track_post_mem_write) {
          tmp___2 = getRES(status);
          (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                  arrghs->arg3, tmp___2);
        } else {

        }
        break;
      }
    } else {

    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_lgetxattr_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;

  {
  *flags |= (unsigned long )(1 << 1);
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_lgetxattr ( %#lx, %#lx, %#lx, %llu )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3, (ULong )arrghs->arg4);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(char *) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2292,
                            (Char const   *)"vgSysWrap_linux_sys_lgetxattr_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2292,
                            (Char const   *)"vgSysWrap_linux_sys_lgetxattr_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"lgetxattr(path)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(char *));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(char *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2292,
                            (Char const   *)"vgSysWrap_linux_sys_lgetxattr_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2292,
                            (Char const   *)"vgSysWrap_linux_sys_lgetxattr_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"lgetxattr(name)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(char *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(void *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(void *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2292,
                            (Char const   *)"vgSysWrap_linux_sys_lgetxattr_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2292,
                            (Char const   *)"vgSysWrap_linux_sys_lgetxattr_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"lgetxattr(value)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(void *));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(vki_size_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_size_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2292,
                            (Char const   *)"vgSysWrap_linux_sys_lgetxattr_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2292,
                            (Char const   *)"vgSysWrap_linux_sys_lgetxattr_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"lgetxattr(size)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(vki_size_t ));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"lgetxattr(path)",
                                                   arrghs->arg1);
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"lgetxattr(name)",
                                                   arrghs->arg2);
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"lgetxattr(value)",
                                             arrghs->arg3, arrghs->arg4);
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_lgetxattr_after(ThreadId tid , SyscallArgs *arrghs ,
                                         SyscallStatus *status ) 
{ 
  Bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  UWord tmp___2 ;
  UWord tmp___3 ;

  {
  if ((unsigned int )status->what == 1U) {
    tmp = sr_isError(status->sres);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
  } else {
    tmp___0 = 0;
  }
  tmp___1 = __builtin_expect((long )tmp___0, 1L);
  if (tmp___1) {

  } else {
    vgPlain_assert_fail((Bool )1, (Char const   *)"SUCCESS",
                        (Char const   *)"m_syswrap/syswrap-linux.c", 2299,
                        (Char const   *)"vgSysWrap_linux_sys_lgetxattr_after",
                        "");
  }
  tmp___3 = getRES(status);
  if (tmp___3 > 0UL) {
    if (arrghs->arg3 != (Addr )((void *)0)) {
      while (1) {
        if (vgPlain_tdict.track_post_mem_write) {
          tmp___2 = getRES(status);
          (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                  arrghs->arg3, tmp___2);
        } else {

        }
        break;
      }
    } else {

    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_fgetxattr_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;

  {
  *flags |= (unsigned long )(1 << 1);
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_fgetxattr ( %ld, %#lx, %#lx, %llu )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3, (ULong )arrghs->arg4);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2310,
                            (Char const   *)"vgSysWrap_linux_sys_fgetxattr_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2310,
                            (Char const   *)"vgSysWrap_linux_sys_fgetxattr_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fgetxattr(fd)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(char *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2310,
                            (Char const   *)"vgSysWrap_linux_sys_fgetxattr_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2310,
                            (Char const   *)"vgSysWrap_linux_sys_fgetxattr_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fgetxattr(name)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(char *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(void *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(void *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2310,
                            (Char const   *)"vgSysWrap_linux_sys_fgetxattr_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2310,
                            (Char const   *)"vgSysWrap_linux_sys_fgetxattr_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fgetxattr(value)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(void *));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(vki_size_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_size_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2310,
                            (Char const   *)"vgSysWrap_linux_sys_fgetxattr_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2310,
                            (Char const   *)"vgSysWrap_linux_sys_fgetxattr_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fgetxattr(size)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(vki_size_t ));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"fgetxattr(name)",
                                                   arrghs->arg2);
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"fgetxattr(value)",
                                             arrghs->arg3, arrghs->arg4);
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_fgetxattr_after(ThreadId tid , SyscallArgs *arrghs ,
                                         SyscallStatus *status ) 
{ 
  UWord tmp ;
  UWord tmp___0 ;

  {
  tmp___0 = getRES(status);
  if (tmp___0 > 0UL) {
    if (arrghs->arg3 != (Addr )((void *)0)) {
      while (1) {
        if (vgPlain_tdict.track_post_mem_write) {
          tmp = getRES(status);
          (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                  arrghs->arg3, tmp);
        } else {

        }
        break;
      }
    } else {

    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_listxattr_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  *flags |= (unsigned long )(1 << 1);
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_listxattr ( %#lx, %#lx, %llu )", arrghs->arg1,
                   arrghs->arg2, (ULong )arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(char *) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2325,
                            (Char const   *)"vgSysWrap_linux_sys_listxattr_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2325,
                            (Char const   *)"vgSysWrap_linux_sys_listxattr_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"listxattr(path)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(char *));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(char *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2325,
                            (Char const   *)"vgSysWrap_linux_sys_listxattr_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2325,
                            (Char const   *)"vgSysWrap_linux_sys_listxattr_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"listxattr(list)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(char *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(vki_size_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_size_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2325,
                            (Char const   *)"vgSysWrap_linux_sys_listxattr_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2325,
                            (Char const   *)"vgSysWrap_linux_sys_listxattr_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"listxattr(size)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(vki_size_t ));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"listxattr(path)",
                                                   arrghs->arg1);
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"listxattr(list)",
                                             arrghs->arg2, arrghs->arg3);
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_listxattr_after(ThreadId tid , SyscallArgs *arrghs ,
                                         SyscallStatus *status ) 
{ 
  UWord tmp ;
  UWord tmp___0 ;

  {
  tmp___0 = getRES(status);
  if (tmp___0 > 0UL) {
    if (arrghs->arg2 != (Addr )((void *)0)) {
      while (1) {
        if (vgPlain_tdict.track_post_mem_write) {
          tmp = getRES(status);
          (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                  arrghs->arg2, tmp);
        } else {

        }
        break;
      }
    } else {

    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_llistxattr_before(ThreadId tid ,
                                           SyscallArgLayout *layout ,
                                           SyscallArgs *arrghs ,
                                           SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  *flags |= (unsigned long )(1 << 1);
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_llistxattr ( %#lx, %#lx, %llu )", arrghs->arg1,
                   arrghs->arg2, (ULong )arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(char *) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2340,
                            (Char const   *)"vgSysWrap_linux_sys_llistxattr_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2340,
                            (Char const   *)"vgSysWrap_linux_sys_llistxattr_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"llistxattr(path)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(char *));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(char *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2340,
                            (Char const   *)"vgSysWrap_linux_sys_llistxattr_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2340,
                            (Char const   *)"vgSysWrap_linux_sys_llistxattr_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"llistxattr(list)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(char *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(vki_size_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_size_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2340,
                            (Char const   *)"vgSysWrap_linux_sys_llistxattr_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2340,
                            (Char const   *)"vgSysWrap_linux_sys_llistxattr_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"llistxattr(size)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(vki_size_t ));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"llistxattr(path)",
                                                   arrghs->arg1);
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"llistxattr(list)",
                                             arrghs->arg2, arrghs->arg3);
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_llistxattr_after(ThreadId tid , SyscallArgs *arrghs ,
                                          SyscallStatus *status ) 
{ 
  UWord tmp ;
  UWord tmp___0 ;

  {
  tmp___0 = getRES(status);
  if (tmp___0 > 0UL) {
    if (arrghs->arg2 != (Addr )((void *)0)) {
      while (1) {
        if (vgPlain_tdict.track_post_mem_write) {
          tmp = getRES(status);
          (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                  arrghs->arg2, tmp);
        } else {

        }
        break;
      }
    } else {

    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_flistxattr_before(ThreadId tid ,
                                           SyscallArgLayout *layout ,
                                           SyscallArgs *arrghs ,
                                           SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  *flags |= (unsigned long )(1 << 1);
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_flistxattr ( %ld, %#lx, %llu )", arrghs->arg1,
                   arrghs->arg2, (ULong )arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2355,
                            (Char const   *)"vgSysWrap_linux_sys_flistxattr_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2355,
                            (Char const   *)"vgSysWrap_linux_sys_flistxattr_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"flistxattr(fd)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(char *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2355,
                            (Char const   *)"vgSysWrap_linux_sys_flistxattr_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2355,
                            (Char const   *)"vgSysWrap_linux_sys_flistxattr_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"flistxattr(list)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(char *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(vki_size_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_size_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2355,
                            (Char const   *)"vgSysWrap_linux_sys_flistxattr_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2355,
                            (Char const   *)"vgSysWrap_linux_sys_flistxattr_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"flistxattr(size)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(vki_size_t ));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"flistxattr(list)",
                                             arrghs->arg2, arrghs->arg3);
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_flistxattr_after(ThreadId tid , SyscallArgs *arrghs ,
                                          SyscallStatus *status ) 
{ 
  UWord tmp ;
  UWord tmp___0 ;

  {
  tmp___0 = getRES(status);
  if (tmp___0 > 0UL) {
    if (arrghs->arg2 != (Addr )((void *)0)) {
      while (1) {
        if (vgPlain_tdict.track_post_mem_write) {
          tmp = getRES(status);
          (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                  arrghs->arg2, tmp);
        } else {

        }
        break;
      }
    } else {

    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_removexattr_before(ThreadId tid ,
                                            SyscallArgLayout *layout ,
                                            SyscallArgs *arrghs ,
                                            SyscallStatus *status ,
                                            UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  *flags |= (unsigned long )(1 << 1);
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_removexattr ( %#lx, %#lx )", arrghs->arg1, arrghs->arg2);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(char *) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2368,
                            (Char const   *)"vgSysWrap_linux_sys_removexattr_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2368,
                            (Char const   *)"vgSysWrap_linux_sys_removexattr_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"removexattr(path)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(char *));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(char *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2368,
                            (Char const   *)"vgSysWrap_linux_sys_removexattr_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2368,
                            (Char const   *)"vgSysWrap_linux_sys_removexattr_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"removexattr(name)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(char *));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"removexattr(path)",
                                                   arrghs->arg1);
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"removexattr(name)",
                                                   arrghs->arg2);
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_lremovexattr_before(ThreadId tid ,
                                             SyscallArgLayout *layout ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ,
                                             UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  *flags |= (unsigned long )(1 << 1);
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_lremovexattr ( %#lx, %#lx )", arrghs->arg1, arrghs->arg2);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(char *) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2377,
                            (Char const   *)"vgSysWrap_linux_sys_lremovexattr_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2377,
                            (Char const   *)"vgSysWrap_linux_sys_lremovexattr_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"lremovexattr(path)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(char *));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(char *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2377,
                            (Char const   *)"vgSysWrap_linux_sys_lremovexattr_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2377,
                            (Char const   *)"vgSysWrap_linux_sys_lremovexattr_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"lremovexattr(name)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(char *));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"lremovexattr(path)",
                                                   arrghs->arg1);
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"lremovexattr(name)",
                                                   arrghs->arg2);
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_fremovexattr_before(ThreadId tid ,
                                             SyscallArgLayout *layout ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ,
                                             UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  *flags |= (unsigned long )(1 << 1);
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_fremovexattr ( %ld, %#lx )", arrghs->arg1, arrghs->arg2);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2386,
                            (Char const   *)"vgSysWrap_linux_sys_fremovexattr_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2386,
                            (Char const   *)"vgSysWrap_linux_sys_fremovexattr_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fremovexattr(fd)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(char *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2386,
                            (Char const   *)"vgSysWrap_linux_sys_fremovexattr_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2386,
                            (Char const   *)"vgSysWrap_linux_sys_fremovexattr_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fremovexattr(name)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(char *));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"fremovexattr(name)",
                                                   arrghs->arg2);
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_sched_setparam_before(ThreadId tid ,
                                               SyscallArgLayout *layout ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ,
                                               UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sched_setparam ( %ld, %#lx )", arrghs->arg1, arrghs->arg2);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_pid_t ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_pid_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2398,
                            (Char const   *)"vgSysWrap_linux_sys_sched_setparam_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2398,
                            (Char const   *)"vgSysWrap_linux_sys_sched_setparam_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sched_setparam(pid)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_pid_t ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(struct sched_param *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct sched_param *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2398,
                            (Char const   *)"vgSysWrap_linux_sys_sched_setparam_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2398,
                            (Char const   *)"vgSysWrap_linux_sys_sched_setparam_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sched_setparam(p)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(struct sched_param *));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"sched_setparam(p)",
                                            arrghs->arg2,
                                            (SizeT )sizeof(struct vki_sched_param ));
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_sched_setparam_after(ThreadId tid ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ) 
{ 


  {
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg2,
                                              (SizeT )sizeof(struct vki_sched_param ));
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_sched_getparam_before(ThreadId tid ,
                                               SyscallArgLayout *layout ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ,
                                               UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sched_getparam ( %ld, %#lx )", arrghs->arg1, arrghs->arg2);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_pid_t ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_pid_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2410,
                            (Char const   *)"vgSysWrap_linux_sys_sched_getparam_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2410,
                            (Char const   *)"vgSysWrap_linux_sys_sched_getparam_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sched_getparam(pid)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_pid_t ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(struct sched_param *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct sched_param *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2410,
                            (Char const   *)"vgSysWrap_linux_sys_sched_getparam_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2410,
                            (Char const   *)"vgSysWrap_linux_sys_sched_getparam_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sched_getparam(p)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(struct sched_param *));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"sched_getparam(p)",
                                             arrghs->arg2,
                                             (SizeT )sizeof(struct vki_sched_param ));
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_sched_getparam_after(ThreadId tid ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ) 
{ 


  {
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg2,
                                              (SizeT )sizeof(struct vki_sched_param ));
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_sched_getscheduler_before(ThreadId tid ,
                                                   SyscallArgLayout *layout ,
                                                   SyscallArgs *arrghs ,
                                                   SyscallStatus *status ,
                                                   UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_sched_getscheduler ( %ld )", arrghs->arg1);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_pid_t ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_pid_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2421,
                            (Char const   *)"vgSysWrap_linux_sys_sched_getscheduler_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2421,
                            (Char const   *)"vgSysWrap_linux_sys_sched_getscheduler_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sched_getscheduler(pid)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_pid_t ));
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_sched_setscheduler_before(ThreadId tid ,
                                                   SyscallArgLayout *layout ,
                                                   SyscallArgs *arrghs ,
                                                   SyscallStatus *status ,
                                                   UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_sched_setscheduler ( %ld, %ld, %#lx )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_pid_t ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_pid_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2428,
                            (Char const   *)"vgSysWrap_linux_sys_sched_setscheduler_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2428,
                            (Char const   *)"vgSysWrap_linux_sys_sched_setscheduler_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sched_setscheduler(pid)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_pid_t ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2428,
                            (Char const   *)"vgSysWrap_linux_sys_sched_setscheduler_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2428,
                            (Char const   *)"vgSysWrap_linux_sys_sched_setscheduler_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sched_setscheduler(policy)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(struct sched_param *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct sched_param *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2428,
                            (Char const   *)"vgSysWrap_linux_sys_sched_setscheduler_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2428,
                            (Char const   *)"vgSysWrap_linux_sys_sched_setscheduler_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sched_setscheduler(p)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(struct sched_param *));
      break;
    }
  } else {

  }
  if (arrghs->arg3 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"sched_setscheduler(p)",
                                              arrghs->arg3,
                                              (SizeT )sizeof(struct vki_sched_param ));
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_sched_yield_before(ThreadId tid ,
                                            SyscallArgLayout *layout ,
                                            SyscallArgs *arrghs ,
                                            SyscallStatus *status ,
                                            UWord *flags ) 
{ 


  {
  *flags |= (unsigned long )(1 << 1);
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sched_yield()");
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_sched_get_priority_max_before(ThreadId tid ,
                                                       SyscallArgLayout *layout ,
                                                       SyscallArgs *arrghs ,
                                                       SyscallStatus *status ,
                                                       UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sched_get_priority_max ( %ld )", arrghs->arg1);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2444,
                            (Char const   *)"vgSysWrap_linux_sys_sched_get_priority_max_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2444,
                            (Char const   *)"vgSysWrap_linux_sys_sched_get_priority_max_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sched_get_priority_max(policy)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_sched_get_priority_min_before(ThreadId tid ,
                                                       SyscallArgLayout *layout ,
                                                       SyscallArgs *arrghs ,
                                                       SyscallStatus *status ,
                                                       UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sched_get_priority_min ( %ld )", arrghs->arg1);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2450,
                            (Char const   *)"vgSysWrap_linux_sys_sched_get_priority_min_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2450,
                            (Char const   *)"vgSysWrap_linux_sys_sched_get_priority_min_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sched_get_priority_min(policy)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_sched_rr_get_interval_before(ThreadId tid ,
                                                      SyscallArgLayout *layout ,
                                                      SyscallArgs *arrghs ,
                                                      SyscallStatus *status ,
                                                      UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_sched_rr_get_interval ( %ld, %#lx )", arrghs->arg1,
                   arrghs->arg2);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_pid_t ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_pid_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2458,
                            (Char const   *)"vgSysWrap_linux_sys_sched_rr_get_interval_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2458,
                            (Char const   *)"vgSysWrap_linux_sys_sched_rr_get_interval_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sched_rr_get_interval(pid)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_pid_t ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(struct vki_timespec *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct vki_timespec *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2458,
                            (Char const   *)"vgSysWrap_linux_sys_sched_rr_get_interval_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2458,
                            (Char const   *)"vgSysWrap_linux_sys_sched_rr_get_interval_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sched_rr_get_interval(tp)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(struct vki_timespec *));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"sched_rr_get_interval(timespec)",
                                             arrghs->arg2,
                                             (SizeT )sizeof(struct vki_timespec ));
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_sched_rr_get_interval_after(ThreadId tid ,
                                                     SyscallArgs *arrghs ,
                                                     SyscallStatus *status ) 
{ 


  {
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg2,
                                              (SizeT )sizeof(struct vki_timespec ));
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_sched_setaffinity_before(ThreadId tid ,
                                                  SyscallArgLayout *layout ,
                                                  SyscallArgs *arrghs ,
                                                  SyscallStatus *status ,
                                                  UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sched_setaffinity ( %ld, %ld, %#lx )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_pid_t ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_pid_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2472,
                            (Char const   *)"vgSysWrap_linux_sys_sched_setaffinity_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2472,
                            (Char const   *)"vgSysWrap_linux_sys_sched_setaffinity_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sched_setaffinity(pid)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_pid_t ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2472,
                            (Char const   *)"vgSysWrap_linux_sys_sched_setaffinity_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2472,
                            (Char const   *)"vgSysWrap_linux_sys_sched_setaffinity_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sched_setaffinity(len)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(unsigned long *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned long *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2472,
                            (Char const   *)"vgSysWrap_linux_sys_sched_setaffinity_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2472,
                            (Char const   *)"vgSysWrap_linux_sys_sched_setaffinity_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sched_setaffinity(mask)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(unsigned long *));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"sched_setaffinity(mask)",
                                            arrghs->arg3, arrghs->arg2);
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_sched_getaffinity_before(ThreadId tid ,
                                                  SyscallArgLayout *layout ,
                                                  SyscallArgs *arrghs ,
                                                  SyscallStatus *status ,
                                                  UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sched_getaffinity ( %ld, %ld, %#lx )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_pid_t ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_pid_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2480,
                            (Char const   *)"vgSysWrap_linux_sys_sched_getaffinity_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2480,
                            (Char const   *)"vgSysWrap_linux_sys_sched_getaffinity_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sched_getaffinity(pid)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_pid_t ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2480,
                            (Char const   *)"vgSysWrap_linux_sys_sched_getaffinity_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2480,
                            (Char const   *)"vgSysWrap_linux_sys_sched_getaffinity_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sched_getaffinity(len)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(unsigned long *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned long *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2480,
                            (Char const   *)"vgSysWrap_linux_sys_sched_getaffinity_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2480,
                            (Char const   *)"vgSysWrap_linux_sys_sched_getaffinity_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sched_getaffinity(mask)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(unsigned long *));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"sched_getaffinity(mask)",
                                             arrghs->arg3, arrghs->arg2);
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_sched_getaffinity_after(ThreadId tid ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ) 
{ 


  {
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              arrghs->arg2);
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_munlockall_before(ThreadId tid ,
                                           SyscallArgLayout *layout ,
                                           SyscallArgs *arrghs ,
                                           SyscallStatus *status , UWord *flags ) 
{ 


  {
  *flags |= (unsigned long )(1 << 1);
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_munlockall ( )");
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_pipe_before(ThreadId tid , SyscallArgLayout *layout ,
                                     SyscallArgs *arrghs ,
                                     SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_pipe ( %#lx )", arrghs->arg1);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int *) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2514,
                            (Char const   *)"vgSysWrap_linux_sys_pipe_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2514,
                            (Char const   *)"vgSysWrap_linux_sys_pipe_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"pipe(filedes)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int *));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"pipe(filedes)",
                                             arrghs->arg1,
                                             (SizeT )(2U * sizeof(int )));
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_pipe_after(ThreadId tid , SyscallArgs *arrghs ,
                                    SyscallStatus *status ) 
{ 
  Int *p ;
  Word wzz ;
  int tmp ;
  long tmp___0 ;
  Bool tmp___1 ;
  Bool tmp___2 ;

  {
  p = (Int *)arrghs->arg1;
  tmp___1 = vgModuleLocal_fd_allowed(*(p + 0), (Char const   *)"pipe", tid,
                                     (Bool )1);
  if (tmp___1) {
    tmp___2 = vgModuleLocal_fd_allowed(*(p + 1), (Char const   *)"pipe", tid,
                                       (Bool )1);
    if (tmp___2) {
      while (1) {
        if (vgPlain_tdict.track_post_mem_write) {
          (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                  arrghs->arg1,
                                                  (SizeT )(2U * sizeof(int )));
        } else {

        }
        break;
      }
      if (vgPlain_clo_track_fds) {
        vgModuleLocal_record_fd_open_nameless(tid, *(p + 0));
        vgModuleLocal_record_fd_open_nameless(tid, *(p + 1));
      } else {

      }
    } else {
      _L: /* CIL Label */ 
      vgPlain_close(*(p + 0));
      vgPlain_close(*(p + 1));
      while (1) {
        wzz = (Word )24;
        if (wzz >= 0L) {
          if (wzz < 10000L) {
            tmp = 1;
          } else {
            tmp = 0;
          }
        } else {
          tmp = 0;
        }
        tmp___0 = __builtin_expect((long )tmp, 1L);
        if (tmp___0) {

        } else {
          vgPlain_assert_fail((Bool )1,
                              (Char const   *)"wzz >= 0 && wzz < 10000",
                              (Char const   *)"m_syswrap/syswrap-linux.c", 2524,
                              (Char const   *)"vgSysWrap_linux_sys_pipe_after",
                              "");
        }
        status->what = (enum __anonenum_what_129 )1;
        status->sres = vgPlain_mk_SysRes_Error((UWord )wzz);
        break;
      }
    }
  } else {
    goto _L;
  }
  return;
}
}
void vgSysWrap_linux_sys_pipe2_before(ThreadId tid , SyscallArgLayout *layout ,
                                      SyscallArgs *arrghs ,
                                      SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_pipe2 ( %#lx, %#lx )", arrghs->arg1, arrghs->arg2);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int *) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2541,
                            (Char const   *)"vgSysWrap_linux_sys_pipe2_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2541,
                            (Char const   *)"vgSysWrap_linux_sys_pipe2_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"pipe(filedes)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int *));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(long ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(long) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2541,
                            (Char const   *)"vgSysWrap_linux_sys_pipe2_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2541,
                            (Char const   *)"vgSysWrap_linux_sys_pipe2_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"pipe(flags)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(long ));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"pipe2(filedes)",
                                             arrghs->arg1,
                                             (SizeT )(2U * sizeof(int )));
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_pipe2_after(ThreadId tid , SyscallArgs *arrghs ,
                                     SyscallStatus *status ) 
{ 
  Int *p ;
  Word wzz ;
  int tmp ;
  long tmp___0 ;
  Bool tmp___1 ;
  Bool tmp___2 ;

  {
  p = (Int *)arrghs->arg1;
  tmp___1 = vgModuleLocal_fd_allowed(*(p + 0), (Char const   *)"pipe2", tid,
                                     (Bool )1);
  if (tmp___1) {
    tmp___2 = vgModuleLocal_fd_allowed(*(p + 1), (Char const   *)"pipe2", tid,
                                       (Bool )1);
    if (tmp___2) {
      while (1) {
        if (vgPlain_tdict.track_post_mem_write) {
          (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                  arrghs->arg1,
                                                  (SizeT )(2U * sizeof(int )));
        } else {

        }
        break;
      }
      if (vgPlain_clo_track_fds) {
        vgModuleLocal_record_fd_open_nameless(tid, *(p + 0));
        vgModuleLocal_record_fd_open_nameless(tid, *(p + 1));
      } else {

      }
    } else {
      _L: /* CIL Label */ 
      vgPlain_close(*(p + 0));
      vgPlain_close(*(p + 1));
      while (1) {
        wzz = (Word )24;
        if (wzz >= 0L) {
          if (wzz < 10000L) {
            tmp = 1;
          } else {
            tmp = 0;
          }
        } else {
          tmp = 0;
        }
        tmp___0 = __builtin_expect((long )tmp, 1L);
        if (tmp___0) {

        } else {
          vgPlain_assert_fail((Bool )1,
                              (Char const   *)"wzz >= 0 && wzz < 10000",
                              (Char const   *)"m_syswrap/syswrap-linux.c", 2551,
                              (Char const   *)"vgSysWrap_linux_sys_pipe2_after",
                              "");
        }
        status->what = (enum __anonenum_what_129 )1;
        status->sres = vgPlain_mk_SysRes_Error((UWord )wzz);
        break;
      }
    }
  } else {
    goto _L;
  }
  return;
}
}
void vgSysWrap_linux_sys_dup3_before(ThreadId tid , SyscallArgLayout *layout ,
                                     SyscallArgs *arrghs ,
                                     SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Word wzz ;
  int tmp___5 ;
  long tmp___6 ;
  Bool tmp___7 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_dup3 ( %ld, %ld, %ld )", arrghs->arg1, arrghs->arg2,
                   arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2564,
                            (Char const   *)"vgSysWrap_linux_sys_dup3_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2564,
                            (Char const   *)"vgSysWrap_linux_sys_dup3_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"dup3(oldfd)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2564,
                            (Char const   *)"vgSysWrap_linux_sys_dup3_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2564,
                            (Char const   *)"vgSysWrap_linux_sys_dup3_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"dup3(newfd)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2564,
                            (Char const   *)"vgSysWrap_linux_sys_dup3_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2564,
                            (Char const   *)"vgSysWrap_linux_sys_dup3_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"dup3(flags)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  tmp___7 = vgModuleLocal_fd_allowed((Int )arrghs->arg2, (Char const   *)"dup3",
                                     tid, (Bool )1);
  if (tmp___7) {

  } else {
    while (1) {
      wzz = (Word )9;
      if (wzz >= 0L) {
        if (wzz < 10000L) {
          tmp___5 = 1;
        } else {
          tmp___5 = 0;
        }
      } else {
        tmp___5 = 0;
      }
      tmp___6 = __builtin_expect((long )tmp___5, 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"wzz >= 0 && wzz < 10000",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2566,
                            (Char const   *)"vgSysWrap_linux_sys_dup3_before",
                            "");
      }
      status->what = (enum __anonenum_what_129 )1;
      status->sres = vgPlain_mk_SysRes_Error((UWord )wzz);
      break;
    }
  }
  return;
}
}
void vgSysWrap_linux_sys_dup3_after(ThreadId tid , SyscallArgs *arrghs ,
                                    SyscallStatus *status ) 
{ 
  Bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  UWord tmp___2 ;

  {
  if ((unsigned int )status->what == 1U) {
    tmp = sr_isError(status->sres);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
  } else {
    tmp___0 = 0;
  }
  tmp___1 = __builtin_expect((long )tmp___0, 1L);
  if (tmp___1) {

  } else {
    vgPlain_assert_fail((Bool )1, (Char const   *)"SUCCESS",
                        (Char const   *)"m_syswrap/syswrap-linux.c", 2571,
                        (Char const   *)"vgSysWrap_linux_sys_dup3_after", "");
  }
  if (vgPlain_clo_track_fds) {
    tmp___2 = getRES(status);
    vgModuleLocal_record_fd_open_named(tid, (Int )tmp___2);
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_quotactl_before(ThreadId tid ,
                                         SyscallArgLayout *layout ,
                                         SyscallArgs *arrghs ,
                                         SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_quotactl (0x%lx, %#lx, 0x%lx, 0x%lx )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3, arrghs->arg4);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2581,
                            (Char const   *)"vgSysWrap_linux_sys_quotactl_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2581,
                            (Char const   *)"vgSysWrap_linux_sys_quotactl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"quotactl(cmd)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(char const   *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2581,
                            (Char const   *)"vgSysWrap_linux_sys_quotactl_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2581,
                            (Char const   *)"vgSysWrap_linux_sys_quotactl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"quotactl(special)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(char const   *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(vki_qid_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_qid_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2581,
                            (Char const   *)"vgSysWrap_linux_sys_quotactl_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2581,
                            (Char const   *)"vgSysWrap_linux_sys_quotactl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"quotactl(id)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(vki_qid_t ));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(void *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(void *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2581,
                            (Char const   *)"vgSysWrap_linux_sys_quotactl_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2581,
                            (Char const   *)"vgSysWrap_linux_sys_quotactl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"quotactl(addr)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(void *));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"quotactl(special)",
                                                   arrghs->arg2);
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_waitid_before(ThreadId tid , SyscallArgLayout *layout ,
                                       SyscallArgs *arrghs ,
                                       SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;
  Int here___3 ;
  long tmp___7 ;
  long tmp___8 ;

  {
  *flags |= (unsigned long )(1 << 1);
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_waitid( %ld, %ld, %#lx, %ld, %#lx )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3, arrghs->arg4, arrghs->arg5);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2591,
                            (Char const   *)"vgSysWrap_linux_sys_waitid_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2591,
                            (Char const   *)"vgSysWrap_linux_sys_waitid_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sys_waitid(which)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(vki_pid_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_pid_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2591,
                            (Char const   *)"vgSysWrap_linux_sys_waitid_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2591,
                            (Char const   *)"vgSysWrap_linux_sys_waitid_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sys_waitid(pid)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(vki_pid_t ));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(struct vki_siginfo *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct vki_siginfo *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2591,
                            (Char const   *)"vgSysWrap_linux_sys_waitid_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2591,
                            (Char const   *)"vgSysWrap_linux_sys_waitid_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sys_waitid(infop)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(struct vki_siginfo *));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2591,
                            (Char const   *)"vgSysWrap_linux_sys_waitid_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2591,
                            (Char const   *)"vgSysWrap_linux_sys_waitid_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sys_waitid(options)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___3 = layout->o_arg5;
      tmp___7 = __builtin_expect((long )(! (! (sizeof(struct vki_rusage *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___7) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct vki_rusage *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2591,
                            (Char const   *)"vgSysWrap_linux_sys_waitid_before",
                            "");
      }
      tmp___8 = __builtin_expect((long )(! (! (here___3 >= 0))), 1L);
      if (tmp___8) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2591,
                            (Char const   *)"vgSysWrap_linux_sys_waitid_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sys_waitid(ru)",
                                            (PtrdiffT )here___3,
                                            (SizeT )sizeof(struct vki_rusage *));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"waitid(infop)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(struct vki_siginfo ));
    } else {

    }
    break;
  }
  if (arrghs->arg5 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_write) {
        (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                               (Char *)"waitid(ru)",
                                               arrghs->arg5,
                                               (SizeT )sizeof(struct vki_rusage ));
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_waitid_after(ThreadId tid , SyscallArgs *arrghs ,
                                      SyscallStatus *status ) 
{ 


  {
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(struct vki_siginfo ));
    } else {

    }
    break;
  }
  if (arrghs->arg5 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg5,
                                                (SizeT )sizeof(struct vki_rusage ));
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_sync_file_range_before(ThreadId tid ,
                                                SyscallArgLayout *layout ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ,
                                                UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;
  Int here___3 ;
  long tmp___7 ;
  long tmp___8 ;
  Int here___4 ;
  long tmp___9 ;
  long tmp___10 ;
  Word wzz ;
  int tmp___11 ;
  long tmp___12 ;
  Bool tmp___13 ;

  {
  *flags |= (unsigned long )(1 << 1);
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_sync_file_range ( %ld, %lld, %lld, %ld )", arrghs->arg1,
                   (ULong )arrghs->arg2 | ((ULong )arrghs->arg3 << 32),
                   (ULong )arrghs->arg4 | ((ULong )arrghs->arg5 << 32),
                   arrghs->arg6);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2613,
                            (Char const   *)"vgSysWrap_linux_sys_sync_file_range_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2613,
                            (Char const   *)"vgSysWrap_linux_sys_sync_file_range_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sync_file_range(fd)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2613,
                            (Char const   *)"vgSysWrap_linux_sys_sync_file_range_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2613,
                            (Char const   *)"vgSysWrap_linux_sys_sync_file_range_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sync_file_range(offset_low)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2613,
                            (Char const   *)"vgSysWrap_linux_sys_sync_file_range_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2613,
                            (Char const   *)"vgSysWrap_linux_sys_sync_file_range_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sync_file_range(offset_high)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2613,
                            (Char const   *)"vgSysWrap_linux_sys_sync_file_range_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2613,
                            (Char const   *)"vgSysWrap_linux_sys_sync_file_range_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sync_file_range(nbytes_low)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
    while (1) {
      here___3 = layout->o_arg5;
      tmp___7 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___7) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2613,
                            (Char const   *)"vgSysWrap_linux_sys_sync_file_range_before",
                            "");
      }
      tmp___8 = __builtin_expect((long )(! (! (here___3 >= 0))), 1L);
      if (tmp___8) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2613,
                            (Char const   *)"vgSysWrap_linux_sys_sync_file_range_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sync_file_range(nbytes_high)",
                                            (PtrdiffT )here___3,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
    while (1) {
      here___4 = layout->o_arg6;
      tmp___9 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___9) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2613,
                            (Char const   *)"vgSysWrap_linux_sys_sync_file_range_before",
                            "");
      }
      tmp___10 = __builtin_expect((long )(! (! (here___4 >= 0))), 1L);
      if (tmp___10) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2613,
                            (Char const   *)"vgSysWrap_linux_sys_sync_file_range_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sync_file_range(flags)",
                                            (PtrdiffT )here___4,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
  } else {

  }
  tmp___13 = vgModuleLocal_fd_allowed((Int )arrghs->arg1,
                                      (Char const   *)"sync_file_range", tid,
                                      (Bool )0);
  if (tmp___13) {

  } else {
    while (1) {
      wzz = (Word )9;
      if (wzz >= 0L) {
        if (wzz < 10000L) {
          tmp___11 = 1;
        } else {
          tmp___11 = 0;
        }
      } else {
        tmp___11 = 0;
      }
      tmp___12 = __builtin_expect((long )tmp___11, 1L);
      if (tmp___12) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"wzz >= 0 && wzz < 10000",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2624,
                            (Char const   *)"vgSysWrap_linux_sys_sync_file_range_before",
                            "");
      }
      status->what = (enum __anonenum_what_129 )1;
      status->sres = vgPlain_mk_SysRes_Error((UWord )wzz);
      break;
    }
  }
  return;
}
}
void vgSysWrap_linux_sys_sync_file_range2_before(ThreadId tid ,
                                                 SyscallArgLayout *layout ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ,
                                                 UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;
  Int here___3 ;
  long tmp___7 ;
  long tmp___8 ;
  Int here___4 ;
  long tmp___9 ;
  long tmp___10 ;
  Word wzz ;
  int tmp___11 ;
  long tmp___12 ;
  Bool tmp___13 ;

  {
  *flags |= (unsigned long )(1 << 1);
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_sync_file_range2 ( %ld, %ld, %lld, %lld )",
                   arrghs->arg1, arrghs->arg2,
                   (ULong )arrghs->arg3 | ((ULong )arrghs->arg4 << 32),
                   (ULong )arrghs->arg5 | ((ULong )arrghs->arg6 << 32));
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2636,
                            (Char const   *)"vgSysWrap_linux_sys_sync_file_range2_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2636,
                            (Char const   *)"vgSysWrap_linux_sys_sync_file_range2_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sync_file_range2(fd)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2636,
                            (Char const   *)"vgSysWrap_linux_sys_sync_file_range2_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2636,
                            (Char const   *)"vgSysWrap_linux_sys_sync_file_range2_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sync_file_range2(flags)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2636,
                            (Char const   *)"vgSysWrap_linux_sys_sync_file_range2_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2636,
                            (Char const   *)"vgSysWrap_linux_sys_sync_file_range2_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sync_file_range2(offset_low)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2636,
                            (Char const   *)"vgSysWrap_linux_sys_sync_file_range2_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2636,
                            (Char const   *)"vgSysWrap_linux_sys_sync_file_range2_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sync_file_range2(offset_high)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
    while (1) {
      here___3 = layout->o_arg5;
      tmp___7 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___7) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2636,
                            (Char const   *)"vgSysWrap_linux_sys_sync_file_range2_before",
                            "");
      }
      tmp___8 = __builtin_expect((long )(! (! (here___3 >= 0))), 1L);
      if (tmp___8) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2636,
                            (Char const   *)"vgSysWrap_linux_sys_sync_file_range2_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sync_file_range2(nbytes_low)",
                                            (PtrdiffT )here___3,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
    while (1) {
      here___4 = layout->o_arg6;
      tmp___9 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___9) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2636,
                            (Char const   *)"vgSysWrap_linux_sys_sync_file_range2_before",
                            "");
      }
      tmp___10 = __builtin_expect((long )(! (! (here___4 >= 0))), 1L);
      if (tmp___10) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2636,
                            (Char const   *)"vgSysWrap_linux_sys_sync_file_range2_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sync_file_range2(nbytes_high)",
                                            (PtrdiffT )here___4,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
  } else {

  }
  tmp___13 = vgModuleLocal_fd_allowed((Int )arrghs->arg1,
                                      (Char const   *)"sync_file_range2", tid,
                                      (Bool )0);
  if (tmp___13) {

  } else {
    while (1) {
      wzz = (Word )9;
      if (wzz >= 0L) {
        if (wzz < 10000L) {
          tmp___11 = 1;
        } else {
          tmp___11 = 0;
        }
      } else {
        tmp___11 = 0;
      }
      tmp___12 = __builtin_expect((long )tmp___11, 1L);
      if (tmp___12) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"wzz >= 0 && wzz < 10000",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2647,
                            (Char const   *)"vgSysWrap_linux_sys_sync_file_range2_before",
                            "");
      }
      status->what = (enum __anonenum_what_129 )1;
      status->sres = vgPlain_mk_SysRes_Error((UWord )wzz);
      break;
    }
  }
  return;
}
}
void vgSysWrap_linux_sys_stime_before(ThreadId tid , SyscallArgLayout *layout ,
                                      SyscallArgs *arrghs ,
                                      SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_stime ( %#lx )", arrghs->arg1);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_time_t *) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_time_t*) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2653,
                            (Char const   *)"vgSysWrap_linux_sys_stime_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2653,
                            (Char const   *)"vgSysWrap_linux_sys_stime_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"stime(t)", (PtrdiffT )here,
                                            (SizeT )sizeof(vki_time_t *));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"stime(t)", arrghs->arg1,
                                            (SizeT )sizeof(vki_time_t ));
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_perf_event_open_before(ThreadId tid ,
                                                SyscallArgLayout *layout ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ,
                                                UWord *flags ) 
{ 
  struct vki_perf_event_attr *attr ;
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;
  Int here___3 ;
  long tmp___7 ;
  long tmp___8 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_perf_event_open ( %#lx, %ld, %ld, %ld, %ld )",
                   arrghs->arg1, arrghs->arg2, arrghs->arg3, arrghs->arg4,
                   arrghs->arg5);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(struct vki_perf_event_attr *) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct vki_perf_event_attr *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2665,
                            (Char const   *)"vgSysWrap_linux_sys_perf_event_open_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2665,
                            (Char const   *)"vgSysWrap_linux_sys_perf_event_open_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"perf_event_open(attr)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(struct vki_perf_event_attr *));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(vki_pid_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_pid_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2665,
                            (Char const   *)"vgSysWrap_linux_sys_perf_event_open_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2665,
                            (Char const   *)"vgSysWrap_linux_sys_perf_event_open_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"perf_event_open(pid)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(vki_pid_t ));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2665,
                            (Char const   *)"vgSysWrap_linux_sys_perf_event_open_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2665,
                            (Char const   *)"vgSysWrap_linux_sys_perf_event_open_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"perf_event_open(cpu)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2665,
                            (Char const   *)"vgSysWrap_linux_sys_perf_event_open_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2665,
                            (Char const   *)"vgSysWrap_linux_sys_perf_event_open_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"perf_event_open(group_fd)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___3 = layout->o_arg5;
      tmp___7 = __builtin_expect((long )(! (! (sizeof(unsigned long ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___7) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned long) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2665,
                            (Char const   *)"vgSysWrap_linux_sys_perf_event_open_before",
                            "");
      }
      tmp___8 = __builtin_expect((long )(! (! (here___3 >= 0))), 1L);
      if (tmp___8) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2665,
                            (Char const   *)"vgSysWrap_linux_sys_perf_event_open_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"perf_event_open(flags)",
                                            (PtrdiffT )here___3,
                                            (SizeT )sizeof(unsigned long ));
      break;
    }
  } else {

  }
  attr = (struct vki_perf_event_attr *)arrghs->arg1;
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"perf_event_open(attr->size)",
                                            (Addr )(& attr->size),
                                            (SizeT )sizeof(attr->size));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"perf_event_open(attr)",
                                            (Addr )attr, (SizeT )attr->size);
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_perf_event_open_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) 
{ 
  Bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  UWord tmp___2 ;
  Word wzz ;
  int tmp___3 ;
  long tmp___4 ;
  UWord tmp___5 ;
  UWord tmp___6 ;
  Bool tmp___7 ;

  {
  if ((unsigned int )status->what == 1U) {
    tmp = sr_isError(status->sres);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
  } else {
    tmp___0 = 0;
  }
  tmp___1 = __builtin_expect((long )tmp___0, 1L);
  if (tmp___1) {

  } else {
    vgPlain_assert_fail((Bool )1, (Char const   *)"SUCCESS",
                        (Char const   *)"m_syswrap/syswrap-linux.c", 2675,
                        (Char const   *)"vgSysWrap_linux_sys_perf_event_open_after",
                        "");
  }
  tmp___6 = getRES(status);
  tmp___7 = vgModuleLocal_fd_allowed((Int )tmp___6,
                                     (Char const   *)"perf_event_open", tid,
                                     (Bool )1);
  if (tmp___7) {
    if (vgPlain_clo_track_fds) {
      tmp___5 = getRES(status);
      vgModuleLocal_record_fd_open_nameless(tid, (Int )tmp___5);
    } else {

    }
  } else {
    tmp___2 = getRES(status);
    vgPlain_close((Int )tmp___2);
    while (1) {
      wzz = (Word )24;
      if (wzz >= 0L) {
        if (wzz < 10000L) {
          tmp___3 = 1;
        } else {
          tmp___3 = 0;
        }
      } else {
        tmp___3 = 0;
      }
      tmp___4 = __builtin_expect((long )tmp___3, 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"wzz >= 0 && wzz < 10000",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2678,
                            (Char const   *)"vgSysWrap_linux_sys_perf_event_open_after",
                            "");
      }
      status->what = (enum __anonenum_what_129 )1;
      status->sres = vgPlain_mk_SysRes_Error((UWord )wzz);
      break;
    }
  }
  return;
}
}
void vgSysWrap_linux_sys_getcpu_before(ThreadId tid , SyscallArgLayout *layout ,
                                       SyscallArgs *arrghs ,
                                       SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_getcpu ( %#lx, %#lx, %#lx )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(unsigned int *) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2689,
                            (Char const   *)"vgSysWrap_linux_sys_getcpu_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2689,
                            (Char const   *)"vgSysWrap_linux_sys_getcpu_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"getcpu(cpu)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(unsigned int *));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(unsigned int *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2689,
                            (Char const   *)"vgSysWrap_linux_sys_getcpu_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2689,
                            (Char const   *)"vgSysWrap_linux_sys_getcpu_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"getcpu(node)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(unsigned int *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(struct vki_getcpu_cache *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct vki_getcpu_cache *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2689,
                            (Char const   *)"vgSysWrap_linux_sys_getcpu_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2689,
                            (Char const   *)"vgSysWrap_linux_sys_getcpu_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"getcpu(tcache)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(struct vki_getcpu_cache *));
      break;
    }
  } else {

  }
  if (arrghs->arg1 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_write) {
        (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                               (Char *)"getcpu(cpu)",
                                               arrghs->arg1,
                                               (SizeT )sizeof(unsigned int ));
      } else {

      }
      break;
    }
  } else {

  }
  if (arrghs->arg2 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_write) {
        (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                               (Char *)"getcpu(node)",
                                               arrghs->arg2,
                                               (SizeT )sizeof(unsigned int ));
      } else {

      }
      break;
    }
  } else {

  }
  if (arrghs->arg3 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_write) {
        (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                               (Char *)"getcpu(tcache)",
                                               arrghs->arg3,
                                               (SizeT )sizeof(struct vki_getcpu_cache ));
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_getcpu_after(ThreadId tid , SyscallArgs *arrghs ,
                                      SyscallStatus *status ) 
{ 


  {
  if (arrghs->arg1 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg1,
                                                (SizeT )sizeof(unsigned int ));
      } else {

      }
      break;
    }
  } else {

  }
  if (arrghs->arg2 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg2,
                                                (SizeT )sizeof(unsigned int ));
      } else {

      }
      break;
    }
  } else {

  }
  if (arrghs->arg3 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                                (SizeT )sizeof(struct vki_getcpu_cache ));
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_utime_before(ThreadId tid , SyscallArgLayout *layout ,
                                      SyscallArgs *arrghs ,
                                      SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  *flags |= (unsigned long )(1 << 1);
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_utime ( %#lx, %#lx )", arrghs->arg1, arrghs->arg2);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(char *) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2716,
                            (Char const   *)"vgSysWrap_linux_sys_utime_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2716,
                            (Char const   *)"vgSysWrap_linux_sys_utime_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"utime(filename)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(char *));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(struct utimbuf *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct utimbuf *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2716,
                            (Char const   *)"vgSysWrap_linux_sys_utime_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2716,
                            (Char const   *)"vgSysWrap_linux_sys_utime_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"utime(buf)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(struct utimbuf *));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"utime(filename)",
                                                   arrghs->arg1);
    } else {

    }
    break;
  }
  if (arrghs->arg2 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"utime(buf)",
                                              arrghs->arg2,
                                              (SizeT )sizeof(struct vki_utimbuf ));
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_lseek_before(ThreadId tid , SyscallArgLayout *layout ,
                                      SyscallArgs *arrghs ,
                                      SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_lseek ( %ld, %ld, %ld )", arrghs->arg1, arrghs->arg2,
                   arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2730,
                            (Char const   *)"vgSysWrap_linux_sys_lseek_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2730,
                            (Char const   *)"vgSysWrap_linux_sys_lseek_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"lseek(fd)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(vki_off_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_off_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2730,
                            (Char const   *)"vgSysWrap_linux_sys_lseek_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2730,
                            (Char const   *)"vgSysWrap_linux_sys_lseek_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"lseek(offset)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(vki_off_t ));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2730,
                            (Char const   *)"vgSysWrap_linux_sys_lseek_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2730,
                            (Char const   *)"vgSysWrap_linux_sys_lseek_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"lseek(whence)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_readahead_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;
  Word wzz ;
  int tmp___7 ;
  long tmp___8 ;
  Bool tmp___9 ;

  {
  *flags |= (unsigned long )(1 << 1);
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_readahead ( %ld, %lld, %ld )", arrghs->arg1,
                   (ULong )arrghs->arg2 | ((ULong )arrghs->arg3 << 32),
                   arrghs->arg4);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2744,
                            (Char const   *)"vgSysWrap_linux_sys_readahead_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2744,
                            (Char const   *)"vgSysWrap_linux_sys_readahead_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"readahead(fd)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2744,
                            (Char const   *)"vgSysWrap_linux_sys_readahead_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2744,
                            (Char const   *)"vgSysWrap_linux_sys_readahead_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"readahead(offset_low)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2744,
                            (Char const   *)"vgSysWrap_linux_sys_readahead_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2744,
                            (Char const   *)"vgSysWrap_linux_sys_readahead_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"readahead(offset_high)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(vki_size_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_size_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2744,
                            (Char const   *)"vgSysWrap_linux_sys_readahead_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2744,
                            (Char const   *)"vgSysWrap_linux_sys_readahead_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"readahead(count)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(vki_size_t ));
      break;
    }
  } else {

  }
  tmp___9 = vgModuleLocal_fd_allowed((Int )arrghs->arg1,
                                     (Char const   *)"readahead", tid, (Bool )0);
  if (tmp___9) {

  } else {
    while (1) {
      wzz = (Word )9;
      if (wzz >= 0L) {
        if (wzz < 10000L) {
          tmp___7 = 1;
        } else {
          tmp___7 = 0;
        }
      } else {
        tmp___7 = 0;
      }
      tmp___8 = __builtin_expect((long )tmp___7, 1L);
      if (tmp___8) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"wzz >= 0 && wzz < 10000",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2753,
                            (Char const   *)"vgSysWrap_linux_sys_readahead_before",
                            "");
      }
      status->what = (enum __anonenum_what_129 )1;
      status->sres = vgPlain_mk_SysRes_Error((UWord )wzz);
      break;
    }
  }
  return;
}
}
void vgSysWrap_linux_sys_sigpending_before(ThreadId tid ,
                                           SyscallArgLayout *layout ,
                                           SyscallArgs *arrghs ,
                                           SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_sigpending ( %#lx )", arrghs->arg1);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_old_sigset_t *) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_old_sigset_t *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2763,
                            (Char const   *)"vgSysWrap_linux_sys_sigpending_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2763,
                            (Char const   *)"vgSysWrap_linux_sys_sigpending_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sigpending(set)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_old_sigset_t *));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"sigpending(set)",
                                             arrghs->arg1,
                                             (SizeT )sizeof(vki_old_sigset_t ));
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_sigpending_after(ThreadId tid , SyscallArgs *arrghs ,
                                          SyscallStatus *status ) 
{ 


  {
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg1,
                                              (SizeT )sizeof(vki_old_sigset_t ));
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_sigprocmask_before(ThreadId tid ,
                                            SyscallArgLayout *layout ,
                                            SyscallArgs *arrghs ,
                                            SyscallStatus *status ,
                                            UWord *flags ) 
{ 
  vki_old_sigset_t *set ;
  vki_old_sigset_t *oldset ;
  vki_sigset_t bigger_set ;
  vki_sigset_t bigger_oldset ;
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  vki_sigset_t *tmp___5 ;
  vki_sigset_t *tmp___6 ;
  Bool tmp___7 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_sigprocmask ( %ld, %#lx, %#lx )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2786,
                            (Char const   *)"vgSysWrap_linux_sys_sigprocmask_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2786,
                            (Char const   *)"vgSysWrap_linux_sys_sigprocmask_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sigprocmask(how)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(vki_old_sigset_t *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_old_sigset_t *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2786,
                            (Char const   *)"vgSysWrap_linux_sys_sigprocmask_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2786,
                            (Char const   *)"vgSysWrap_linux_sys_sigprocmask_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sigprocmask(set)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(vki_old_sigset_t *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(vki_old_sigset_t *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_old_sigset_t *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2786,
                            (Char const   *)"vgSysWrap_linux_sys_sigprocmask_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2786,
                            (Char const   *)"vgSysWrap_linux_sys_sigprocmask_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sigprocmask(oldset)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(vki_old_sigset_t *));
      break;
    }
  } else {

  }
  if (arrghs->arg2 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"sigprocmask(set)",
                                              arrghs->arg2,
                                              (SizeT )sizeof(vki_old_sigset_t ));
      } else {

      }
      break;
    }
  } else {

  }
  if (arrghs->arg3 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_write) {
        (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                               (Char *)"sigprocmask(oldset)",
                                               arrghs->arg3,
                                               (SizeT )sizeof(vki_old_sigset_t ));
      } else {

      }
      break;
    }
  } else {

  }
  set = (vki_old_sigset_t *)arrghs->arg2;
  oldset = (vki_old_sigset_t *)arrghs->arg3;
  vgPlain_memset((void *)(& bigger_set), 0, (SizeT )sizeof(vki_sigset_t ));
  vgPlain_memset((void *)(& bigger_oldset), 0, (SizeT )sizeof(vki_sigset_t ));
  if (set) {
    bigger_set.sig[0] = *set;
  } else {

  }
  while (1) {
    status->what = (enum __anonenum_what_129 )1;
    if (oldset) {
      tmp___5 = & bigger_oldset;
    } else {
      tmp___5 = (vki_sigset_t *)((void *)0);
    }
    if (set) {
      tmp___6 = & bigger_set;
    } else {
      tmp___6 = (vki_sigset_t *)((void *)0);
    }
    status->sres = vgPlain_do_sys_sigprocmask(tid, (Int )arrghs->arg1, tmp___6,
                                              tmp___5);
    break;
  }
  if (oldset) {
    *oldset = bigger_oldset.sig[0];
  } else {

  }
  if ((unsigned int )status->what == 1U) {
    tmp___7 = sr_isError(status->sres);
    if (tmp___7) {

    } else {
      *flags |= (unsigned long )(1 << 3);
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_sigprocmask_after(ThreadId tid , SyscallArgs *arrghs ,
                                           SyscallStatus *status ) 
{ 
  Bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  UWord tmp___2 ;

  {
  if ((unsigned int )status->what == 1U) {
    tmp = sr_isError(status->sres);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
  } else {
    tmp___0 = 0;
  }
  tmp___1 = __builtin_expect((long )tmp___0, 1L);
  if (tmp___1) {

  } else {
    vgPlain_assert_fail((Bool )1, (Char const   *)"SUCCESS",
                        (Char const   *)"m_syswrap/syswrap-linux.c", 2816,
                        (Char const   *)"vgSysWrap_linux_sys_sigprocmask_after",
                        "");
  }
  tmp___2 = getRES(status);
  if (tmp___2 == 0UL) {
    if (arrghs->arg3 != 0UL) {
      while (1) {
        if (vgPlain_tdict.track_post_mem_write) {
          (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                  arrghs->arg3,
                                                  (SizeT )sizeof(vki_old_sigset_t ));
        } else {

        }
        break;
      }
    } else {

    }
  } else {

  }
  return;
}
}
static void convert_sigset_to_rt(vki_old_sigset_t const   *oldset ,
                                 vki_sigset_t *set ) 
{ 


  {
  vgPlain_sigemptyset(set);
  set->sig[0] = (unsigned long )*oldset;
  return;
}
}
void vgSysWrap_linux_sys_sigaction_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) 
{ 
  vki_sigaction_toK_t new ;
  vki_sigaction_toK_t *newp ;
  vki_sigaction_fromK_t old ;
  vki_sigaction_fromK_t *oldp ;
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  struct vki_old_sigaction *sa ;
  Bool tmp___5 ;
  struct vki_old_sigaction *oldnew ;
  struct vki_old_sigaction *oldold ;
  Bool tmp___6 ;
  UWord tmp___7 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_sigaction ( %ld, %#lx, %#lx )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2836,
                            (Char const   *)"vgSysWrap_linux_sys_sigaction_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2836,
                            (Char const   *)"vgSysWrap_linux_sys_sigaction_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sigaction(signum)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(struct old_sigaction  const  *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const struct old_sigaction *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2836,
                            (Char const   *)"vgSysWrap_linux_sys_sigaction_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2836,
                            (Char const   *)"vgSysWrap_linux_sys_sigaction_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sigaction(act)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(struct old_sigaction  const  *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(struct old_sigaction *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct old_sigaction *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2836,
                            (Char const   *)"vgSysWrap_linux_sys_sigaction_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2836,
                            (Char const   *)"vgSysWrap_linux_sys_sigaction_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sigaction(oldact)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(struct old_sigaction *));
      break;
    }
  } else {

  }
  oldp = (vki_sigaction_fromK_t *)((void *)0);
  newp = oldp;
  if (arrghs->arg2 != 0UL) {
    sa = (struct vki_old_sigaction *)arrghs->arg2;
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"sigaction(act->sa_handler)",
                                              (Addr )(& sa->ksa_handler),
                                              (SizeT )sizeof(sa->ksa_handler));
      } else {

      }
      break;
    }
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"sigaction(act->sa_mask)",
                                              (Addr )(& sa->sa_mask),
                                              (SizeT )sizeof(sa->sa_mask));
      } else {

      }
      break;
    }
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"sigaction(act->sa_flags)",
                                              (Addr )(& sa->sa_flags),
                                              (SizeT )sizeof(sa->sa_flags));
      } else {

      }
      break;
    }
    tmp___5 = vgModuleLocal_safe_to_deref((void *)sa, (SizeT )sizeof(sa));
    if (tmp___5) {
      if (sa->sa_flags & 67108864UL) {
        while (1) {
          if (vgPlain_tdict.track_pre_mem_read) {
            (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                                  (Char *)"sigaction(act->sa_restorer)",
                                                  (Addr )(& sa->sa_restorer),
                                                  (SizeT )sizeof(sa->sa_restorer));
          } else {

          }
          break;
        }
      } else {

      }
    } else {

    }
  } else {

  }
  if (arrghs->arg3 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_write) {
        (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                               (Char *)"sigaction(oldact)",
                                               arrghs->arg3,
                                               (SizeT )sizeof(struct vki_old_sigaction ));
      } else {

      }
      break;
    }
    oldp = & old;
  } else {

  }
  if (arrghs->arg2 != 0UL) {
    oldnew = (struct vki_old_sigaction *)arrghs->arg2;
    new.ksa_handler = oldnew->ksa_handler;
    new.sa_flags = oldnew->sa_flags;
    new.sa_restorer = oldnew->sa_restorer;
    convert_sigset_to_rt((vki_old_sigset_t const   *)(& oldnew->sa_mask),
                         & new.sa_mask);
    newp = & new;
  } else {

  }
  while (1) {
    status->what = (enum __anonenum_what_129 )1;
    status->sres = vgPlain_do_sys_sigaction((Int )arrghs->arg1,
                                            (vki_sigaction_toK_t const   *)newp,
                                            oldp);
    break;
  }
  if (arrghs->arg3 != 0UL) {
    if ((unsigned int )status->what == 1U) {
      tmp___6 = sr_isError(status->sres);
      if (tmp___6) {

      } else {
        tmp___7 = getRES(status);
        if (tmp___7 == 0UL) {
          oldold = (struct vki_old_sigaction *)arrghs->arg3;
          oldold->ksa_handler = oldp->ksa_handler;
          oldold->sa_flags = oldp->sa_flags;
          oldold->sa_restorer = oldp->sa_restorer;
          oldold->sa_mask = oldp->sa_mask.sig[0];
        } else {

        }
      }
    } else {

    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_sigaction_after(ThreadId tid , SyscallArgs *arrghs ,
                                         SyscallStatus *status ) 
{ 
  Bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  UWord tmp___2 ;

  {
  if ((unsigned int )status->what == 1U) {
    tmp = sr_isError(status->sres);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
  } else {
    tmp___0 = 0;
  }
  tmp___1 = __builtin_expect((long )tmp___0, 1L);
  if (tmp___1) {

  } else {
    vgPlain_assert_fail((Bool )1, (Char const   *)"SUCCESS",
                        (Char const   *)"m_syswrap/syswrap-linux.c", 2878,
                        (Char const   *)"vgSysWrap_linux_sys_sigaction_after",
                        "");
  }
  tmp___2 = getRES(status);
  if (tmp___2 == 0UL) {
    if (arrghs->arg3 != 0UL) {
      while (1) {
        if (vgPlain_tdict.track_post_mem_write) {
          (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                  arrghs->arg3,
                                                  (SizeT )sizeof(struct vki_old_sigaction ));
        } else {

        }
        break;
      }
    } else {

    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_signalfd_before(ThreadId tid ,
                                         SyscallArgLayout *layout ,
                                         SyscallArgs *arrghs ,
                                         SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Word wzz ;
  int tmp___5 ;
  long tmp___6 ;
  Bool tmp___7 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_signalfd ( %d, %#lx, %llu )", (Int )arrghs->arg1,
                   arrghs->arg2, (ULong )arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2888,
                            (Char const   *)"vgSysWrap_linux_sys_signalfd_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2888,
                            (Char const   *)"vgSysWrap_linux_sys_signalfd_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sys_signalfd(fd)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(vki_sigset_t *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_sigset_t *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2888,
                            (Char const   *)"vgSysWrap_linux_sys_signalfd_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2888,
                            (Char const   *)"vgSysWrap_linux_sys_signalfd_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sys_signalfd(sigmask)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(vki_sigset_t *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(vki_size_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_size_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2888,
                            (Char const   *)"vgSysWrap_linux_sys_signalfd_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2888,
                            (Char const   *)"vgSysWrap_linux_sys_signalfd_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sys_signalfd(sigsetsize)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(vki_size_t ));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"signalfd(sigmask)",
                                            arrghs->arg2,
                                            (SizeT )sizeof(vki_sigset_t ));
    } else {

    }
    break;
  }
  if ((int )arrghs->arg1 != -1) {
    tmp___7 = vgModuleLocal_fd_allowed((Int )arrghs->arg1,
                                       (Char const   *)"signalfd", tid, (Bool )0);
    if (tmp___7) {

    } else {
      while (1) {
        wzz = (Word )9;
        if (wzz >= 0L) {
          if (wzz < 10000L) {
            tmp___5 = 1;
          } else {
            tmp___5 = 0;
          }
        } else {
          tmp___5 = 0;
        }
        tmp___6 = __builtin_expect((long )tmp___5, 1L);
        if (tmp___6) {

        } else {
          vgPlain_assert_fail((Bool )1,
                              (Char const   *)"wzz >= 0 && wzz < 10000",
                              (Char const   *)"m_syswrap/syswrap-linux.c", 2891,
                              (Char const   *)"vgSysWrap_linux_sys_signalfd_before",
                              "");
        }
        status->what = (enum __anonenum_what_129 )1;
        status->sres = vgPlain_mk_SysRes_Error((UWord )wzz);
        break;
      }
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_signalfd_after(ThreadId tid , SyscallArgs *arrghs ,
                                        SyscallStatus *status ) 
{ 
  UWord tmp ;
  Word wzz ;
  int tmp___0 ;
  long tmp___1 ;
  UWord tmp___2 ;
  UWord tmp___3 ;
  Bool tmp___4 ;

  {
  tmp___3 = getRES(status);
  tmp___4 = vgModuleLocal_fd_allowed((Int )tmp___3, (Char const   *)"signalfd",
                                     tid, (Bool )1);
  if (tmp___4) {
    if (vgPlain_clo_track_fds) {
      tmp___2 = getRES(status);
      vgModuleLocal_record_fd_open_nameless(tid, (Int )tmp___2);
    } else {

    }
  } else {
    tmp = getRES(status);
    vgPlain_close((Int )tmp);
    while (1) {
      wzz = (Word )24;
      if (wzz >= 0L) {
        if (wzz < 10000L) {
          tmp___0 = 1;
        } else {
          tmp___0 = 0;
        }
      } else {
        tmp___0 = 0;
      }
      tmp___1 = __builtin_expect((long )tmp___0, 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"wzz >= 0 && wzz < 10000",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2897,
                            (Char const   *)"vgSysWrap_linux_sys_signalfd_after",
                            "");
      }
      status->what = (enum __anonenum_what_129 )1;
      status->sres = vgPlain_mk_SysRes_Error((UWord )wzz);
      break;
    }
  }
  return;
}
}
void vgSysWrap_linux_sys_signalfd4_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;
  Word wzz ;
  int tmp___7 ;
  long tmp___8 ;
  Bool tmp___9 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_signalfd4 ( %d, %#lx, %llu, %ld )", (Int )arrghs->arg1,
                   arrghs->arg2, (ULong )arrghs->arg3, arrghs->arg4);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2908,
                            (Char const   *)"vgSysWrap_linux_sys_signalfd4_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2908,
                            (Char const   *)"vgSysWrap_linux_sys_signalfd4_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sys_signalfd4(fd)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(vki_sigset_t *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_sigset_t *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2908,
                            (Char const   *)"vgSysWrap_linux_sys_signalfd4_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2908,
                            (Char const   *)"vgSysWrap_linux_sys_signalfd4_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sys_signalfd4(sigmask)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(vki_sigset_t *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(vki_size_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_size_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2908,
                            (Char const   *)"vgSysWrap_linux_sys_signalfd4_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2908,
                            (Char const   *)"vgSysWrap_linux_sys_signalfd4_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sys_signalfd4(sigsetsize)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(vki_size_t ));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2908,
                            (Char const   *)"vgSysWrap_linux_sys_signalfd4_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2908,
                            (Char const   *)"vgSysWrap_linux_sys_signalfd4_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sys_signalfd4(flags)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"signalfd(sigmask)",
                                            arrghs->arg2,
                                            (SizeT )sizeof(vki_sigset_t ));
    } else {

    }
    break;
  }
  if ((int )arrghs->arg1 != -1) {
    tmp___9 = vgModuleLocal_fd_allowed((Int )arrghs->arg1,
                                       (Char const   *)"signalfd", tid, (Bool )0);
    if (tmp___9) {

    } else {
      while (1) {
        wzz = (Word )9;
        if (wzz >= 0L) {
          if (wzz < 10000L) {
            tmp___7 = 1;
          } else {
            tmp___7 = 0;
          }
        } else {
          tmp___7 = 0;
        }
        tmp___8 = __builtin_expect((long )tmp___7, 1L);
        if (tmp___8) {

        } else {
          vgPlain_assert_fail((Bool )1,
                              (Char const   *)"wzz >= 0 && wzz < 10000",
                              (Char const   *)"m_syswrap/syswrap-linux.c", 2911,
                              (Char const   *)"vgSysWrap_linux_sys_signalfd4_before",
                              "");
        }
        status->what = (enum __anonenum_what_129 )1;
        status->sres = vgPlain_mk_SysRes_Error((UWord )wzz);
        break;
      }
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_signalfd4_after(ThreadId tid , SyscallArgs *arrghs ,
                                         SyscallStatus *status ) 
{ 
  UWord tmp ;
  Word wzz ;
  int tmp___0 ;
  long tmp___1 ;
  UWord tmp___2 ;
  UWord tmp___3 ;
  Bool tmp___4 ;

  {
  tmp___3 = getRES(status);
  tmp___4 = vgModuleLocal_fd_allowed((Int )tmp___3, (Char const   *)"signalfd4",
                                     tid, (Bool )1);
  if (tmp___4) {
    if (vgPlain_clo_track_fds) {
      tmp___2 = getRES(status);
      vgModuleLocal_record_fd_open_nameless(tid, (Int )tmp___2);
    } else {

    }
  } else {
    tmp = getRES(status);
    vgPlain_close((Int )tmp);
    while (1) {
      wzz = (Word )24;
      if (wzz >= 0L) {
        if (wzz < 10000L) {
          tmp___0 = 1;
        } else {
          tmp___0 = 0;
        }
      } else {
        tmp___0 = 0;
      }
      tmp___1 = __builtin_expect((long )tmp___0, 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"wzz >= 0 && wzz < 10000",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2917,
                            (Char const   *)"vgSysWrap_linux_sys_signalfd4_after",
                            "");
      }
      status->what = (enum __anonenum_what_129 )1;
      status->sres = vgPlain_mk_SysRes_Error((UWord )wzz);
      break;
    }
  }
  return;
}
}
void vgSysWrap_linux_sys_rt_sigaction_before(ThreadId tid ,
                                             SyscallArgLayout *layout ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ,
                                             UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;
  vki_sigaction_toK_t *sa ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_rt_sigaction ( %ld, %#lx, %#lx, %ld )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3, arrghs->arg4);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2934,
                            (Char const   *)"vgSysWrap_linux_sys_rt_sigaction_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2934,
                            (Char const   *)"vgSysWrap_linux_sys_rt_sigaction_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"rt_sigaction(signum)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(struct sigaction  const  *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const struct sigaction *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2934,
                            (Char const   *)"vgSysWrap_linux_sys_rt_sigaction_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2934,
                            (Char const   *)"vgSysWrap_linux_sys_rt_sigaction_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"rt_sigaction(act)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(struct sigaction  const  *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(struct sigaction *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct sigaction *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2934,
                            (Char const   *)"vgSysWrap_linux_sys_rt_sigaction_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2934,
                            (Char const   *)"vgSysWrap_linux_sys_rt_sigaction_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"rt_sigaction(oldact)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(struct sigaction *));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(vki_size_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_size_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2934,
                            (Char const   *)"vgSysWrap_linux_sys_rt_sigaction_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2934,
                            (Char const   *)"vgSysWrap_linux_sys_rt_sigaction_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"rt_sigaction(sigsetsize)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(vki_size_t ));
      break;
    }
  } else {

  }
  if (arrghs->arg2 != 0UL) {
    sa = (vki_sigaction_toK_t *)arrghs->arg2;
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"rt_sigaction(act->sa_handler)",
                                              (Addr )(& sa->ksa_handler),
                                              (SizeT )sizeof(sa->ksa_handler));
      } else {

      }
      break;
    }
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"rt_sigaction(act->sa_mask)",
                                              (Addr )(& sa->sa_mask),
                                              (SizeT )sizeof(sa->sa_mask));
      } else {

      }
      break;
    }
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"rt_sigaction(act->sa_flags)",
                                              (Addr )(& sa->sa_flags),
                                              (SizeT )sizeof(sa->sa_flags));
      } else {

      }
      break;
    }
    if (sa->sa_flags & 67108864UL) {
      while (1) {
        if (vgPlain_tdict.track_pre_mem_read) {
          (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                                (Char *)"rt_sigaction(act->sa_restorer)",
                                                (Addr )(& sa->sa_restorer),
                                                (SizeT )sizeof(sa->sa_restorer));
        } else {

        }
        break;
      }
    } else {

    }
  } else {

  }
  if (arrghs->arg3 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_write) {
        (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                               (Char *)"rt_sigaction(oldact)",
                                               arrghs->arg3,
                                               (SizeT )sizeof(vki_sigaction_fromK_t ));
      } else {

      }
      break;
    }
  } else {

  }
  while (1) {
    status->what = (enum __anonenum_what_129 )1;
    status->sres = vgPlain_do_sys_sigaction((Int )arrghs->arg1,
                                            (vki_sigaction_toK_t const   *)arrghs->arg2,
                                            (vki_sigaction_fromK_t *)arrghs->arg3);
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_rt_sigaction_after(ThreadId tid , SyscallArgs *arrghs ,
                                            SyscallStatus *status ) 
{ 
  Bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  UWord tmp___2 ;

  {
  if ((unsigned int )status->what == 1U) {
    tmp = sr_isError(status->sres);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
  } else {
    tmp___0 = 0;
  }
  tmp___1 = __builtin_expect((long )tmp___0, 1L);
  if (tmp___1) {

  } else {
    vgPlain_assert_fail((Bool )1, (Char const   *)"SUCCESS",
                        (Char const   *)"m_syswrap/syswrap-linux.c", 2958,
                        (Char const   *)"vgSysWrap_linux_sys_rt_sigaction_after",
                        "");
  }
  tmp___2 = getRES(status);
  if (tmp___2 == 0UL) {
    if (arrghs->arg3 != 0UL) {
      while (1) {
        if (vgPlain_tdict.track_post_mem_write) {
          (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                  arrghs->arg3,
                                                  (SizeT )sizeof(vki_sigaction_fromK_t ));
        } else {

        }
        break;
      }
    } else {

    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_rt_sigprocmask_before(ThreadId tid ,
                                               SyscallArgLayout *layout ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ,
                                               UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;
  Word wzz ;
  int tmp___7 ;
  long tmp___8 ;
  Bool tmp___9 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_rt_sigprocmask ( %ld, %#lx, %#lx, %llu )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3, (ULong )arrghs->arg4);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2968,
                            (Char const   *)"vgSysWrap_linux_sys_rt_sigprocmask_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2968,
                            (Char const   *)"vgSysWrap_linux_sys_rt_sigprocmask_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"rt_sigprocmask(how)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(vki_sigset_t *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_sigset_t *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2968,
                            (Char const   *)"vgSysWrap_linux_sys_rt_sigprocmask_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2968,
                            (Char const   *)"vgSysWrap_linux_sys_rt_sigprocmask_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"rt_sigprocmask(set)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(vki_sigset_t *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(vki_sigset_t *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_sigset_t *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2968,
                            (Char const   *)"vgSysWrap_linux_sys_rt_sigprocmask_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2968,
                            (Char const   *)"vgSysWrap_linux_sys_rt_sigprocmask_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"rt_sigprocmask(oldset)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(vki_sigset_t *));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(vki_size_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_size_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2968,
                            (Char const   *)"vgSysWrap_linux_sys_rt_sigprocmask_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2968,
                            (Char const   *)"vgSysWrap_linux_sys_rt_sigprocmask_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"rt_sigprocmask(sigsetsize)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(vki_size_t ));
      break;
    }
  } else {

  }
  if (arrghs->arg2 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"rt_sigprocmask(set)",
                                              arrghs->arg2,
                                              (SizeT )sizeof(vki_sigset_t ));
      } else {

      }
      break;
    }
  } else {

  }
  if (arrghs->arg3 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_write) {
        (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                               (Char *)"rt_sigprocmask(oldset)",
                                               arrghs->arg3,
                                               (SizeT )sizeof(vki_sigset_t ));
      } else {

      }
      break;
    }
  } else {

  }
  if ((UWord )sizeof(vki_sigset_t ) != arrghs->arg4) {
    while (1) {
      wzz = (Word )24;
      if (wzz >= 0L) {
        if (wzz < 10000L) {
          tmp___7 = 1;
        } else {
          tmp___7 = 0;
        }
      } else {
        tmp___7 = 0;
      }
      tmp___8 = __builtin_expect((long )tmp___7, 1L);
      if (tmp___8) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"wzz >= 0 && wzz < 10000",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2976,
                            (Char const   *)"vgSysWrap_linux_sys_rt_sigprocmask_before",
                            "");
      }
      status->what = (enum __anonenum_what_129 )1;
      status->sres = vgPlain_mk_SysRes_Error((UWord )wzz);
      break;
    }
  } else {
    while (1) {
      status->what = (enum __anonenum_what_129 )1;
      status->sres = vgPlain_do_sys_sigprocmask(tid, (Int )arrghs->arg1,
                                                (vki_sigset_t *)arrghs->arg2,
                                                (vki_sigset_t *)arrghs->arg3);
      break;
    }
  }
  if ((unsigned int )status->what == 1U) {
    tmp___9 = sr_isError(status->sres);
    if (tmp___9) {

    } else {
      *flags |= (unsigned long )(1 << 3);
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_rt_sigprocmask_after(ThreadId tid ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ) 
{ 
  Bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  UWord tmp___2 ;

  {
  if ((unsigned int )status->what == 1U) {
    tmp = sr_isError(status->sres);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
  } else {
    tmp___0 = 0;
  }
  tmp___1 = __builtin_expect((long )tmp___0, 1L);
  if (tmp___1) {

  } else {
    vgPlain_assert_fail((Bool )1, (Char const   *)"SUCCESS",
                        (Char const   *)"m_syswrap/syswrap-linux.c", 2990,
                        (Char const   *)"vgSysWrap_linux_sys_rt_sigprocmask_after",
                        "");
  }
  tmp___2 = getRES(status);
  if (tmp___2 == 0UL) {
    if (arrghs->arg3 != 0UL) {
      while (1) {
        if (vgPlain_tdict.track_post_mem_write) {
          (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                  arrghs->arg3,
                                                  (SizeT )sizeof(vki_sigset_t ));
        } else {

        }
        break;
      }
    } else {

    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_rt_sigpending_before(ThreadId tid ,
                                              SyscallArgLayout *layout ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ,
                                              UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_rt_sigpending ( %#lx )", arrghs->arg1);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_sigset_t *) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_sigset_t *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2999,
                            (Char const   *)"vgSysWrap_linux_sys_rt_sigpending_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2999,
                            (Char const   *)"vgSysWrap_linux_sys_rt_sigpending_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"rt_sigpending(set)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_sigset_t *));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(vki_size_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_size_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2999,
                            (Char const   *)"vgSysWrap_linux_sys_rt_sigpending_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 2999,
                            (Char const   *)"vgSysWrap_linux_sys_rt_sigpending_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"rt_sigpending(sigsetsize)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(vki_size_t ));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"rt_sigpending(set)",
                                             arrghs->arg1,
                                             (SizeT )sizeof(vki_sigset_t ));
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_rt_sigpending_after(ThreadId tid ,
                                             SyscallArgs *arrghs ,
                                             SyscallStatus *status ) 
{ 


  {
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg1,
                                              (SizeT )sizeof(vki_sigset_t ));
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_rt_sigtimedwait_before(ThreadId tid ,
                                                SyscallArgLayout *layout ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ,
                                                UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;

  {
  *flags |= (unsigned long )(1 << 1);
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_rt_sigtimedwait ( %#lx, %#lx, %#lx, %lld )",
                   arrghs->arg1, arrghs->arg2, arrghs->arg3,
                   (ULong )arrghs->arg4);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_sigset_t const   *) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const vki_sigset_t *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3014,
                            (Char const   *)"vgSysWrap_linux_sys_rt_sigtimedwait_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3014,
                            (Char const   *)"vgSysWrap_linux_sys_rt_sigtimedwait_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"rt_sigtimedwait(set)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_sigset_t const   *));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(vki_siginfo_t *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_siginfo_t *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3014,
                            (Char const   *)"vgSysWrap_linux_sys_rt_sigtimedwait_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3014,
                            (Char const   *)"vgSysWrap_linux_sys_rt_sigtimedwait_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"rt_sigtimedwait(info)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(vki_siginfo_t *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(struct timespec  const  *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const struct timespec *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3014,
                            (Char const   *)"vgSysWrap_linux_sys_rt_sigtimedwait_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3014,
                            (Char const   *)"vgSysWrap_linux_sys_rt_sigtimedwait_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"rt_sigtimedwait(timeout)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(struct timespec  const  *));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(vki_size_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_size_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3014,
                            (Char const   *)"vgSysWrap_linux_sys_rt_sigtimedwait_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3014,
                            (Char const   *)"vgSysWrap_linux_sys_rt_sigtimedwait_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"rt_sigtimedwait(sigsetsize)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(vki_size_t ));
      break;
    }
  } else {

  }
  if (arrghs->arg1 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"rt_sigtimedwait(set)",
                                              arrghs->arg1,
                                              (SizeT )sizeof(vki_sigset_t ));
      } else {

      }
      break;
    }
  } else {

  }
  if (arrghs->arg2 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_write) {
        (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                               (Char *)"rt_sigtimedwait(info)",
                                               arrghs->arg2,
                                               (SizeT )sizeof(vki_siginfo_t ));
      } else {

      }
      break;
    }
  } else {

  }
  if (arrghs->arg3 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"rt_sigtimedwait(timeout)",
                                              arrghs->arg3,
                                              (SizeT )sizeof(struct vki_timespec ));
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_rt_sigtimedwait_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) 
{ 


  {
  if (arrghs->arg2 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg2,
                                                (SizeT )sizeof(vki_siginfo_t ));
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_rt_sigqueueinfo_before(ThreadId tid ,
                                                SyscallArgLayout *layout ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ,
                                                UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_rt_sigqueueinfo(%ld, %ld, %#lx)", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3033,
                            (Char const   *)"vgSysWrap_linux_sys_rt_sigqueueinfo_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3033,
                            (Char const   *)"vgSysWrap_linux_sys_rt_sigqueueinfo_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"rt_sigqueueinfo(pid)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3033,
                            (Char const   *)"vgSysWrap_linux_sys_rt_sigqueueinfo_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3033,
                            (Char const   *)"vgSysWrap_linux_sys_rt_sigqueueinfo_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"rt_sigqueueinfo(sig)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(vki_siginfo_t *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_siginfo_t *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3033,
                            (Char const   *)"vgSysWrap_linux_sys_rt_sigqueueinfo_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3033,
                            (Char const   *)"vgSysWrap_linux_sys_rt_sigqueueinfo_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"rt_sigqueueinfo(uinfo)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(vki_siginfo_t *));
      break;
    }
  } else {

  }
  if (arrghs->arg2 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"rt_sigqueueinfo(uinfo)",
                                              arrghs->arg3, (SizeT )128);
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_rt_sigqueueinfo_after(ThreadId tid ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ) 
{ 
  Word wzz ;
  int tmp ;
  long tmp___0 ;
  Bool tmp___1 ;

  {
  tmp___1 = vgModuleLocal_client_signal_OK((Int )arrghs->arg2);
  if (tmp___1) {

  } else {
    while (1) {
      wzz = (Word )22;
      if (wzz >= 0L) {
        if (wzz < 10000L) {
          tmp = 1;
        } else {
          tmp = 0;
        }
      } else {
        tmp = 0;
      }
      tmp___0 = __builtin_expect((long )tmp, 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"wzz >= 0 && wzz < 10000",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3040,
                            (Char const   *)"vgSysWrap_linux_sys_rt_sigqueueinfo_after",
                            "");
      }
      status->what = (enum __anonenum_what_129 )1;
      status->sres = vgPlain_mk_SysRes_Error((UWord )wzz);
      break;
    }
  }
  return;
}
}
void vgSysWrap_linux_sys_rt_tgsigqueueinfo_before(ThreadId tid ,
                                                  SyscallArgLayout *layout ,
                                                  SyscallArgs *arrghs ,
                                                  SyscallStatus *status ,
                                                  UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_rt_tgsigqueueinfo(%ld, %ld, %ld, %#lx)", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3, arrghs->arg4);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3047,
                            (Char const   *)"vgSysWrap_linux_sys_rt_tgsigqueueinfo_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3047,
                            (Char const   *)"vgSysWrap_linux_sys_rt_tgsigqueueinfo_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"rt_tgsigqueueinfo(tgid)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3047,
                            (Char const   *)"vgSysWrap_linux_sys_rt_tgsigqueueinfo_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3047,
                            (Char const   *)"vgSysWrap_linux_sys_rt_tgsigqueueinfo_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"rt_tgsigqueueinfo(pid)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3047,
                            (Char const   *)"vgSysWrap_linux_sys_rt_tgsigqueueinfo_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3047,
                            (Char const   *)"vgSysWrap_linux_sys_rt_tgsigqueueinfo_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"rt_tgsigqueueinfo(sig)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(vki_siginfo_t *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_siginfo_t *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3047,
                            (Char const   *)"vgSysWrap_linux_sys_rt_tgsigqueueinfo_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3047,
                            (Char const   *)"vgSysWrap_linux_sys_rt_tgsigqueueinfo_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"rt_tgsigqueueinfo(uinfo)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(vki_siginfo_t *));
      break;
    }
  } else {

  }
  if (arrghs->arg3 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"rt_tgsigqueueinfo(uinfo)",
                                              arrghs->arg4, (SizeT )128);
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_rt_tgsigqueueinfo_after(ThreadId tid ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ) 
{ 
  Word wzz ;
  int tmp ;
  long tmp___0 ;
  Bool tmp___1 ;

  {
  tmp___1 = vgModuleLocal_client_signal_OK((Int )arrghs->arg3);
  if (tmp___1) {

  } else {
    while (1) {
      wzz = (Word )22;
      if (wzz >= 0L) {
        if (wzz < 10000L) {
          tmp = 1;
        } else {
          tmp = 0;
        }
      } else {
        tmp = 0;
      }
      tmp___0 = __builtin_expect((long )tmp, 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"wzz >= 0 && wzz < 10000",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3055,
                            (Char const   *)"vgSysWrap_linux_sys_rt_tgsigqueueinfo_after",
                            "");
      }
      status->what = (enum __anonenum_what_129 )1;
      status->sres = vgPlain_mk_SysRes_Error((UWord )wzz);
      break;
    }
  }
  return;
}
}
void vgSysWrap_linux_sys_rt_sigsuspend_before(ThreadId tid ,
                                              SyscallArgLayout *layout ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ,
                                              UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  *flags |= (unsigned long )(1 << 1);
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_rt_sigsuspend ( %#lx, %ld )", arrghs->arg1, arrghs->arg2);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_sigset_t *) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_sigset_t *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3070,
                            (Char const   *)"vgSysWrap_linux_sys_rt_sigsuspend_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3070,
                            (Char const   *)"vgSysWrap_linux_sys_rt_sigsuspend_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"rt_sigsuspend(mask)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_sigset_t *));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(vki_size_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_size_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3070,
                            (Char const   *)"vgSysWrap_linux_sys_rt_sigsuspend_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3070,
                            (Char const   *)"vgSysWrap_linux_sys_rt_sigsuspend_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"rt_sigsuspend(size)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(vki_size_t ));
      break;
    }
  } else {

  }
  if (arrghs->arg1 != (Addr )((void *)0)) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"rt_sigsuspend(mask)",
                                              arrghs->arg1,
                                              (SizeT )sizeof(vki_sigset_t ));
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgModuleLocal_linux_PRE_sys_msgsnd(ThreadId tid , UWord arg0 , UWord arg1 ,
                                        UWord arg2 , UWord arg3 ) 
{ 
  struct vki_msgbuf *msgp ;

  {
  msgp = (struct vki_msgbuf *)arg1;
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"msgsnd(msgp->mtype)",
                                            (Addr )(& msgp->mtype),
                                            (SizeT )sizeof(msgp->mtype));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"msgsnd(msgp->mtext)",
                                            (Addr )(& msgp->mtext), arg2);
    } else {

    }
    break;
  }
  return;
}
}
void vgModuleLocal_linux_PRE_sys_msgrcv(ThreadId tid , UWord arg0 , UWord arg1 ,
                                        UWord arg2 , UWord arg3 , UWord arg4 ) 
{ 
  struct vki_msgbuf *msgp ;

  {
  msgp = (struct vki_msgbuf *)arg1;
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"msgrcv(msgp->mtype)",
                                             (Addr )(& msgp->mtype),
                                             (SizeT )sizeof(msgp->mtype));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"msgrcv(msgp->mtext)",
                                             (Addr )(& msgp->mtext), arg2);
    } else {

    }
    break;
  }
  return;
}
}
void vgModuleLocal_linux_POST_sys_msgrcv(ThreadId tid , UWord res , UWord arg0 ,
                                         UWord arg1 , UWord arg2 , UWord arg3 ,
                                         UWord arg4 ) 
{ 
  struct vki_msgbuf *msgp ;

  {
  msgp = (struct vki_msgbuf *)arg1;
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                              (Addr )(& msgp->mtype),
                                              (SizeT )sizeof(msgp->mtype));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                              (Addr )(& msgp->mtext), res);
    } else {

    }
    break;
  }
  return;
}
}
void vgModuleLocal_linux_PRE_sys_msgctl(ThreadId tid , UWord arg0 , UWord arg1 ,
                                        UWord arg2 ) 
{ 


  {
  switch (arg1) {
  case 268UL: 
  case 259UL: 
  case 12UL: 
  case 3UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"msgctl(IPC_INFO, buf)",
                                             arg2,
                                             (SizeT )sizeof(struct vki_msginfo ));
    } else {

    }
    break;
  }
  break;
  case 11UL: 
  case 2UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"msgctl(IPC_STAT, buf)",
                                             arg2,
                                             (SizeT )sizeof(struct vki_msqid_ds ));
    } else {

    }
    break;
  }
  break;
  case 267UL: 
  case 258UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"msgctl(IPC_STAT, arg.buf)",
                                             arg2,
                                             (SizeT )sizeof(struct vki_msqid64_ds ));
    } else {

    }
    break;
  }
  break;
  case 1UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"msgctl(IPC_SET, arg.buf)",
                                            arg2,
                                            (SizeT )sizeof(struct vki_msqid_ds ));
    } else {

    }
    break;
  }
  break;
  case 257UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"msgctl(IPC_SET, arg.buf)",
                                            arg2,
                                            (SizeT )sizeof(struct vki_msqid64_ds ));
    } else {

    }
    break;
  }
  break;
  }
  return;
}
}
void vgModuleLocal_linux_POST_sys_msgctl(ThreadId tid , UWord res , UWord arg0 ,
                                         UWord arg1 , UWord arg2 ) 
{ 


  {
  switch (arg1) {
  case 268UL: 
  case 259UL: 
  case 12UL: 
  case 3UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arg2,
                                              (SizeT )sizeof(struct vki_msginfo ));
    } else {

    }
    break;
  }
  break;
  case 11UL: 
  case 2UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arg2,
                                              (SizeT )sizeof(struct vki_msqid_ds ));
    } else {

    }
    break;
  }
  break;
  case 267UL: 
  case 258UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arg2,
                                              (SizeT )sizeof(struct vki_msqid64_ds ));
    } else {

    }
    break;
  }
  break;
  }
  return;
}
}
void vgSysWrap_linux_sys_openat_before(ThreadId tid , SyscallArgLayout *layout ,
                                       SyscallArgs *arrghs ,
                                       SyscallStatus *status , UWord *flags ) 
{ 
  HChar name[30] ;
  SysRes sres ;
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;
  Int here___3 ;
  long tmp___7 ;
  long tmp___8 ;
  Int here___4 ;
  long tmp___9 ;
  long tmp___10 ;
  Int here___5 ;
  long tmp___11 ;
  long tmp___12 ;
  Word wzz ;
  int tmp___13 ;
  long tmp___14 ;
  Bool tmp___15 ;
  Int tmp___16 ;
  OffT off ;
  UWord tmp___17 ;
  Off64T tmp___18 ;
  Word wzz___0 ;
  int tmp___19 ;
  long tmp___20 ;
  Bool tmp___21 ;
  Bool tmp___22 ;
  Int tmp___23 ;
  Int tmp___24 ;

  {
  if (arrghs->arg3 & 64UL) {
    if (vgPlain_clo_trace_syscalls) {
      vgPlain_printf("sys_openat ( %ld, %#lx(%s), %ld, %ld )", arrghs->arg1,
                     arrghs->arg2, (char *)arrghs->arg2, arrghs->arg3,
                     arrghs->arg4);
    } else {

    }
    if (vgPlain_tdict.track_pre_reg_read) {
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"(syscallno)",
                                            (PtrdiffT )layout->o_sysno,
                                            (SizeT )sizeof(UWord ));
      while (1) {
        here = layout->o_arg1;
        tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                               1L);
        if (tmp) {

        } else {
          vgPlain_assert_fail((Bool )1,
                              (Char const   *)"sizeof(int) <= sizeof(UWord)",
                              (Char const   *)"m_syswrap/syswrap-linux.c", 3181,
                              (Char const   *)"vgSysWrap_linux_sys_openat_before",
                              "");
        }
        tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
        if (tmp___0) {

        } else {
          vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                              (Char const   *)"m_syswrap/syswrap-linux.c", 3181,
                              (Char const   *)"vgSysWrap_linux_sys_openat_before",
                              "");
        }
        (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                              (Char *)"openat(dfd)",
                                              (PtrdiffT )here,
                                              (SizeT )sizeof(int ));
        break;
      }
      while (1) {
        here___0 = layout->o_arg2;
        tmp___1 = __builtin_expect((long )(! (! (sizeof(char const   *) <= sizeof(UWord )))),
                                   1L);
        if (tmp___1) {

        } else {
          vgPlain_assert_fail((Bool )1,
                              (Char const   *)"sizeof(const char *) <= sizeof(UWord)",
                              (Char const   *)"m_syswrap/syswrap-linux.c", 3181,
                              (Char const   *)"vgSysWrap_linux_sys_openat_before",
                              "");
        }
        tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
        if (tmp___2) {

        } else {
          vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                              (Char const   *)"m_syswrap/syswrap-linux.c", 3181,
                              (Char const   *)"vgSysWrap_linux_sys_openat_before",
                              "");
        }
        (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                              (Char *)"openat(filename)",
                                              (PtrdiffT )here___0,
                                              (SizeT )sizeof(char const   *));
        break;
      }
      while (1) {
        here___1 = layout->o_arg3;
        tmp___3 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                   1L);
        if (tmp___3) {

        } else {
          vgPlain_assert_fail((Bool )1,
                              (Char const   *)"sizeof(int) <= sizeof(UWord)",
                              (Char const   *)"m_syswrap/syswrap-linux.c", 3181,
                              (Char const   *)"vgSysWrap_linux_sys_openat_before",
                              "");
        }
        tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
        if (tmp___4) {

        } else {
          vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                              (Char const   *)"m_syswrap/syswrap-linux.c", 3181,
                              (Char const   *)"vgSysWrap_linux_sys_openat_before",
                              "");
        }
        (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                              (Char *)"openat(flags)",
                                              (PtrdiffT )here___1,
                                              (SizeT )sizeof(int ));
        break;
      }
      while (1) {
        here___2 = layout->o_arg4;
        tmp___5 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                   1L);
        if (tmp___5) {

        } else {
          vgPlain_assert_fail((Bool )1,
                              (Char const   *)"sizeof(int) <= sizeof(UWord)",
                              (Char const   *)"m_syswrap/syswrap-linux.c", 3181,
                              (Char const   *)"vgSysWrap_linux_sys_openat_before",
                              "");
        }
        tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
        if (tmp___6) {

        } else {
          vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                              (Char const   *)"m_syswrap/syswrap-linux.c", 3181,
                              (Char const   *)"vgSysWrap_linux_sys_openat_before",
                              "");
        }
        (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                              (Char *)"openat(mode)",
                                              (PtrdiffT )here___2,
                                              (SizeT )sizeof(int ));
        break;
      }
    } else {

    }
  } else {
    if (vgPlain_clo_trace_syscalls) {
      vgPlain_printf("sys_openat ( %ld, %#lx(%s), %ld )", arrghs->arg1,
                     arrghs->arg2, (char *)arrghs->arg2, arrghs->arg3);
    } else {

    }
    if (vgPlain_tdict.track_pre_reg_read) {
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"(syscallno)",
                                            (PtrdiffT )layout->o_sysno,
                                            (SizeT )sizeof(UWord ));
      while (1) {
        here___3 = layout->o_arg1;
        tmp___7 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                   1L);
        if (tmp___7) {

        } else {
          vgPlain_assert_fail((Bool )1,
                              (Char const   *)"sizeof(int) <= sizeof(UWord)",
                              (Char const   *)"m_syswrap/syswrap-linux.c", 3186,
                              (Char const   *)"vgSysWrap_linux_sys_openat_before",
                              "");
        }
        tmp___8 = __builtin_expect((long )(! (! (here___3 >= 0))), 1L);
        if (tmp___8) {

        } else {
          vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                              (Char const   *)"m_syswrap/syswrap-linux.c", 3186,
                              (Char const   *)"vgSysWrap_linux_sys_openat_before",
                              "");
        }
        (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                              (Char *)"openat(dfd)",
                                              (PtrdiffT )here___3,
                                              (SizeT )sizeof(int ));
        break;
      }
      while (1) {
        here___4 = layout->o_arg2;
        tmp___9 = __builtin_expect((long )(! (! (sizeof(char const   *) <= sizeof(UWord )))),
                                   1L);
        if (tmp___9) {

        } else {
          vgPlain_assert_fail((Bool )1,
                              (Char const   *)"sizeof(const char *) <= sizeof(UWord)",
                              (Char const   *)"m_syswrap/syswrap-linux.c", 3186,
                              (Char const   *)"vgSysWrap_linux_sys_openat_before",
                              "");
        }
        tmp___10 = __builtin_expect((long )(! (! (here___4 >= 0))), 1L);
        if (tmp___10) {

        } else {
          vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                              (Char const   *)"m_syswrap/syswrap-linux.c", 3186,
                              (Char const   *)"vgSysWrap_linux_sys_openat_before",
                              "");
        }
        (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                              (Char *)"openat(filename)",
                                              (PtrdiffT )here___4,
                                              (SizeT )sizeof(char const   *));
        break;
      }
      while (1) {
        here___5 = layout->o_arg3;
        tmp___11 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                    1L);
        if (tmp___11) {

        } else {
          vgPlain_assert_fail((Bool )1,
                              (Char const   *)"sizeof(int) <= sizeof(UWord)",
                              (Char const   *)"m_syswrap/syswrap-linux.c", 3186,
                              (Char const   *)"vgSysWrap_linux_sys_openat_before",
                              "");
        }
        tmp___12 = __builtin_expect((long )(! (! (here___5 >= 0))), 1L);
        if (tmp___12) {

        } else {
          vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                              (Char const   *)"m_syswrap/syswrap-linux.c", 3186,
                              (Char const   *)"vgSysWrap_linux_sys_openat_before",
                              "");
        }
        (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                              (Char *)"openat(flags)",
                                              (PtrdiffT )here___5,
                                              (SizeT )sizeof(int ));
        break;
      }
    } else {

    }
  }
  if (arrghs->arg1 != 4294967196UL) {
    tmp___15 = vgModuleLocal_fd_allowed((Int )arrghs->arg1,
                                        (Char const   *)"openat", tid, (Bool )0);
    if (tmp___15) {
      goto _L;
    } else {
      while (1) {
        wzz = (Word )9;
        if (wzz >= 0L) {
          if (wzz < 10000L) {
            tmp___13 = 1;
          } else {
            tmp___13 = 0;
          }
        } else {
          tmp___13 = 0;
        }
        tmp___14 = __builtin_expect((long )tmp___13, 1L);
        if (tmp___14) {

        } else {
          vgPlain_assert_fail((Bool )1,
                              (Char const   *)"wzz >= 0 && wzz < 10000",
                              (Char const   *)"m_syswrap/syswrap-linux.c", 3190,
                              (Char const   *)"vgSysWrap_linux_sys_openat_before",
                              "");
        }
        status->what = (enum __anonenum_what_129 )1;
        status->sres = vgPlain_mk_SysRes_Error((UWord )wzz);
        break;
      }
    }
  } else {
    _L: /* CIL Label */ 
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read_asciiz) {
        (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                     (Char *)"openat(filename)",
                                                     arrghs->arg2);
      } else {

      }
      break;
    }
  }
  tmp___16 = vgPlain_getpid();
  vgPlain_sprintf((Char *)(name), "/proc/%d/cmdline", tmp___16);
  tmp___22 = vgModuleLocal_safe_to_deref((void *)arrghs->arg2, (SizeT )1);
  if (tmp___22) {
    tmp___23 = vgPlain_strcmp((Char const   *)((Char *)arrghs->arg2),
                              (Char const   *)(name));
    if (tmp___23 == 0) {
      goto _L___0;
    } else {
      tmp___24 = vgPlain_strcmp((Char const   *)((Char *)arrghs->arg2),
                                (Char const   *)"/proc/self/cmdline");
      if (tmp___24 == 0) {
        _L___0: /* CIL Label */ 
        sres = vgPlain_dup(vgPlain_cl_cmdline_fd);
        while (1) {
          status->what = (enum __anonenum_what_129 )1;
          status->sres = sres;
          break;
        }
        tmp___21 = sr_isError(sres);
        if (tmp___21) {

        } else {
          tmp___17 = sr_Res(sres);
          tmp___18 = vgPlain_lseek((Int )tmp___17, (Off64T )0, 0);
          off = (OffT )tmp___18;
          if (off < 0L) {
            while (1) {
              wzz___0 = (Word )24;
              if (wzz___0 >= 0L) {
                if (wzz___0 < 10000L) {
                  tmp___19 = 1;
                } else {
                  tmp___19 = 0;
                }
              } else {
                tmp___19 = 0;
              }
              tmp___20 = __builtin_expect((long )tmp___19, 1L);
              if (tmp___20) {

              } else {
                vgPlain_assert_fail((Bool )1,
                                    (Char const   *)"wzz >= 0 && wzz < 10000",
                                    (Char const   *)"m_syswrap/syswrap-linux.c",
                                    3208,
                                    (Char const   *)"vgSysWrap_linux_sys_openat_before",
                                    "");
              }
              status->what = (enum __anonenum_what_129 )1;
              status->sres = vgPlain_mk_SysRes_Error((UWord )wzz___0);
              break;
            }
          } else {

          }
        }
        return;
      } else {

      }
    }
  } else {

  }
  *flags |= (unsigned long )(1 << 1);
  return;
}
}
void vgSysWrap_linux_sys_openat_after(ThreadId tid , SyscallArgs *arrghs ,
                                      SyscallStatus *status ) 
{ 
  Bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  UWord tmp___2 ;
  Word wzz ;
  int tmp___3 ;
  long tmp___4 ;
  UWord tmp___5 ;
  UWord tmp___6 ;
  Bool tmp___7 ;

  {
  if ((unsigned int )status->what == 1U) {
    tmp = sr_isError(status->sres);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
  } else {
    tmp___0 = 0;
  }
  tmp___1 = __builtin_expect((long )tmp___0, 1L);
  if (tmp___1) {

  } else {
    vgPlain_assert_fail((Bool )1, (Char const   *)"SUCCESS",
                        (Char const   *)"m_syswrap/syswrap-linux.c", 3219,
                        (Char const   *)"vgSysWrap_linux_sys_openat_after", "");
  }
  tmp___6 = getRES(status);
  tmp___7 = vgModuleLocal_fd_allowed((Int )tmp___6, (Char const   *)"openat",
                                     tid, (Bool )1);
  if (tmp___7) {
    if (vgPlain_clo_track_fds) {
      tmp___5 = getRES(status);
      vgModuleLocal_record_fd_open_with_given_name(tid, (Int )tmp___5,
                                                   (char *)((Char *)arrghs->arg2));
    } else {

    }
  } else {
    tmp___2 = getRES(status);
    vgPlain_close((Int )tmp___2);
    while (1) {
      wzz = (Word )24;
      if (wzz >= 0L) {
        if (wzz < 10000L) {
          tmp___3 = 1;
        } else {
          tmp___3 = 0;
        }
      } else {
        tmp___3 = 0;
      }
      tmp___4 = __builtin_expect((long )tmp___3, 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"wzz >= 0 && wzz < 10000",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3222,
                            (Char const   *)"vgSysWrap_linux_sys_openat_after",
                            "");
      }
      status->what = (enum __anonenum_what_129 )1;
      status->sres = vgPlain_mk_SysRes_Error((UWord )wzz);
      break;
    }
  }
  return;
}
}
void vgSysWrap_linux_sys_mkdirat_before(ThreadId tid ,
                                        SyscallArgLayout *layout ,
                                        SyscallArgs *arrghs ,
                                        SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  *flags |= (unsigned long )(1 << 1);
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_mkdirat ( %ld, %#lx(%s), %ld )", arrghs->arg1,
                   arrghs->arg2, (char *)arrghs->arg2, arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3234,
                            (Char const   *)"vgSysWrap_linux_sys_mkdirat_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3234,
                            (Char const   *)"vgSysWrap_linux_sys_mkdirat_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"mkdirat(dfd)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(char const   *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3234,
                            (Char const   *)"vgSysWrap_linux_sys_mkdirat_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3234,
                            (Char const   *)"vgSysWrap_linux_sys_mkdirat_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"mkdirat(pathname)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(char const   *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3234,
                            (Char const   *)"vgSysWrap_linux_sys_mkdirat_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3234,
                            (Char const   *)"vgSysWrap_linux_sys_mkdirat_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"mkdirat(mode)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"mkdirat(pathname)",
                                                   arrghs->arg2);
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_mknodat_before(ThreadId tid ,
                                        SyscallArgLayout *layout ,
                                        SyscallArgs *arrghs ,
                                        SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_mknodat ( %ld, %#lx(%s), 0x%lx, 0x%lx )", arrghs->arg1,
                   arrghs->arg2, (char *)arrghs->arg2, arrghs->arg3,
                   arrghs->arg4);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3242,
                            (Char const   *)"vgSysWrap_linux_sys_mknodat_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3242,
                            (Char const   *)"vgSysWrap_linux_sys_mknodat_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"mknodat(dfd)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(char const   *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3242,
                            (Char const   *)"vgSysWrap_linux_sys_mknodat_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3242,
                            (Char const   *)"vgSysWrap_linux_sys_mknodat_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"mknodat(pathname)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(char const   *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3242,
                            (Char const   *)"vgSysWrap_linux_sys_mknodat_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3242,
                            (Char const   *)"vgSysWrap_linux_sys_mknodat_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"mknodat(mode)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3242,
                            (Char const   *)"vgSysWrap_linux_sys_mknodat_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3242,
                            (Char const   *)"vgSysWrap_linux_sys_mknodat_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"mknodat(dev)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"mknodat(pathname)",
                                                   arrghs->arg2);
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_fchownat_before(ThreadId tid ,
                                         SyscallArgLayout *layout ,
                                         SyscallArgs *arrghs ,
                                         SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_fchownat ( %ld, %#lx(%s), 0x%lx, 0x%lx )", arrghs->arg1,
                   arrghs->arg2, (char *)arrghs->arg2, arrghs->arg3,
                   arrghs->arg4);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3251,
                            (Char const   *)"vgSysWrap_linux_sys_fchownat_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3251,
                            (Char const   *)"vgSysWrap_linux_sys_fchownat_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fchownat(dfd)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(char const   *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3251,
                            (Char const   *)"vgSysWrap_linux_sys_fchownat_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3251,
                            (Char const   *)"vgSysWrap_linux_sys_fchownat_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fchownat(path)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(char const   *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(vki_uid_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_uid_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3251,
                            (Char const   *)"vgSysWrap_linux_sys_fchownat_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3251,
                            (Char const   *)"vgSysWrap_linux_sys_fchownat_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fchownat(owner)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(vki_uid_t ));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(vki_gid_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_gid_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3251,
                            (Char const   *)"vgSysWrap_linux_sys_fchownat_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3251,
                            (Char const   *)"vgSysWrap_linux_sys_fchownat_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fchownat(group)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(vki_gid_t ));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"fchownat(path)",
                                                   arrghs->arg2);
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_futimesat_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_futimesat ( %ld, %#lx(%s), %#lx )", arrghs->arg1,
                   arrghs->arg2, (char *)arrghs->arg2, arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3259,
                            (Char const   *)"vgSysWrap_linux_sys_futimesat_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3259,
                            (Char const   *)"vgSysWrap_linux_sys_futimesat_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"futimesat(dfd)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(char *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3259,
                            (Char const   *)"vgSysWrap_linux_sys_futimesat_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3259,
                            (Char const   *)"vgSysWrap_linux_sys_futimesat_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"futimesat(filename)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(char *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(struct timeval *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct timeval *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3259,
                            (Char const   *)"vgSysWrap_linux_sys_futimesat_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3259,
                            (Char const   *)"vgSysWrap_linux_sys_futimesat_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"futimesat(tvp)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(struct timeval *));
      break;
    }
  } else {

  }
  if (arrghs->arg2 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read_asciiz) {
        (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                     (Char *)"futimesat(filename)",
                                                     arrghs->arg2);
      } else {

      }
      break;
    }
  } else {

  }
  if (arrghs->arg3 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"futimesat(tvp)",
                                              arrghs->arg3,
                                              (SizeT )(2U * sizeof(struct vki_timeval )));
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_utimensat_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_utimensat ( %ld, %#lx(%s), %#lx, 0x%lx )", arrghs->arg1,
                   arrghs->arg2, (char *)arrghs->arg2, arrghs->arg3,
                   arrghs->arg4);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3270,
                            (Char const   *)"vgSysWrap_linux_sys_utimensat_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3270,
                            (Char const   *)"vgSysWrap_linux_sys_utimensat_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"utimensat(dfd)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(char *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3270,
                            (Char const   *)"vgSysWrap_linux_sys_utimensat_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3270,
                            (Char const   *)"vgSysWrap_linux_sys_utimensat_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"utimensat(filename)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(char *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(struct timespec *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct timespec *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3270,
                            (Char const   *)"vgSysWrap_linux_sys_utimensat_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3270,
                            (Char const   *)"vgSysWrap_linux_sys_utimensat_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"utimensat(utimes)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(struct timespec *));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3270,
                            (Char const   *)"vgSysWrap_linux_sys_utimensat_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3270,
                            (Char const   *)"vgSysWrap_linux_sys_utimensat_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"utimensat(flags)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  if (arrghs->arg2 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read_asciiz) {
        (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                     (Char *)"utimensat(filename)",
                                                     arrghs->arg2);
      } else {

      }
      break;
    }
  } else {

  }
  if (arrghs->arg3 != 0UL) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"utimensat(tvp)",
                                              arrghs->arg3,
                                              (SizeT )(2U * sizeof(struct vki_timespec )));
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_newfstatat_before(ThreadId tid ,
                                           SyscallArgLayout *layout ,
                                           SyscallArgs *arrghs ,
                                           SyscallStatus *status , UWord *flags ) 
{ 
  Char *tmp ;
  Int here ;
  long tmp___0 ;
  long tmp___1 ;
  Int here___0 ;
  long tmp___2 ;
  long tmp___3 ;
  Int here___1 ;
  long tmp___4 ;
  long tmp___5 ;

  {
  tmp = vgPlain_strstr((Char const   *)vgPlain_clo_sim_hints,
                       (Char *)"fuse-compatible");
  if (tmp) {
    *flags |= (unsigned long )(1 << 1);
  } else {

  }
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_newfstatat ( %ld, %#lx(%s), %#lx )", arrghs->arg1,
                   arrghs->arg2, (char *)arrghs->arg2, arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp___0 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3282,
                            (Char const   *)"vgSysWrap_linux_sys_newfstatat_before",
                            "");
      }
      tmp___1 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3282,
                            (Char const   *)"vgSysWrap_linux_sys_newfstatat_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fstatat(dfd)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___2 = __builtin_expect((long )(! (! (sizeof(char *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3282,
                            (Char const   *)"vgSysWrap_linux_sys_newfstatat_before",
                            "");
      }
      tmp___3 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3282,
                            (Char const   *)"vgSysWrap_linux_sys_newfstatat_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fstatat(file_name)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(char *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___4 = __builtin_expect((long )(! (! (sizeof(struct stat *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct stat *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3282,
                            (Char const   *)"vgSysWrap_linux_sys_newfstatat_before",
                            "");
      }
      tmp___5 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3282,
                            (Char const   *)"vgSysWrap_linux_sys_newfstatat_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fstatat(buf)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(struct stat *));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"fstatat(file_name)",
                                                   arrghs->arg2);
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"fstatat(buf)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(struct vki_stat ));
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_newfstatat_after(ThreadId tid , SyscallArgs *arrghs ,
                                          SyscallStatus *status ) 
{ 


  {
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(struct vki_stat ));
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_unlinkat_before(ThreadId tid ,
                                         SyscallArgLayout *layout ,
                                         SyscallArgs *arrghs ,
                                         SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  *flags |= (unsigned long )(1 << 1);
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_unlinkat ( %ld, %#lx(%s) )", arrghs->arg1, arrghs->arg2,
                   (char *)arrghs->arg2);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3296,
                            (Char const   *)"vgSysWrap_linux_sys_unlinkat_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3296,
                            (Char const   *)"vgSysWrap_linux_sys_unlinkat_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"unlinkat(dfd)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(char const   *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3296,
                            (Char const   *)"vgSysWrap_linux_sys_unlinkat_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3296,
                            (Char const   *)"vgSysWrap_linux_sys_unlinkat_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"unlinkat(pathname)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(char const   *));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"unlinkat(pathname)",
                                                   arrghs->arg2);
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_renameat_before(ThreadId tid ,
                                         SyscallArgLayout *layout ,
                                         SyscallArgs *arrghs ,
                                         SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_renameat ( %ld, %#lx(%s), %ld, %#lx(%s) )",
                   arrghs->arg1, arrghs->arg2, (char *)arrghs->arg2,
                   arrghs->arg3, arrghs->arg4, (char *)arrghs->arg4);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3305,
                            (Char const   *)"vgSysWrap_linux_sys_renameat_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3305,
                            (Char const   *)"vgSysWrap_linux_sys_renameat_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"renameat(olddfd)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(char const   *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3305,
                            (Char const   *)"vgSysWrap_linux_sys_renameat_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3305,
                            (Char const   *)"vgSysWrap_linux_sys_renameat_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"renameat(oldpath)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(char const   *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3305,
                            (Char const   *)"vgSysWrap_linux_sys_renameat_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3305,
                            (Char const   *)"vgSysWrap_linux_sys_renameat_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"renameat(newdfd)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(char const   *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3305,
                            (Char const   *)"vgSysWrap_linux_sys_renameat_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3305,
                            (Char const   *)"vgSysWrap_linux_sys_renameat_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"renameat(newpath)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(char const   *));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"renameat(oldpath)",
                                                   arrghs->arg2);
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"renameat(newpath)",
                                                   arrghs->arg4);
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_linkat_before(ThreadId tid , SyscallArgLayout *layout ,
                                       SyscallArgs *arrghs ,
                                       SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;
  Int here___3 ;
  long tmp___7 ;
  long tmp___8 ;

  {
  *flags |= (unsigned long )(1 << 1);
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_linkat ( %ld, %#lx(%s), %ld, %#lx(%s), %ld )",
                   arrghs->arg1, arrghs->arg2, (char *)arrghs->arg2,
                   arrghs->arg3, arrghs->arg4, (char *)arrghs->arg4,
                   arrghs->arg5);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3317,
                            (Char const   *)"vgSysWrap_linux_sys_linkat_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3317,
                            (Char const   *)"vgSysWrap_linux_sys_linkat_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"linkat(olddfd)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(char const   *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3317,
                            (Char const   *)"vgSysWrap_linux_sys_linkat_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3317,
                            (Char const   *)"vgSysWrap_linux_sys_linkat_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"linkat(oldpath)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(char const   *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3317,
                            (Char const   *)"vgSysWrap_linux_sys_linkat_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3317,
                            (Char const   *)"vgSysWrap_linux_sys_linkat_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"linkat(newdfd)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(char const   *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3317,
                            (Char const   *)"vgSysWrap_linux_sys_linkat_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3317,
                            (Char const   *)"vgSysWrap_linux_sys_linkat_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"linkat(newpath)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(char const   *));
      break;
    }
    while (1) {
      here___3 = layout->o_arg5;
      tmp___7 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___7) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3317,
                            (Char const   *)"vgSysWrap_linux_sys_linkat_before",
                            "");
      }
      tmp___8 = __builtin_expect((long )(! (! (here___3 >= 0))), 1L);
      if (tmp___8) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3317,
                            (Char const   *)"vgSysWrap_linux_sys_linkat_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"linkat(flags)",
                                            (PtrdiffT )here___3,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"linkat(oldpath)",
                                                   arrghs->arg2);
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"linkat(newpath)",
                                                   arrghs->arg4);
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_symlinkat_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  *flags |= (unsigned long )(1 << 1);
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_symlinkat ( %#lx(%s), %ld, %#lx(%s) )", arrghs->arg1,
                   (char *)arrghs->arg1, arrghs->arg2, arrghs->arg3,
                   (char *)arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(char const   *) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3327,
                            (Char const   *)"vgSysWrap_linux_sys_symlinkat_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3327,
                            (Char const   *)"vgSysWrap_linux_sys_symlinkat_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"symlinkat(oldpath)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(char const   *));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3327,
                            (Char const   *)"vgSysWrap_linux_sys_symlinkat_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3327,
                            (Char const   *)"vgSysWrap_linux_sys_symlinkat_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"symlinkat(newdfd)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(char const   *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3327,
                            (Char const   *)"vgSysWrap_linux_sys_symlinkat_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3327,
                            (Char const   *)"vgSysWrap_linux_sys_symlinkat_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"symlinkat(newpath)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(char const   *));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"symlinkat(oldpath)",
                                                   arrghs->arg1);
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"symlinkat(newpath)",
                                                   arrghs->arg3);
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_readlinkat_before(ThreadId tid ,
                                           SyscallArgLayout *layout ,
                                           SyscallArgs *arrghs ,
                                           SyscallStatus *status , UWord *flags ) 
{ 
  HChar name[25] ;
  Word saved ;
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;
  Int tmp___7 ;
  Bool tmp___8 ;
  Int tmp___9 ;
  Int tmp___10 ;
  UWord tmp___11 ;
  Bool tmp___12 ;
  UWord tmp___13 ;

  {
  saved = arrghs->sysno;
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_readlinkat ( %ld, %#lx(%s), %#lx, %llu )", arrghs->arg1,
                   arrghs->arg2, (char *)arrghs->arg2, arrghs->arg3,
                   (ULong )arrghs->arg4);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3339,
                            (Char const   *)"vgSysWrap_linux_sys_readlinkat_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3339,
                            (Char const   *)"vgSysWrap_linux_sys_readlinkat_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"readlinkat(dfd)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(char const   *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3339,
                            (Char const   *)"vgSysWrap_linux_sys_readlinkat_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3339,
                            (Char const   *)"vgSysWrap_linux_sys_readlinkat_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"readlinkat(path)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(char const   *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(char *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3339,
                            (Char const   *)"vgSysWrap_linux_sys_readlinkat_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3339,
                            (Char const   *)"vgSysWrap_linux_sys_readlinkat_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"readlinkat(buf)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(char *));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3339,
                            (Char const   *)"vgSysWrap_linux_sys_readlinkat_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3339,
                            (Char const   *)"vgSysWrap_linux_sys_readlinkat_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"readlinkat(bufsiz)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"readlinkat(path)",
                                                   arrghs->arg2);
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"readlinkat(buf)",
                                             arrghs->arg3, arrghs->arg4);
    } else {

    }
    break;
  }
  tmp___7 = vgPlain_getpid();
  vgPlain_sprintf((Char *)(name), "/proc/%d/exe", tmp___7);
  tmp___8 = vgModuleLocal_safe_to_deref((void *)arrghs->arg2, (SizeT )1);
  if (tmp___8) {
    tmp___9 = vgPlain_strcmp((Char const   *)((Char *)arrghs->arg2),
                             (Char const   *)(name));
    if (tmp___9 == 0) {
      goto _L___0;
    } else {
      tmp___10 = vgPlain_strcmp((Char const   *)((Char *)arrghs->arg2),
                                (Char const   *)"/proc/self/exe");
      if (tmp___10 == 0) {
        _L___0: /* CIL Label */ 
        vgPlain_sprintf((Char *)(name), "/proc/self/fd/%d", vgPlain_cl_exec_fd);
        while (1) {
          status->what = (enum __anonenum_what_129 )1;
          status->sres = vgPlain_do_syscall((UWord )saved, arrghs->arg1,
                                            (UWord )(name), arrghs->arg3,
                                            arrghs->arg4, (UWord )0, (UWord )0,
                                            (UWord )0, (UWord )0);
          break;
        }
      } else {
        goto _L;
      }
    }
  } else {
    _L: /* CIL Label */ 
    while (1) {
      status->what = (enum __anonenum_what_129 )1;
      status->sres = vgPlain_do_syscall((UWord )saved, arrghs->arg1,
                                        arrghs->arg2, arrghs->arg3,
                                        arrghs->arg4, (UWord )0, (UWord )0,
                                        (UWord )0, (UWord )0);
      break;
    }
  }
  if ((unsigned int )status->what == 1U) {
    tmp___12 = sr_isError(status->sres);
    if (tmp___12) {

    } else {
      tmp___13 = getRES(status);
      if (tmp___13 > 0UL) {
        while (1) {
          if (vgPlain_tdict.track_post_mem_write) {
            tmp___11 = getRES(status);
            (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                    arrghs->arg3, tmp___11);
          } else {

          }
          break;
        }
      } else {

      }
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_fchmodat_before(ThreadId tid ,
                                         SyscallArgLayout *layout ,
                                         SyscallArgs *arrghs ,
                                         SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_fchmodat ( %ld, %#lx(%s), %ld )", arrghs->arg1,
                   arrghs->arg2, (char *)arrghs->arg2, arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3367,
                            (Char const   *)"vgSysWrap_linux_sys_fchmodat_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3367,
                            (Char const   *)"vgSysWrap_linux_sys_fchmodat_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fchmodat(dfd)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(char const   *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3367,
                            (Char const   *)"vgSysWrap_linux_sys_fchmodat_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3367,
                            (Char const   *)"vgSysWrap_linux_sys_fchmodat_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fchmodat(path)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(char const   *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(vki_mode_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_mode_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3367,
                            (Char const   *)"vgSysWrap_linux_sys_fchmodat_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3367,
                            (Char const   *)"vgSysWrap_linux_sys_fchmodat_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fchmodat(mode)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(vki_mode_t ));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"fchmodat(path)",
                                                   arrghs->arg2);
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_faccessat_before(ThreadId tid ,
                                          SyscallArgLayout *layout ,
                                          SyscallArgs *arrghs ,
                                          SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_faccessat ( %ld, %#lx(%s), %ld )", arrghs->arg1,
                   arrghs->arg2, (char *)arrghs->arg2, arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3375,
                            (Char const   *)"vgSysWrap_linux_sys_faccessat_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3375,
                            (Char const   *)"vgSysWrap_linux_sys_faccessat_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"faccessat(dfd)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(char const   *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3375,
                            (Char const   *)"vgSysWrap_linux_sys_faccessat_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3375,
                            (Char const   *)"vgSysWrap_linux_sys_faccessat_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"faccessat(pathname)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(char const   *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3375,
                            (Char const   *)"vgSysWrap_linux_sys_faccessat_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3375,
                            (Char const   *)"vgSysWrap_linux_sys_faccessat_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"faccessat(mode)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"faccessat(pathname)",
                                                   arrghs->arg2);
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_preadv_before(ThreadId tid , SyscallArgLayout *layout ,
                                       SyscallArgs *arrghs ,
                                       SyscallStatus *status , UWord *flags ) 
{ 
  Int i ;
  struct vki_iovec *vec ;
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;
  Int here___3 ;
  long tmp___7 ;
  long tmp___8 ;
  Word wzz ;
  int tmp___9 ;
  long tmp___10 ;
  Bool tmp___11 ;

  {
  *flags |= (unsigned long )(1 << 1);
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_preadv ( %ld, %#lx, %llu, %lld )", arrghs->arg1,
                   arrghs->arg2, (ULong )arrghs->arg3,
                   (ULong )arrghs->arg4 | ((ULong )arrghs->arg5 << 32));
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(unsigned long ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned long) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3395,
                            (Char const   *)"vgSysWrap_linux_sys_preadv_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3395,
                            (Char const   *)"vgSysWrap_linux_sys_preadv_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"preadv(fd)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(unsigned long ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(struct iovec  const  *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const struct iovec *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3395,
                            (Char const   *)"vgSysWrap_linux_sys_preadv_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3395,
                            (Char const   *)"vgSysWrap_linux_sys_preadv_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"preadv(vector)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(struct iovec  const  *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(unsigned long ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned long) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3395,
                            (Char const   *)"vgSysWrap_linux_sys_preadv_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3395,
                            (Char const   *)"vgSysWrap_linux_sys_preadv_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"preadv(count)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(unsigned long ));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(vki_u32 ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_u32) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3395,
                            (Char const   *)"vgSysWrap_linux_sys_preadv_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3395,
                            (Char const   *)"vgSysWrap_linux_sys_preadv_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"preadv(offset_low)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(vki_u32 ));
      break;
    }
    while (1) {
      here___3 = layout->o_arg5;
      tmp___7 = __builtin_expect((long )(! (! (sizeof(vki_u32 ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___7) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_u32) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3395,
                            (Char const   *)"vgSysWrap_linux_sys_preadv_before",
                            "");
      }
      tmp___8 = __builtin_expect((long )(! (! (here___3 >= 0))), 1L);
      if (tmp___8) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3395,
                            (Char const   *)"vgSysWrap_linux_sys_preadv_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"preadv(offset_high)",
                                            (PtrdiffT )here___3,
                                            (SizeT )sizeof(vki_u32 ));
      break;
    }
  } else {

  }
  tmp___11 = vgModuleLocal_fd_allowed((Int )arrghs->arg1,
                                      (Char const   *)"preadv", tid, (Bool )0);
  if (tmp___11) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"preadv(vector)",
                                              arrghs->arg2,
                                              arrghs->arg3 * (UWord )sizeof(struct vki_iovec ));
      } else {

      }
      break;
    }
    if (arrghs->arg2 != 0UL) {
      vec = (struct vki_iovec *)arrghs->arg2;
      i = 0;
      while (i < (Int )arrghs->arg3) {
        while (1) {
          if (vgPlain_tdict.track_pre_mem_write) {
            (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                                   (Char *)"preadv(vector[...])",
                                                   (Addr )(vec + i)->iov_base,
                                                   (SizeT )(vec + i)->iov_len);
          } else {

          }
          break;
        }
        i ++;
      }
    } else {

    }
  } else {
    while (1) {
      wzz = (Word )9;
      if (wzz >= 0L) {
        if (wzz < 10000L) {
          tmp___9 = 1;
        } else {
          tmp___9 = 0;
        }
      } else {
        tmp___9 = 0;
      }
      tmp___10 = __builtin_expect((long )tmp___9, 1L);
      if (tmp___10) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"wzz >= 0 && wzz < 10000",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3405,
                            (Char const   *)"vgSysWrap_linux_sys_preadv_before",
                            "");
      }
      status->what = (enum __anonenum_what_129 )1;
      status->sres = vgPlain_mk_SysRes_Error((UWord )wzz);
      break;
    }
  }
  return;
}
}
void vgSysWrap_linux_sys_preadv_after(ThreadId tid , SyscallArgs *arrghs ,
                                      SyscallStatus *status ) 
{ 
  Bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  Int i ;
  struct vki_iovec *vec ;
  Int remains ;
  UWord tmp___2 ;
  Int nReadThisBuf ;
  UWord tmp___3 ;

  {
  if ((unsigned int )status->what == 1U) {
    tmp = sr_isError(status->sres);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
  } else {
    tmp___0 = 0;
  }
  tmp___1 = __builtin_expect((long )tmp___0, 1L);
  if (tmp___1) {

  } else {
    vgPlain_assert_fail((Bool )1, (Char const   *)"SUCCESS",
                        (Char const   *)"m_syswrap/syswrap-linux.c", 3421,
                        (Char const   *)"vgSysWrap_linux_sys_preadv_after", "");
  }
  tmp___3 = getRES(status);
  if (tmp___3 > 0UL) {
    vec = (struct vki_iovec *)arrghs->arg2;
    tmp___2 = getRES(status);
    remains = (Int )tmp___2;
    i = 0;
    while (i < (Int )arrghs->arg3) {
      nReadThisBuf = (Int )(vec + i)->iov_len;
      if (nReadThisBuf > remains) {
        nReadThisBuf = remains;
      } else {

      }
      while (1) {
        if (vgPlain_tdict.track_post_mem_write) {
          (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                  (Addr )(vec + i)->iov_base,
                                                  (SizeT )nReadThisBuf);
        } else {

        }
        break;
      }
      remains -= nReadThisBuf;
      if (remains < 0) {
        vgPlain_core_panic((Char *)"preadv: remains < 0");
      } else {

      }
      i ++;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_pwritev_before(ThreadId tid ,
                                        SyscallArgLayout *layout ,
                                        SyscallArgs *arrghs ,
                                        SyscallStatus *status , UWord *flags ) 
{ 
  Int i ;
  struct vki_iovec *vec ;
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;
  Int here___3 ;
  long tmp___7 ;
  long tmp___8 ;
  Word wzz ;
  int tmp___9 ;
  long tmp___10 ;
  Bool tmp___11 ;

  {
  *flags |= (unsigned long )(1 << 1);
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_pwritev ( %ld, %#lx, %llu, %lld )", arrghs->arg1,
                   arrghs->arg2, (ULong )arrghs->arg3,
                   (ULong )arrghs->arg4 | ((ULong )arrghs->arg5 << 32));
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(unsigned long ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned long) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3450,
                            (Char const   *)"vgSysWrap_linux_sys_pwritev_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3450,
                            (Char const   *)"vgSysWrap_linux_sys_pwritev_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"pwritev(fd)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(unsigned long ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(struct iovec  const  *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const struct iovec *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3450,
                            (Char const   *)"vgSysWrap_linux_sys_pwritev_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3450,
                            (Char const   *)"vgSysWrap_linux_sys_pwritev_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"pwritev(vector)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(struct iovec  const  *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(unsigned long ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned long) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3450,
                            (Char const   *)"vgSysWrap_linux_sys_pwritev_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3450,
                            (Char const   *)"vgSysWrap_linux_sys_pwritev_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"pwritev(count)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(unsigned long ));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(vki_u32 ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_u32) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3450,
                            (Char const   *)"vgSysWrap_linux_sys_pwritev_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3450,
                            (Char const   *)"vgSysWrap_linux_sys_pwritev_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"pwritev(offset_low)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(vki_u32 ));
      break;
    }
    while (1) {
      here___3 = layout->o_arg5;
      tmp___7 = __builtin_expect((long )(! (! (sizeof(vki_u32 ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___7) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_u32) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3450,
                            (Char const   *)"vgSysWrap_linux_sys_pwritev_before",
                            "");
      }
      tmp___8 = __builtin_expect((long )(! (! (here___3 >= 0))), 1L);
      if (tmp___8) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3450,
                            (Char const   *)"vgSysWrap_linux_sys_pwritev_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"pwritev(offset_high)",
                                            (PtrdiffT )here___3,
                                            (SizeT )sizeof(vki_u32 ));
      break;
    }
  } else {

  }
  tmp___11 = vgModuleLocal_fd_allowed((Int )arrghs->arg1,
                                      (Char const   *)"pwritev", tid, (Bool )0);
  if (tmp___11) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"pwritev(vector)",
                                              arrghs->arg2,
                                              arrghs->arg3 * (UWord )sizeof(struct vki_iovec ));
      } else {

      }
      break;
    }
    if (arrghs->arg2 != 0UL) {
      vec = (struct vki_iovec *)arrghs->arg2;
      i = 0;
      while (i < (Int )arrghs->arg3) {
        while (1) {
          if (vgPlain_tdict.track_pre_mem_read) {
            (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                                  (Char *)"pwritev(vector[...])",
                                                  (Addr )(vec + i)->iov_base,
                                                  (SizeT )(vec + i)->iov_len);
          } else {

          }
          break;
        }
        i ++;
      }
    } else {

    }
  } else {
    while (1) {
      wzz = (Word )9;
      if (wzz >= 0L) {
        if (wzz < 10000L) {
          tmp___9 = 1;
        } else {
          tmp___9 = 0;
        }
      } else {
        tmp___9 = 0;
      }
      tmp___10 = __builtin_expect((long )tmp___9, 1L);
      if (tmp___10) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"wzz >= 0 && wzz < 10000",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3460,
                            (Char const   *)"vgSysWrap_linux_sys_pwritev_before",
                            "");
      }
      status->what = (enum __anonenum_what_129 )1;
      status->sres = vgPlain_mk_SysRes_Error((UWord )wzz);
      break;
    }
  }
  return;
}
}
void vgSysWrap_linux_sys_process_vm_readv_before(ThreadId tid ,
                                                 SyscallArgLayout *layout ,
                                                 SyscallArgs *arrghs ,
                                                 SyscallStatus *status ,
                                                 UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;
  Int here___3 ;
  long tmp___7 ;
  long tmp___8 ;
  Int here___4 ;
  long tmp___9 ;
  long tmp___10 ;
  struct vki_iovec  const  *vec ;
  UInt i ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_process_vm_readv ( %lu, %#lx, %lu, %#lx, %lu, %lu )",
                   arrghs->arg1, arrghs->arg2, arrghs->arg3, arrghs->arg4,
                   arrghs->arg5, arrghs->arg6);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_pid_t ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_pid_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3488,
                            (Char const   *)"vgSysWrap_linux_sys_process_vm_readv_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3488,
                            (Char const   *)"vgSysWrap_linux_sys_process_vm_readv_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"process_vm_readv(pid)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_pid_t ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(struct iovec  const  *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const struct iovec *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3488,
                            (Char const   *)"vgSysWrap_linux_sys_process_vm_readv_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3488,
                            (Char const   *)"vgSysWrap_linux_sys_process_vm_readv_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"process_vm_readv(lvec)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(struct iovec  const  *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(unsigned long ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned long) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3488,
                            (Char const   *)"vgSysWrap_linux_sys_process_vm_readv_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3488,
                            (Char const   *)"vgSysWrap_linux_sys_process_vm_readv_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"process_vm_readv(liovcnt)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(unsigned long ));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(struct iovec  const  *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const struct iovec *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3488,
                            (Char const   *)"vgSysWrap_linux_sys_process_vm_readv_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3488,
                            (Char const   *)"vgSysWrap_linux_sys_process_vm_readv_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"process_vm_readv(rvec)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(struct iovec  const  *));
      break;
    }
    while (1) {
      here___3 = layout->o_arg5;
      tmp___7 = __builtin_expect((long )(! (! (sizeof(unsigned long ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___7) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned long) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3488,
                            (Char const   *)"vgSysWrap_linux_sys_process_vm_readv_before",
                            "");
      }
      tmp___8 = __builtin_expect((long )(! (! (here___3 >= 0))), 1L);
      if (tmp___8) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3488,
                            (Char const   *)"vgSysWrap_linux_sys_process_vm_readv_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"process_vm_readv(riovcnt)",
                                            (PtrdiffT )here___3,
                                            (SizeT )sizeof(unsigned long ));
      break;
    }
    while (1) {
      here___4 = layout->o_arg6;
      tmp___9 = __builtin_expect((long )(! (! (sizeof(unsigned long ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___9) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned long) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3488,
                            (Char const   *)"vgSysWrap_linux_sys_process_vm_readv_before",
                            "");
      }
      tmp___10 = __builtin_expect((long )(! (! (here___4 >= 0))), 1L);
      if (tmp___10) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3488,
                            (Char const   *)"vgSysWrap_linux_sys_process_vm_readv_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"process_vm_readv(flags)",
                                            (PtrdiffT )here___4,
                                            (SizeT )sizeof(unsigned long ));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"process_vm_readv(lvec)",
                                            arrghs->arg2,
                                            arrghs->arg3 * (UWord )sizeof(struct vki_iovec ));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"process_vm_readv(rvec)",
                                            arrghs->arg4,
                                            arrghs->arg5 * (UWord )sizeof(struct vki_iovec ));
    } else {

    }
    break;
  }
  if (arrghs->arg2 != 0UL) {
    vec = (struct vki_iovec  const  *)arrghs->arg2;
    i = (UInt )0;
    while ((UWord )i < arrghs->arg3) {
      while (1) {
        if (vgPlain_tdict.track_pre_mem_write) {
          (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                                 (Char *)"process_vm_readv(lvec[...])",
                                                 (Addr )(vec + i)->iov_base,
                                                 (SizeT )(vec + i)->iov_len);
        } else {

        }
        break;
      }
      i ++;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_process_vm_readv_after(ThreadId tid ,
                                                SyscallArgs *arrghs ,
                                                SyscallStatus *status ) 
{ 
  struct vki_iovec  const  *vec ;
  UInt remains ;
  UWord tmp ;
  UInt i ;
  UInt nReadThisBuf ;
  __vki_kernel_size_t tmp___0 ;

  {
  vec = (struct vki_iovec  const  *)arrghs->arg2;
  tmp = getRES(status);
  remains = (UInt )tmp;
  i = (UInt )0;
  while ((UWord )i < arrghs->arg3) {
    if ((vec + i)->iov_len <= (__vki_kernel_size_t const   )remains) {
      tmp___0 = (vec + i)->iov_len;
    } else {
      tmp___0 = (__vki_kernel_size_t const   )remains;
    }
    nReadThisBuf = (UInt )tmp___0;
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                (Addr )(vec + i)->iov_base,
                                                (SizeT )nReadThisBuf);
      } else {

      }
      break;
    }
    remains -= nReadThisBuf;
    i ++;
  }
  return;
}
}
void vgSysWrap_linux_sys_process_vm_writev_before(ThreadId tid ,
                                                  SyscallArgLayout *layout ,
                                                  SyscallArgs *arrghs ,
                                                  SyscallStatus *status ,
                                                  UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;
  Int here___3 ;
  long tmp___7 ;
  long tmp___8 ;
  Int here___4 ;
  long tmp___9 ;
  long tmp___10 ;
  struct vki_iovec  const  *vec ;
  UInt i ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_process_vm_writev ( %lu, %#lx, %lu, %#lx, %lu, %lu )",
                   arrghs->arg1, arrghs->arg2, arrghs->arg3, arrghs->arg4,
                   arrghs->arg5, arrghs->arg6);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_pid_t ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_pid_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3526,
                            (Char const   *)"vgSysWrap_linux_sys_process_vm_writev_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3526,
                            (Char const   *)"vgSysWrap_linux_sys_process_vm_writev_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"process_vm_writev(pid)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_pid_t ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(struct iovec  const  *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const struct iovec *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3526,
                            (Char const   *)"vgSysWrap_linux_sys_process_vm_writev_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3526,
                            (Char const   *)"vgSysWrap_linux_sys_process_vm_writev_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"process_vm_writev(lvec)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(struct iovec  const  *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(unsigned long ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned long) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3526,
                            (Char const   *)"vgSysWrap_linux_sys_process_vm_writev_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3526,
                            (Char const   *)"vgSysWrap_linux_sys_process_vm_writev_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"process_vm_writev(liovcnt)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(unsigned long ));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(struct iovec  const  *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const struct iovec *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3526,
                            (Char const   *)"vgSysWrap_linux_sys_process_vm_writev_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3526,
                            (Char const   *)"vgSysWrap_linux_sys_process_vm_writev_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"process_vm_writev(rvec)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(struct iovec  const  *));
      break;
    }
    while (1) {
      here___3 = layout->o_arg5;
      tmp___7 = __builtin_expect((long )(! (! (sizeof(unsigned long ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___7) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned long) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3526,
                            (Char const   *)"vgSysWrap_linux_sys_process_vm_writev_before",
                            "");
      }
      tmp___8 = __builtin_expect((long )(! (! (here___3 >= 0))), 1L);
      if (tmp___8) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3526,
                            (Char const   *)"vgSysWrap_linux_sys_process_vm_writev_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"process_vm_writev(riovcnt)",
                                            (PtrdiffT )here___3,
                                            (SizeT )sizeof(unsigned long ));
      break;
    }
    while (1) {
      here___4 = layout->o_arg6;
      tmp___9 = __builtin_expect((long )(! (! (sizeof(unsigned long ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___9) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned long) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3526,
                            (Char const   *)"vgSysWrap_linux_sys_process_vm_writev_before",
                            "");
      }
      tmp___10 = __builtin_expect((long )(! (! (here___4 >= 0))), 1L);
      if (tmp___10) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3526,
                            (Char const   *)"vgSysWrap_linux_sys_process_vm_writev_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"process_vm_writev(flags)",
                                            (PtrdiffT )here___4,
                                            (SizeT )sizeof(unsigned long ));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"process_vm_writev(lvec)",
                                            arrghs->arg2,
                                            arrghs->arg3 * (UWord )sizeof(struct vki_iovec ));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"process_vm_writev(rvec)",
                                            arrghs->arg4,
                                            arrghs->arg5 * (UWord )sizeof(struct vki_iovec ));
    } else {

    }
    break;
  }
  if (arrghs->arg2 != 0UL) {
    vec = (struct vki_iovec  const  *)arrghs->arg2;
    i = (UInt )0;
    while ((UWord )i < arrghs->arg3) {
      while (1) {
        if (vgPlain_tdict.track_pre_mem_read) {
          (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                                (Char *)"process_vm_writev(lvec[...])",
                                                (Addr )(vec + i)->iov_base,
                                                (SizeT )(vec + i)->iov_len);
        } else {

        }
        break;
      }
      i ++;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_sendmmsg_before(ThreadId tid ,
                                         SyscallArgLayout *layout ,
                                         SyscallArgs *arrghs ,
                                         SyscallStatus *status , UWord *flags ) 
{ 
  struct vki_mmsghdr *mmsg ;
  Char name[32] ;
  UInt i ;
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;

  {
  mmsg = (struct vki_mmsghdr *)arrghs->arg2;
  *flags |= (unsigned long )(1 << 1);
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_sendmmsg ( %ld, %#lx, %ld, %ld )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3, arrghs->arg4);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3553,
                            (Char const   *)"vgSysWrap_linux_sys_sendmmsg_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3553,
                            (Char const   *)"vgSysWrap_linux_sys_sendmmsg_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sendmmsg(s)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(struct mmsghdr  const  *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const struct mmsghdr *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3553,
                            (Char const   *)"vgSysWrap_linux_sys_sendmmsg_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3553,
                            (Char const   *)"vgSysWrap_linux_sys_sendmmsg_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sendmmsg(mmsg)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(struct mmsghdr  const  *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3553,
                            (Char const   *)"vgSysWrap_linux_sys_sendmmsg_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3553,
                            (Char const   *)"vgSysWrap_linux_sys_sendmmsg_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sendmmsg(vlen)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3553,
                            (Char const   *)"vgSysWrap_linux_sys_sendmmsg_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3553,
                            (Char const   *)"vgSysWrap_linux_sys_sendmmsg_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"sendmmsg(flags)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  i = (UInt )0;
  while ((UWord )i < arrghs->arg3) {
    vgPlain_sprintf(name, "mmsg[%u].msg_hdr", i);
    vgModuleLocal_generic_PRE_sys_sendmsg(tid, name, & (mmsg + i)->msg_hdr);
    vgPlain_sprintf(name, "sendmmsg(mmsg[%u].msg_len)", i);
    while (1) {
      if (vgPlain_tdict.track_pre_mem_write) {
        (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid, name,
                                               (Addr )(& (mmsg + i)->msg_len),
                                               (SizeT )sizeof((mmsg + i)->msg_len));
      } else {

      }
      break;
    }
    i ++;
  }
  return;
}
}
void vgSysWrap_linux_sys_sendmmsg_after(ThreadId tid , SyscallArgs *arrghs ,
                                        SyscallStatus *status ) 
{ 
  struct vki_mmsghdr *mmsg ;
  UInt i ;
  UWord tmp ;
  UWord tmp___0 ;

  {
  tmp___0 = getRES(status);
  if (tmp___0 > 0UL) {
    mmsg = (struct vki_mmsghdr *)arrghs->arg2;
    i = (UInt )0;
    while (1) {
      tmp = getRES(status);
      if ((UWord )i < tmp) {

      } else {
        break;
      }
      while (1) {
        if (vgPlain_tdict.track_post_mem_write) {
          (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                  (Addr )(& (mmsg + i)->msg_len),
                                                  (SizeT )sizeof((mmsg + i)->msg_len));
        } else {

        }
        break;
      }
      i ++;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_recvmmsg_before(ThreadId tid ,
                                         SyscallArgLayout *layout ,
                                         SyscallArgs *arrghs ,
                                         SyscallStatus *status , UWord *flags ) 
{ 
  struct vki_mmsghdr *mmsg ;
  Char name[32] ;
  UInt i ;
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;
  Int here___3 ;
  long tmp___7 ;
  long tmp___8 ;

  {
  mmsg = (struct vki_mmsghdr *)arrghs->arg2;
  *flags |= (unsigned long )(1 << 1);
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_recvmmsg ( %ld, %#lx, %ld, %ld, %#lx )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3, arrghs->arg4, arrghs->arg5);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3582,
                            (Char const   *)"vgSysWrap_linux_sys_recvmmsg_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3582,
                            (Char const   *)"vgSysWrap_linux_sys_recvmmsg_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"recvmmsg(s)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(struct mmsghdr *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct mmsghdr *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3582,
                            (Char const   *)"vgSysWrap_linux_sys_recvmmsg_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3582,
                            (Char const   *)"vgSysWrap_linux_sys_recvmmsg_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"recvmmsg(mmsg)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(struct mmsghdr *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3582,
                            (Char const   *)"vgSysWrap_linux_sys_recvmmsg_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3582,
                            (Char const   *)"vgSysWrap_linux_sys_recvmmsg_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"recvmmsg(vlen)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3582,
                            (Char const   *)"vgSysWrap_linux_sys_recvmmsg_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3582,
                            (Char const   *)"vgSysWrap_linux_sys_recvmmsg_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"recvmmsg(flags)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___3 = layout->o_arg5;
      tmp___7 = __builtin_expect((long )(! (! (sizeof(struct timespec *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___7) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct timespec *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3582,
                            (Char const   *)"vgSysWrap_linux_sys_recvmmsg_before",
                            "");
      }
      tmp___8 = __builtin_expect((long )(! (! (here___3 >= 0))), 1L);
      if (tmp___8) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3582,
                            (Char const   *)"vgSysWrap_linux_sys_recvmmsg_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"recvmmsg(timeout)",
                                            (PtrdiffT )here___3,
                                            (SizeT )sizeof(struct timespec *));
      break;
    }
  } else {

  }
  i = (UInt )0;
  while ((UWord )i < arrghs->arg3) {
    vgPlain_sprintf(name, "mmsg[%u].msg_hdr", i);
    vgModuleLocal_generic_PRE_sys_recvmsg(tid, name, & (mmsg + i)->msg_hdr);
    vgPlain_sprintf(name, "recvmmsg(mmsg[%u].msg_len)", i);
    while (1) {
      if (vgPlain_tdict.track_pre_mem_write) {
        (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid, name,
                                               (Addr )(& (mmsg + i)->msg_len),
                                               (SizeT )sizeof((mmsg + i)->msg_len));
      } else {

      }
      break;
    }
    i ++;
  }
  if (arrghs->arg5) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"recvmmsg(timeout)",
                                              arrghs->arg5,
                                              (SizeT )sizeof(struct vki_timespec ));
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_recvmmsg_after(ThreadId tid , SyscallArgs *arrghs ,
                                        SyscallStatus *status ) 
{ 
  struct vki_mmsghdr *mmsg ;
  Char name[32] ;
  UInt i ;
  UWord tmp ;
  UWord tmp___0 ;

  {
  tmp___0 = getRES(status);
  if (tmp___0 > 0UL) {
    mmsg = (struct vki_mmsghdr *)arrghs->arg2;
    i = (UInt )0;
    while (1) {
      tmp = getRES(status);
      if ((UWord )i < tmp) {

      } else {
        break;
      }
      vgPlain_sprintf(name, "mmsg[%u].msg_hdr", i);
      vgModuleLocal_generic_POST_sys_recvmsg(tid, name, & (mmsg + i)->msg_hdr,
                                             (mmsg + i)->msg_len);
      while (1) {
        if (vgPlain_tdict.track_post_mem_write) {
          (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                  (Addr )(& (mmsg + i)->msg_len),
                                                  (SizeT )sizeof((mmsg + i)->msg_len));
        } else {

        }
        break;
      }
      i ++;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_request_key_before(ThreadId tid ,
                                            SyscallArgLayout *layout ,
                                            SyscallArgs *arrghs ,
                                            SyscallStatus *status ,
                                            UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_request_key ( %#lx(%s), %#lx(%s), %#lx(%s), %ld )",
                   arrghs->arg1, (char *)arrghs->arg1, arrghs->arg2,
                   (char *)arrghs->arg2, arrghs->arg3, (char *)arrghs->arg3,
                   arrghs->arg4);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(char const   *) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3617,
                            (Char const   *)"vgSysWrap_linux_sys_request_key_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3617,
                            (Char const   *)"vgSysWrap_linux_sys_request_key_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"request_key(type)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(char const   *));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(char const   *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3617,
                            (Char const   *)"vgSysWrap_linux_sys_request_key_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3617,
                            (Char const   *)"vgSysWrap_linux_sys_request_key_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"request_key(description)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(char const   *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(char const   *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3617,
                            (Char const   *)"vgSysWrap_linux_sys_request_key_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3617,
                            (Char const   *)"vgSysWrap_linux_sys_request_key_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"request_key(callout_info)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(char const   *));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(vki_key_serial_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_key_serial_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3617,
                            (Char const   *)"vgSysWrap_linux_sys_request_key_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3617,
                            (Char const   *)"vgSysWrap_linux_sys_request_key_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"request_key(keyring)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(vki_key_serial_t ));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"request_key(type)",
                                                   arrghs->arg1);
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"request_key(description)",
                                                   arrghs->arg2);
    } else {

    }
    break;
  }
  if (arrghs->arg3 != (UWord )((void *)0)) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read_asciiz) {
        (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                     (Char *)"request_key(callout_info)",
                                                     arrghs->arg3);
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_add_key_before(ThreadId tid ,
                                        SyscallArgLayout *layout ,
                                        SyscallArgs *arrghs ,
                                        SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;
  Int here___3 ;
  long tmp___7 ;
  long tmp___8 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_add_key ( %#lx(%s), %#lx(%s), %#lx, %ld, %ld )",
                   arrghs->arg1, (char *)arrghs->arg1, arrghs->arg2,
                   (char *)arrghs->arg2, arrghs->arg3, arrghs->arg4,
                   arrghs->arg5);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(char const   *) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3631,
                            (Char const   *)"vgSysWrap_linux_sys_add_key_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3631,
                            (Char const   *)"vgSysWrap_linux_sys_add_key_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"add_key(type)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(char const   *));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(char const   *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3631,
                            (Char const   *)"vgSysWrap_linux_sys_add_key_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3631,
                            (Char const   *)"vgSysWrap_linux_sys_add_key_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"add_key(description)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(char const   *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(void const   *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const void *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3631,
                            (Char const   *)"vgSysWrap_linux_sys_add_key_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3631,
                            (Char const   *)"vgSysWrap_linux_sys_add_key_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"add_key(payload)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(void const   *));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(vki_size_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_size_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3631,
                            (Char const   *)"vgSysWrap_linux_sys_add_key_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3631,
                            (Char const   *)"vgSysWrap_linux_sys_add_key_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"add_key(plen)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(vki_size_t ));
      break;
    }
    while (1) {
      here___3 = layout->o_arg5;
      tmp___7 = __builtin_expect((long )(! (! (sizeof(vki_key_serial_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___7) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_key_serial_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3631,
                            (Char const   *)"vgSysWrap_linux_sys_add_key_before",
                            "");
      }
      tmp___8 = __builtin_expect((long )(! (! (here___3 >= 0))), 1L);
      if (tmp___8) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3631,
                            (Char const   *)"vgSysWrap_linux_sys_add_key_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"add_key(keyring)",
                                            (PtrdiffT )here___3,
                                            (SizeT )sizeof(vki_key_serial_t ));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"add_key(type)",
                                                   arrghs->arg1);
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"add_key(description)",
                                                   arrghs->arg2);
    } else {

    }
    break;
  }
  if (arrghs->arg3 != (UWord )((void *)0)) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"request_key(payload)",
                                              arrghs->arg3, arrghs->arg4);
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_keyctl_before(ThreadId tid , SyscallArgLayout *layout ,
                                       SyscallArgs *arrghs ,
                                       SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;
  Int here___3 ;
  long tmp___7 ;
  long tmp___8 ;
  Int here___4 ;
  long tmp___9 ;
  long tmp___10 ;
  Int here___5 ;
  long tmp___11 ;
  long tmp___12 ;
  Int here___6 ;
  long tmp___13 ;
  long tmp___14 ;
  Int here___7 ;
  long tmp___15 ;
  long tmp___16 ;
  Int here___8 ;
  long tmp___17 ;
  long tmp___18 ;
  Int here___9 ;
  long tmp___19 ;
  long tmp___20 ;
  Int here___10 ;
  long tmp___21 ;
  long tmp___22 ;
  Int here___11 ;
  long tmp___23 ;
  long tmp___24 ;
  Int here___12 ;
  long tmp___25 ;
  long tmp___26 ;
  Int here___13 ;
  long tmp___27 ;
  long tmp___28 ;
  Int here___14 ;
  long tmp___29 ;
  long tmp___30 ;
  Int here___15 ;
  long tmp___31 ;
  long tmp___32 ;
  Int here___16 ;
  long tmp___33 ;
  long tmp___34 ;
  Int here___17 ;
  long tmp___35 ;
  long tmp___36 ;
  Int here___18 ;
  long tmp___37 ;
  long tmp___38 ;
  Int here___19 ;
  long tmp___39 ;
  long tmp___40 ;
  Int here___20 ;
  long tmp___41 ;
  long tmp___42 ;
  Int here___21 ;
  long tmp___43 ;
  long tmp___44 ;
  Int here___22 ;
  long tmp___45 ;
  long tmp___46 ;
  Int here___23 ;
  long tmp___47 ;
  long tmp___48 ;
  Int here___24 ;
  long tmp___49 ;
  long tmp___50 ;
  Int here___25 ;
  long tmp___51 ;
  long tmp___52 ;
  Int here___26 ;
  long tmp___53 ;
  long tmp___54 ;
  Int here___27 ;
  long tmp___55 ;
  long tmp___56 ;
  Int here___28 ;
  long tmp___57 ;
  long tmp___58 ;
  Int here___29 ;
  long tmp___59 ;
  long tmp___60 ;
  Int here___30 ;
  long tmp___61 ;
  long tmp___62 ;
  Int here___31 ;
  long tmp___63 ;
  long tmp___64 ;
  Int here___32 ;
  long tmp___65 ;
  long tmp___66 ;
  Int here___33 ;
  long tmp___67 ;
  long tmp___68 ;
  Int here___34 ;
  long tmp___69 ;
  long tmp___70 ;
  Int here___35 ;
  long tmp___71 ;
  long tmp___72 ;
  Int here___36 ;
  long tmp___73 ;
  long tmp___74 ;
  Int here___37 ;
  long tmp___75 ;
  long tmp___76 ;
  Int here___38 ;
  long tmp___77 ;
  long tmp___78 ;
  Int here___39 ;
  long tmp___79 ;
  long tmp___80 ;
  Int here___40 ;
  long tmp___81 ;
  long tmp___82 ;
  Int here___41 ;
  long tmp___83 ;
  long tmp___84 ;
  Int here___42 ;
  long tmp___85 ;
  long tmp___86 ;
  Int here___43 ;
  long tmp___87 ;
  long tmp___88 ;
  Int here___44 ;
  long tmp___89 ;
  long tmp___90 ;
  Int here___45 ;
  long tmp___91 ;
  long tmp___92 ;
  Int here___46 ;
  long tmp___93 ;
  long tmp___94 ;
  Int here___47 ;
  long tmp___95 ;
  long tmp___96 ;
  Int here___48 ;
  long tmp___97 ;
  long tmp___98 ;
  Int here___49 ;
  long tmp___99 ;
  long tmp___100 ;
  Int here___50 ;
  long tmp___101 ;
  long tmp___102 ;
  Int here___51 ;
  long tmp___103 ;
  long tmp___104 ;
  Int here___52 ;
  long tmp___105 ;
  long tmp___106 ;
  Int here___53 ;
  long tmp___107 ;
  long tmp___108 ;
  Int here___54 ;
  long tmp___109 ;
  long tmp___110 ;

  {
  switch (arrghs->arg1) {
  case 0UL: 
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_keyctl ( KEYCTL_GET_KEYRING_ID, %ld, %ld )",
                   arrghs->arg2, arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3644,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3644,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_GET_KEYRING_ID)(option)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(vki_key_serial_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_key_serial_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3644,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3644,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_GET_KEYRING_ID)(id)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(vki_key_serial_t ));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3644,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3644,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_GET_KEYRING_ID)(create)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  break;
  case 1UL: 
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_keyctl ( KEYCTL_JOIN_SESSION_KEYRING, %#lx(%s) )",
                   arrghs->arg2, (char *)arrghs->arg2);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___2 = layout->o_arg1;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3649,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3649,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_JOIN_SESSION_KEYRING)(option)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___3 = layout->o_arg2;
      tmp___7 = __builtin_expect((long )(! (! (sizeof(char const   *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___7) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3649,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___8 = __builtin_expect((long )(! (! (here___3 >= 0))), 1L);
      if (tmp___8) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3649,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_JOIN_SESSION_KEYRING)(name)",
                                            (PtrdiffT )here___3,
                                            (SizeT )sizeof(char const   *));
      break;
    }
  } else {

  }
  if (arrghs->arg2 != (UWord )((void *)0)) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read_asciiz) {
        (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                     (Char *)"keyctl(KEYCTL_JOIN_SESSION_KEYRING, name)",
                                                     arrghs->arg2);
      } else {

      }
      break;
    }
  } else {

  }
  break;
  case 2UL: 
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_keyctl ( KEYCTL_UPDATE, %ld, %#lx, %ld )", arrghs->arg2,
                   arrghs->arg3, arrghs->arg4);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___4 = layout->o_arg1;
      tmp___9 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___9) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3657,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___10 = __builtin_expect((long )(! (! (here___4 >= 0))), 1L);
      if (tmp___10) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3657,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_UPDATE)(option)",
                                            (PtrdiffT )here___4,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___5 = layout->o_arg2;
      tmp___11 = __builtin_expect((long )(! (! (sizeof(vki_key_serial_t ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___11) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_key_serial_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3657,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___12 = __builtin_expect((long )(! (! (here___5 >= 0))), 1L);
      if (tmp___12) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3657,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_UPDATE)(key)",
                                            (PtrdiffT )here___5,
                                            (SizeT )sizeof(vki_key_serial_t ));
      break;
    }
    while (1) {
      here___6 = layout->o_arg3;
      tmp___13 = __builtin_expect((long )(! (! (sizeof(void const   *) <= sizeof(UWord )))),
                                  1L);
      if (tmp___13) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const void *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3657,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___14 = __builtin_expect((long )(! (! (here___6 >= 0))), 1L);
      if (tmp___14) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3657,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_UPDATE)(payload)",
                                            (PtrdiffT )here___6,
                                            (SizeT )sizeof(void const   *));
      break;
    }
    while (1) {
      here___7 = layout->o_arg4;
      tmp___15 = __builtin_expect((long )(! (! (sizeof(vki_size_t ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___15) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_size_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3657,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___16 = __builtin_expect((long )(! (! (here___7 >= 0))), 1L);
      if (tmp___16) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3657,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_UPDATE)(plen)",
                                            (PtrdiffT )here___7,
                                            (SizeT )sizeof(vki_size_t ));
      break;
    }
  } else {

  }
  if (arrghs->arg3 != (UWord )((void *)0)) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"keyctl(KEYCTL_UPDATE, payload)",
                                              arrghs->arg3, arrghs->arg4);
      } else {

      }
      break;
    }
  } else {

  }
  break;
  case 3UL: 
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_keyctl ( KEYCTL_REVOKE, %ld )", arrghs->arg2);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___8 = layout->o_arg1;
      tmp___17 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___17) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3664,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___18 = __builtin_expect((long )(! (! (here___8 >= 0))), 1L);
      if (tmp___18) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3664,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_REVOKE)(option)",
                                            (PtrdiffT )here___8,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___9 = layout->o_arg2;
      tmp___19 = __builtin_expect((long )(! (! (sizeof(vki_key_serial_t ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___19) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_key_serial_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3664,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___20 = __builtin_expect((long )(! (! (here___9 >= 0))), 1L);
      if (tmp___20) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3664,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_REVOKE)(id)",
                                            (PtrdiffT )here___9,
                                            (SizeT )sizeof(vki_key_serial_t ));
      break;
    }
  } else {

  }
  break;
  case 4UL: 
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_keyctl ( KEYCTL_CHOWN, %ld, %ld, %ld )", arrghs->arg2,
                   arrghs->arg3, arrghs->arg4);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___10 = layout->o_arg1;
      tmp___21 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___21) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3670,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___22 = __builtin_expect((long )(! (! (here___10 >= 0))), 1L);
      if (tmp___22) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3670,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_CHOWN)(option)",
                                            (PtrdiffT )here___10,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___11 = layout->o_arg2;
      tmp___23 = __builtin_expect((long )(! (! (sizeof(vki_key_serial_t ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___23) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_key_serial_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3670,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___24 = __builtin_expect((long )(! (! (here___11 >= 0))), 1L);
      if (tmp___24) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3670,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_CHOWN)(id)",
                                            (PtrdiffT )here___11,
                                            (SizeT )sizeof(vki_key_serial_t ));
      break;
    }
    while (1) {
      here___12 = layout->o_arg3;
      tmp___25 = __builtin_expect((long )(! (! (sizeof(vki_uid_t ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___25) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_uid_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3670,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___26 = __builtin_expect((long )(! (! (here___12 >= 0))), 1L);
      if (tmp___26) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3670,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_CHOWN)(uid)",
                                            (PtrdiffT )here___12,
                                            (SizeT )sizeof(vki_uid_t ));
      break;
    }
    while (1) {
      here___13 = layout->o_arg4;
      tmp___27 = __builtin_expect((long )(! (! (sizeof(vki_gid_t ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___27) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_gid_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3670,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___28 = __builtin_expect((long )(! (! (here___13 >= 0))), 1L);
      if (tmp___28) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3670,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_CHOWN)(gid)",
                                            (PtrdiffT )here___13,
                                            (SizeT )sizeof(vki_gid_t ));
      break;
    }
  } else {

  }
  break;
  case 5UL: 
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_keyctl ( KEYCTL_SETPERM, %ld, %ld )", arrghs->arg2,
                   arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___14 = layout->o_arg1;
      tmp___29 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___29) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3675,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___30 = __builtin_expect((long )(! (! (here___14 >= 0))), 1L);
      if (tmp___30) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3675,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_SETPERM)(option)",
                                            (PtrdiffT )here___14,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___15 = layout->o_arg2;
      tmp___31 = __builtin_expect((long )(! (! (sizeof(vki_key_serial_t ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___31) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_key_serial_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3675,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___32 = __builtin_expect((long )(! (! (here___15 >= 0))), 1L);
      if (tmp___32) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3675,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_SETPERM)(id)",
                                            (PtrdiffT )here___15,
                                            (SizeT )sizeof(vki_key_serial_t ));
      break;
    }
    while (1) {
      here___16 = layout->o_arg3;
      tmp___33 = __builtin_expect((long )(! (! (sizeof(vki_key_perm_t ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___33) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_key_perm_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3675,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___34 = __builtin_expect((long )(! (! (here___16 >= 0))), 1L);
      if (tmp___34) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3675,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_SETPERM)(perm)",
                                            (PtrdiffT )here___16,
                                            (SizeT )sizeof(vki_key_perm_t ));
      break;
    }
  } else {

  }
  break;
  case 6UL: 
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_keyctl ( KEYCTL_DESCRIBE, %ld, %#lx, %ld )",
                   arrghs->arg2, arrghs->arg3, arrghs->arg4);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___17 = layout->o_arg1;
      tmp___35 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___35) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3681,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___36 = __builtin_expect((long )(! (! (here___17 >= 0))), 1L);
      if (tmp___36) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3681,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_DESCRIBE)(option)",
                                            (PtrdiffT )here___17,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___18 = layout->o_arg2;
      tmp___37 = __builtin_expect((long )(! (! (sizeof(vki_key_serial_t ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___37) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_key_serial_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3681,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___38 = __builtin_expect((long )(! (! (here___18 >= 0))), 1L);
      if (tmp___38) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3681,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_DESCRIBE)(id)",
                                            (PtrdiffT )here___18,
                                            (SizeT )sizeof(vki_key_serial_t ));
      break;
    }
    while (1) {
      here___19 = layout->o_arg3;
      tmp___39 = __builtin_expect((long )(! (! (sizeof(char *) <= sizeof(UWord )))),
                                  1L);
      if (tmp___39) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3681,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___40 = __builtin_expect((long )(! (! (here___19 >= 0))), 1L);
      if (tmp___40) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3681,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_DESCRIBE)(buffer)",
                                            (PtrdiffT )here___19,
                                            (SizeT )sizeof(char *));
      break;
    }
    while (1) {
      here___20 = layout->o_arg4;
      tmp___41 = __builtin_expect((long )(! (! (sizeof(vki_size_t ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___41) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_size_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3681,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___42 = __builtin_expect((long )(! (! (here___20 >= 0))), 1L);
      if (tmp___42) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3681,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_DESCRIBE)(buflen)",
                                            (PtrdiffT )here___20,
                                            (SizeT )sizeof(vki_size_t ));
      break;
    }
  } else {

  }
  if (arrghs->arg3 != (UWord )((void *)0)) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_write) {
        (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                               (Char *)"keyctl(KEYCTL_DESCRIBE, buffer)",
                                               arrghs->arg3, arrghs->arg4);
      } else {

      }
      break;
    }
  } else {

  }
  break;
  case 7UL: 
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_keyctl ( KEYCTL_CLEAR, %ld )", arrghs->arg2);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___21 = layout->o_arg1;
      tmp___43 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___43) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3688,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___44 = __builtin_expect((long )(! (! (here___21 >= 0))), 1L);
      if (tmp___44) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3688,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_CLEAR)(option)",
                                            (PtrdiffT )here___21,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___22 = layout->o_arg2;
      tmp___45 = __builtin_expect((long )(! (! (sizeof(vki_key_serial_t ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___45) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_key_serial_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3688,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___46 = __builtin_expect((long )(! (! (here___22 >= 0))), 1L);
      if (tmp___46) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3688,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_CLEAR)(keyring)",
                                            (PtrdiffT )here___22,
                                            (SizeT )sizeof(vki_key_serial_t ));
      break;
    }
  } else {

  }
  break;
  case 8UL: 
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_keyctl ( KEYCTL_LINK, %ld, %ld )", arrghs->arg2,
                   arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___23 = layout->o_arg1;
      tmp___47 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___47) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3693,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___48 = __builtin_expect((long )(! (! (here___23 >= 0))), 1L);
      if (tmp___48) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3693,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_LINK)(option)",
                                            (PtrdiffT )here___23,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___24 = layout->o_arg2;
      tmp___49 = __builtin_expect((long )(! (! (sizeof(vki_key_serial_t ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___49) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_key_serial_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3693,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___50 = __builtin_expect((long )(! (! (here___24 >= 0))), 1L);
      if (tmp___50) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3693,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_LINK)(keyring)",
                                            (PtrdiffT )here___24,
                                            (SizeT )sizeof(vki_key_serial_t ));
      break;
    }
    while (1) {
      here___25 = layout->o_arg3;
      tmp___51 = __builtin_expect((long )(! (! (sizeof(vki_key_serial_t ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___51) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_key_serial_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3693,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___52 = __builtin_expect((long )(! (! (here___25 >= 0))), 1L);
      if (tmp___52) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3693,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_LINK)(key)",
                                            (PtrdiffT )here___25,
                                            (SizeT )sizeof(vki_key_serial_t ));
      break;
    }
  } else {

  }
  break;
  case 9UL: 
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_keyctl ( KEYCTL_UNLINK, %ld, %ld )", arrghs->arg2,
                   arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___26 = layout->o_arg1;
      tmp___53 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___53) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3698,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___54 = __builtin_expect((long )(! (! (here___26 >= 0))), 1L);
      if (tmp___54) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3698,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_UNLINK)(option)",
                                            (PtrdiffT )here___26,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___27 = layout->o_arg2;
      tmp___55 = __builtin_expect((long )(! (! (sizeof(vki_key_serial_t ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___55) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_key_serial_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3698,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___56 = __builtin_expect((long )(! (! (here___27 >= 0))), 1L);
      if (tmp___56) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3698,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_UNLINK)(keyring)",
                                            (PtrdiffT )here___27,
                                            (SizeT )sizeof(vki_key_serial_t ));
      break;
    }
    while (1) {
      here___28 = layout->o_arg3;
      tmp___57 = __builtin_expect((long )(! (! (sizeof(vki_key_serial_t ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___57) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_key_serial_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3698,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___58 = __builtin_expect((long )(! (! (here___28 >= 0))), 1L);
      if (tmp___58) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3698,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_UNLINK)(key)",
                                            (PtrdiffT )here___28,
                                            (SizeT )sizeof(vki_key_serial_t ));
      break;
    }
  } else {

  }
  break;
  case 10UL: 
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_keyctl ( KEYCTL_SEARCH, %ld, %#lx(%s), %#lx(%s), %ld )",
                   arrghs->arg2, arrghs->arg3, (char *)arrghs->arg3,
                   arrghs->arg4, (char *)arrghs->arg4, arrghs->arg5);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___29 = layout->o_arg1;
      tmp___59 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___59) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3706,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___60 = __builtin_expect((long )(! (! (here___29 >= 0))), 1L);
      if (tmp___60) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3706,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_SEARCH)(option)",
                                            (PtrdiffT )here___29,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___30 = layout->o_arg2;
      tmp___61 = __builtin_expect((long )(! (! (sizeof(vki_key_serial_t ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___61) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_key_serial_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3706,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___62 = __builtin_expect((long )(! (! (here___30 >= 0))), 1L);
      if (tmp___62) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3706,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_SEARCH)(keyring)",
                                            (PtrdiffT )here___30,
                                            (SizeT )sizeof(vki_key_serial_t ));
      break;
    }
    while (1) {
      here___31 = layout->o_arg3;
      tmp___63 = __builtin_expect((long )(! (! (sizeof(char const   *) <= sizeof(UWord )))),
                                  1L);
      if (tmp___63) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3706,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___64 = __builtin_expect((long )(! (! (here___31 >= 0))), 1L);
      if (tmp___64) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3706,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_SEARCH)(type)",
                                            (PtrdiffT )here___31,
                                            (SizeT )sizeof(char const   *));
      break;
    }
    while (1) {
      here___32 = layout->o_arg4;
      tmp___65 = __builtin_expect((long )(! (! (sizeof(char const   *) <= sizeof(UWord )))),
                                  1L);
      if (tmp___65) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3706,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___66 = __builtin_expect((long )(! (! (here___32 >= 0))), 1L);
      if (tmp___66) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3706,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_SEARCH)(description)",
                                            (PtrdiffT )here___32,
                                            (SizeT )sizeof(char const   *));
      break;
    }
    while (1) {
      here___33 = layout->o_arg5;
      tmp___67 = __builtin_expect((long )(! (! (sizeof(vki_key_serial_t ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___67) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_key_serial_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3706,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___68 = __builtin_expect((long )(! (! (here___33 >= 0))), 1L);
      if (tmp___68) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3706,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_SEARCH)(destring)",
                                            (PtrdiffT )here___33,
                                            (SizeT )sizeof(vki_key_serial_t ));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"sys_keyctl(KEYCTL_SEARCH, type)",
                                                   arrghs->arg3);
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"sys_keyctl(KEYCTL_SEARCH, description)",
                                                   arrghs->arg4);
    } else {

    }
    break;
  }
  break;
  case 11UL: 
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_keyctl ( KEYCTL_READ, %ld, %#lx, %ld )", arrghs->arg2,
                   arrghs->arg3, arrghs->arg4);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___34 = layout->o_arg1;
      tmp___69 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___69) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3714,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___70 = __builtin_expect((long )(! (! (here___34 >= 0))), 1L);
      if (tmp___70) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3714,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_READ)(option)",
                                            (PtrdiffT )here___34,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___35 = layout->o_arg2;
      tmp___71 = __builtin_expect((long )(! (! (sizeof(vki_key_serial_t ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___71) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_key_serial_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3714,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___72 = __builtin_expect((long )(! (! (here___35 >= 0))), 1L);
      if (tmp___72) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3714,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_READ)(keyring)",
                                            (PtrdiffT )here___35,
                                            (SizeT )sizeof(vki_key_serial_t ));
      break;
    }
    while (1) {
      here___36 = layout->o_arg3;
      tmp___73 = __builtin_expect((long )(! (! (sizeof(char *) <= sizeof(UWord )))),
                                  1L);
      if (tmp___73) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3714,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___74 = __builtin_expect((long )(! (! (here___36 >= 0))), 1L);
      if (tmp___74) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3714,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_READ)(buffer)",
                                            (PtrdiffT )here___36,
                                            (SizeT )sizeof(char *));
      break;
    }
    while (1) {
      here___37 = layout->o_arg4;
      tmp___75 = __builtin_expect((long )(! (! (sizeof(vki_size_t ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___75) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_size_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3714,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___76 = __builtin_expect((long )(! (! (here___37 >= 0))), 1L);
      if (tmp___76) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3714,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_READ)(buflen)",
                                            (PtrdiffT )here___37,
                                            (SizeT )sizeof(vki_size_t ));
      break;
    }
  } else {

  }
  if (arrghs->arg3 != (UWord )((void *)0)) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_write) {
        (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                               (Char *)"keyctl(KEYCTL_READ, buffer)",
                                               arrghs->arg3, arrghs->arg4);
      } else {

      }
      break;
    }
  } else {

  }
  break;
  case 12UL: 
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_keyctl ( KEYCTL_INSTANTIATE, %ld, %#lx, %ld, %ld )",
                   arrghs->arg2, arrghs->arg3, arrghs->arg4, arrghs->arg5);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___38 = layout->o_arg1;
      tmp___77 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___77) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3724,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___78 = __builtin_expect((long )(! (! (here___38 >= 0))), 1L);
      if (tmp___78) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3724,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_INSTANTIATE)(option)",
                                            (PtrdiffT )here___38,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___39 = layout->o_arg2;
      tmp___79 = __builtin_expect((long )(! (! (sizeof(vki_key_serial_t ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___79) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_key_serial_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3724,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___80 = __builtin_expect((long )(! (! (here___39 >= 0))), 1L);
      if (tmp___80) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3724,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_INSTANTIATE)(key)",
                                            (PtrdiffT )here___39,
                                            (SizeT )sizeof(vki_key_serial_t ));
      break;
    }
    while (1) {
      here___40 = layout->o_arg3;
      tmp___81 = __builtin_expect((long )(! (! (sizeof(char *) <= sizeof(UWord )))),
                                  1L);
      if (tmp___81) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3724,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___82 = __builtin_expect((long )(! (! (here___40 >= 0))), 1L);
      if (tmp___82) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3724,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_INSTANTIATE)(payload)",
                                            (PtrdiffT )here___40,
                                            (SizeT )sizeof(char *));
      break;
    }
    while (1) {
      here___41 = layout->o_arg4;
      tmp___83 = __builtin_expect((long )(! (! (sizeof(vki_size_t ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___83) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_size_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3724,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___84 = __builtin_expect((long )(! (! (here___41 >= 0))), 1L);
      if (tmp___84) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3724,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_INSTANTIATE)(plen)",
                                            (PtrdiffT )here___41,
                                            (SizeT )sizeof(vki_size_t ));
      break;
    }
    while (1) {
      here___42 = layout->o_arg5;
      tmp___85 = __builtin_expect((long )(! (! (sizeof(vki_key_serial_t ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___85) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_key_serial_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3724,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___86 = __builtin_expect((long )(! (! (here___42 >= 0))), 1L);
      if (tmp___86) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3724,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_INSTANTIATE)(keyring)",
                                            (PtrdiffT )here___42,
                                            (SizeT )sizeof(vki_key_serial_t ));
      break;
    }
  } else {

  }
  if (arrghs->arg3 != (UWord )((void *)0)) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"keyctl(KEYCTL_INSTANTIATE, payload)",
                                              arrghs->arg3, arrghs->arg4);
      } else {

      }
      break;
    }
  } else {

  }
  break;
  case 13UL: 
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_keyctl ( KEYCTL_NEGATE, %ld, %lu, %ld )", arrghs->arg2,
                   arrghs->arg3, arrghs->arg4);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___43 = layout->o_arg1;
      tmp___87 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___87) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3732,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___88 = __builtin_expect((long )(! (! (here___43 >= 0))), 1L);
      if (tmp___88) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3732,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_NEGATE)(option)",
                                            (PtrdiffT )here___43,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___44 = layout->o_arg2;
      tmp___89 = __builtin_expect((long )(! (! (sizeof(vki_key_serial_t ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___89) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_key_serial_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3732,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___90 = __builtin_expect((long )(! (! (here___44 >= 0))), 1L);
      if (tmp___90) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3732,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_NEGATE)(key)",
                                            (PtrdiffT )here___44,
                                            (SizeT )sizeof(vki_key_serial_t ));
      break;
    }
    while (1) {
      here___45 = layout->o_arg3;
      tmp___91 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___91) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3732,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___92 = __builtin_expect((long )(! (! (here___45 >= 0))), 1L);
      if (tmp___92) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3732,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_NEGATE)(timeout)",
                                            (PtrdiffT )here___45,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
    while (1) {
      here___46 = layout->o_arg4;
      tmp___93 = __builtin_expect((long )(! (! (sizeof(vki_key_serial_t ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___93) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_key_serial_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3732,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___94 = __builtin_expect((long )(! (! (here___46 >= 0))), 1L);
      if (tmp___94) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3732,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_NEGATE)(keyring)",
                                            (PtrdiffT )here___46,
                                            (SizeT )sizeof(vki_key_serial_t ));
      break;
    }
  } else {

  }
  break;
  case 14UL: 
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_keyctl ( KEYCTL_SET_REQKEY_KEYRING, %ld )", arrghs->arg2);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___47 = layout->o_arg1;
      tmp___95 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___95) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3737,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___96 = __builtin_expect((long )(! (! (here___47 >= 0))), 1L);
      if (tmp___96) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3737,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_SET_REQKEY_KEYRING)(option)",
                                            (PtrdiffT )here___47,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___48 = layout->o_arg2;
      tmp___97 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___97) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3737,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___98 = __builtin_expect((long )(! (! (here___48 >= 0))), 1L);
      if (tmp___98) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3737,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_SET_REQKEY_KEYRING)(reqkey_defl)",
                                            (PtrdiffT )here___48,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  break;
  case 15UL: 
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_keyctl ( KEYCTL_SET_TIMEOUT, %ld, %ld )", arrghs->arg2,
                   arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___49 = layout->o_arg1;
      tmp___99 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___99) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3742,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___100 = __builtin_expect((long )(! (! (here___49 >= 0))), 1L);
      if (tmp___100) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3742,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_SET_TIMEOUT)(option)",
                                            (PtrdiffT )here___49,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___50 = layout->o_arg2;
      tmp___101 = __builtin_expect((long )(! (! (sizeof(vki_key_serial_t ) <= sizeof(UWord )))),
                                   1L);
      if (tmp___101) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_key_serial_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3742,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___102 = __builtin_expect((long )(! (! (here___50 >= 0))), 1L);
      if (tmp___102) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3742,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_SET_TIMEOUT)(key)",
                                            (PtrdiffT )here___50,
                                            (SizeT )sizeof(vki_key_serial_t ));
      break;
    }
    while (1) {
      here___51 = layout->o_arg3;
      tmp___103 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                   1L);
      if (tmp___103) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3742,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___104 = __builtin_expect((long )(! (! (here___51 >= 0))), 1L);
      if (tmp___104) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3742,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_SET_TIMEOUT)(timeout)",
                                            (PtrdiffT )here___51,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
  } else {

  }
  break;
  case 16UL: 
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_keyctl ( KEYCTL_ASSUME_AUTHORITY, %ld )", arrghs->arg2);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___52 = layout->o_arg1;
      tmp___105 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                   1L);
      if (tmp___105) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3747,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___106 = __builtin_expect((long )(! (! (here___52 >= 0))), 1L);
      if (tmp___106) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3747,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_ASSUME_AUTHORITY)(option)",
                                            (PtrdiffT )here___52,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___53 = layout->o_arg2;
      tmp___107 = __builtin_expect((long )(! (! (sizeof(vki_key_serial_t ) <= sizeof(UWord )))),
                                   1L);
      if (tmp___107) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_key_serial_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3747,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___108 = __builtin_expect((long )(! (! (here___53 >= 0))), 1L);
      if (tmp___108) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3747,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(KEYCTL_ASSUME_AUTHORITY)(key)",
                                            (PtrdiffT )here___53,
                                            (SizeT )sizeof(vki_key_serial_t ));
      break;
    }
  } else {

  }
  break;
  default: 
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_keyctl ( %ld ) ", arrghs->arg1);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___54 = layout->o_arg1;
      tmp___109 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                   1L);
      if (tmp___109) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3751,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      tmp___110 = __builtin_expect((long )(! (! (here___54 >= 0))), 1L);
      if (tmp___110) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3751,
                            (Char const   *)"vgSysWrap_linux_sys_keyctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"keyctl(option)",
                                            (PtrdiffT )here___54,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  break;
  }
  return;
}
}
void vgSysWrap_linux_sys_keyctl_after(ThreadId tid , SyscallArgs *arrghs ,
                                      SyscallStatus *status ) 
{ 
  Bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  UWord tmp___2 ;
  UWord tmp___3 ;

  {
  if ((unsigned int )status->what == 1U) {
    tmp = sr_isError(status->sres);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
  } else {
    tmp___0 = 0;
  }
  tmp___1 = __builtin_expect((long )tmp___0, 1L);
  if (tmp___1) {

  } else {
    vgPlain_assert_fail((Bool )1, (Char const   *)"SUCCESS",
                        (Char const   *)"m_syswrap/syswrap-linux.c", 3758,
                        (Char const   *)"vgSysWrap_linux_sys_keyctl_after", "");
  }
  switch (arrghs->arg1) {
  case 11UL: 
  case 6UL: 
  tmp___3 = getRES(status);
  if (tmp___3 > arrghs->arg4) {
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                                arrghs->arg4);
      } else {

      }
      break;
    }
  } else {
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        tmp___2 = getRES(status);
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                                tmp___2);
      } else {

      }
      break;
    }
  }
  break;
  default: 
  break;
  }
  return;
}
}
void vgSysWrap_linux_sys_ioprio_set_before(ThreadId tid ,
                                           SyscallArgLayout *layout ,
                                           SyscallArgs *arrghs ,
                                           SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_ioprio_set ( %ld, %ld, %ld )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3779,
                            (Char const   *)"vgSysWrap_linux_sys_ioprio_set_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3779,
                            (Char const   *)"vgSysWrap_linux_sys_ioprio_set_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"ioprio_set(which)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3779,
                            (Char const   *)"vgSysWrap_linux_sys_ioprio_set_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3779,
                            (Char const   *)"vgSysWrap_linux_sys_ioprio_set_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"ioprio_set(who)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3779,
                            (Char const   *)"vgSysWrap_linux_sys_ioprio_set_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3779,
                            (Char const   *)"vgSysWrap_linux_sys_ioprio_set_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"ioprio_set(ioprio)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_ioprio_get_before(ThreadId tid ,
                                           SyscallArgLayout *layout ,
                                           SyscallArgs *arrghs ,
                                           SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_ioprio_get ( %ld, %ld )", arrghs->arg1, arrghs->arg2);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3785,
                            (Char const   *)"vgSysWrap_linux_sys_ioprio_get_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3785,
                            (Char const   *)"vgSysWrap_linux_sys_ioprio_get_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"ioprio_get(which)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3785,
                            (Char const   *)"vgSysWrap_linux_sys_ioprio_get_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3785,
                            (Char const   *)"vgSysWrap_linux_sys_ioprio_get_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"ioprio_get(who)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(int ));
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_init_module_before(ThreadId tid ,
                                            SyscallArgLayout *layout ,
                                            SyscallArgs *arrghs ,
                                            SyscallStatus *status ,
                                            UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  *flags |= (unsigned long )(1 << 1);
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_init_module ( %#lx, %llu, %#lx(\"%s\") )", arrghs->arg1,
                   (ULong )arrghs->arg2, arrghs->arg3, (char *)arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(void *) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(void *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3798,
                            (Char const   *)"vgSysWrap_linux_sys_init_module_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3798,
                            (Char const   *)"vgSysWrap_linux_sys_init_module_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"init_module(umod)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(void *));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(unsigned long ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned long) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3798,
                            (Char const   *)"vgSysWrap_linux_sys_init_module_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3798,
                            (Char const   *)"vgSysWrap_linux_sys_init_module_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"init_module(len)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(unsigned long ));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(char const   *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3798,
                            (Char const   *)"vgSysWrap_linux_sys_init_module_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3798,
                            (Char const   *)"vgSysWrap_linux_sys_init_module_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"init_module(uargs)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(char const   *));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"init_module(umod)",
                                            arrghs->arg1, arrghs->arg2);
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"init_module(uargs)",
                                                   arrghs->arg3);
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_delete_module_before(ThreadId tid ,
                                              SyscallArgLayout *layout ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ,
                                              UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  *flags |= (unsigned long )(1 << 1);
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_delete_module ( %#lx(\"%s\"), 0x%lx )", arrghs->arg1,
                   (char *)arrghs->arg1, arrghs->arg2);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(char const   *) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(const char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3808,
                            (Char const   *)"vgSysWrap_linux_sys_delete_module_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3808,
                            (Char const   *)"vgSysWrap_linux_sys_delete_module_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"delete_module(name_user)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(char const   *));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3808,
                            (Char const   *)"vgSysWrap_linux_sys_delete_module_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3808,
                            (Char const   *)"vgSysWrap_linux_sys_delete_module_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"delete_module(flags)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"delete_module(name_user)",
                                                   arrghs->arg1);
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_splice_before(ThreadId tid , SyscallArgLayout *layout ,
                                       SyscallArgs *arrghs ,
                                       SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;
  Int here___3 ;
  long tmp___7 ;
  long tmp___8 ;
  Int here___4 ;
  long tmp___9 ;
  long tmp___10 ;
  Word wzz ;
  int tmp___11 ;
  long tmp___12 ;
  Bool tmp___13 ;
  Bool tmp___14 ;

  {
  *flags |= (unsigned long )(1 << 1);
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_splice ( %ld, %#lx, %ld, %#lx, %ld, %ld )",
                   arrghs->arg1, arrghs->arg2, arrghs->arg3, arrghs->arg4,
                   arrghs->arg5, arrghs->arg6);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))), 1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3824,
                            (Char const   *)"vgSysWrap_linux_sys_splice_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3824,
                            (Char const   *)"vgSysWrap_linux_sys_splice_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"splice(fd_in)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(vki_loff_t *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_loff_t *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3824,
                            (Char const   *)"vgSysWrap_linux_sys_splice_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3824,
                            (Char const   *)"vgSysWrap_linux_sys_splice_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"splice(off_in)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(vki_loff_t *));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3824,
                            (Char const   *)"vgSysWrap_linux_sys_splice_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3824,
                            (Char const   *)"vgSysWrap_linux_sys_splice_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"splice(fd_out)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(int ));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(vki_loff_t *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_loff_t *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3824,
                            (Char const   *)"vgSysWrap_linux_sys_splice_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3824,
                            (Char const   *)"vgSysWrap_linux_sys_splice_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"splice(off_out)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(vki_loff_t *));
      break;
    }
    while (1) {
      here___3 = layout->o_arg5;
      tmp___7 = __builtin_expect((long )(! (! (sizeof(vki_size_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___7) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_size_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3824,
                            (Char const   *)"vgSysWrap_linux_sys_splice_before",
                            "");
      }
      tmp___8 = __builtin_expect((long )(! (! (here___3 >= 0))), 1L);
      if (tmp___8) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3824,
                            (Char const   *)"vgSysWrap_linux_sys_splice_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"splice(len)",
                                            (PtrdiffT )here___3,
                                            (SizeT )sizeof(vki_size_t ));
      break;
    }
    while (1) {
      here___4 = layout->o_arg6;
      tmp___9 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___9) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3824,
                            (Char const   *)"vgSysWrap_linux_sys_splice_before",
                            "");
      }
      tmp___10 = __builtin_expect((long )(! (! (here___4 >= 0))), 1L);
      if (tmp___10) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3824,
                            (Char const   *)"vgSysWrap_linux_sys_splice_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"splice(flags)",
                                            (PtrdiffT )here___4,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
  } else {

  }
  tmp___13 = vgModuleLocal_fd_allowed((Int )arrghs->arg1,
                                      (Char const   *)"splice(fd_in)", tid,
                                      (Bool )0);
  if (tmp___13) {
    tmp___14 = vgModuleLocal_fd_allowed((Int )arrghs->arg3,
                                        (Char const   *)"splice(fd_out)", tid,
                                        (Bool )0);
    if (tmp___14) {
      if (arrghs->arg2 != 0UL) {
        while (1) {
          if (vgPlain_tdict.track_pre_mem_read) {
            (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                                  (Char *)"splice(off_in)",
                                                  arrghs->arg2,
                                                  (SizeT )sizeof(vki_loff_t ));
          } else {

          }
          break;
        }
      } else {

      }
      if (arrghs->arg4 != 0UL) {
        while (1) {
          if (vgPlain_tdict.track_pre_mem_read) {
            (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                                  (Char *)"splice(off_out)",
                                                  arrghs->arg4,
                                                  (SizeT )sizeof(vki_loff_t ));
          } else {

          }
          break;
        }
      } else {

      }
    } else {
      _L: /* CIL Label */ 
      while (1) {
        wzz = (Word )9;
        if (wzz >= 0L) {
          if (wzz < 10000L) {
            tmp___11 = 1;
          } else {
            tmp___11 = 0;
          }
        } else {
          tmp___11 = 0;
        }
        tmp___12 = __builtin_expect((long )tmp___11, 1L);
        if (tmp___12) {

        } else {
          vgPlain_assert_fail((Bool )1,
                              (Char const   *)"wzz >= 0 && wzz < 10000",
                              (Char const   *)"m_syswrap/syswrap-linux.c", 3827,
                              (Char const   *)"vgSysWrap_linux_sys_splice_before",
                              "");
        }
        status->what = (enum __anonenum_what_129 )1;
        status->sres = vgPlain_mk_SysRes_Error((UWord )wzz);
        break;
      }
    }
  } else {
    goto _L;
  }
  return;
}
}
void vgSysWrap_linux_sys_lookup_dcookie_before(ThreadId tid ,
                                               SyscallArgLayout *layout ,
                                               SyscallArgs *arrghs ,
                                               SyscallStatus *status ,
                                               UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;

  {
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_lookup_dcookie (0x%llx, %#lx, %ld)",
                   (ULong )arrghs->arg1 | ((ULong )arrghs->arg2 << 32),
                   arrghs->arg3, arrghs->arg4);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(vki_u32 ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_u32) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3847,
                            (Char const   *)"vgSysWrap_linux_sys_lookup_dcookie_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3847,
                            (Char const   *)"vgSysWrap_linux_sys_lookup_dcookie_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"lookup_dcookie(cookie_low)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(vki_u32 ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(vki_u32 ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_u32) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3847,
                            (Char const   *)"vgSysWrap_linux_sys_lookup_dcookie_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3847,
                            (Char const   *)"vgSysWrap_linux_sys_lookup_dcookie_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"lookup_dcookie(cookie_high)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(vki_u32 ));
      break;
    }
    while (1) {
      here___1 = layout->o_arg3;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(char *) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(char *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3847,
                            (Char const   *)"vgSysWrap_linux_sys_lookup_dcookie_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3847,
                            (Char const   *)"vgSysWrap_linux_sys_lookup_dcookie_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"lookup_dcookie(buf)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(char *));
      break;
    }
    while (1) {
      here___2 = layout->o_arg4;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(vki_size_t ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(vki_size_t) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3847,
                            (Char const   *)"vgSysWrap_linux_sys_lookup_dcookie_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3847,
                            (Char const   *)"vgSysWrap_linux_sys_lookup_dcookie_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"lookup_dcookie(len)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(vki_size_t ));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"lookup_dcookie(buf)",
                                             arrghs->arg3, arrghs->arg4);
    } else {

    }
    break;
  }
  return;
}
}
void vgSysWrap_linux_sys_lookup_dcookie_after(ThreadId tid ,
                                              SyscallArgs *arrghs ,
                                              SyscallStatus *status ) 
{ 
  Bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  UWord tmp___2 ;

  {
  if ((unsigned int )status->what == 1U) {
    tmp = sr_isError(status->sres);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
  } else {
    tmp___0 = 0;
  }
  tmp___1 = __builtin_expect((long )tmp___0, 1L);
  if (tmp___1) {

  } else {
    vgPlain_assert_fail((Bool )1, (Char const   *)"SUCCESS",
                        (Char const   *)"m_syswrap/syswrap-linux.c", 3852,
                        (Char const   *)"vgSysWrap_linux_sys_lookup_dcookie_after",
                        "");
  }
  if (arrghs->arg3 != (Addr )((void *)0)) {
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        tmp___2 = getRES(status);
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                                tmp___2);
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_fcntl_before(ThreadId tid , SyscallArgLayout *layout ,
                                      SyscallArgs *arrghs ,
                                      SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;
  Int here___3 ;
  long tmp___7 ;
  long tmp___8 ;
  Int here___4 ;
  long tmp___9 ;
  long tmp___10 ;
  Int here___5 ;
  long tmp___11 ;
  long tmp___12 ;
  Int here___6 ;
  long tmp___13 ;
  long tmp___14 ;
  Int here___7 ;
  long tmp___15 ;
  long tmp___16 ;
  Int here___8 ;
  long tmp___17 ;
  long tmp___18 ;
  Int here___9 ;
  long tmp___19 ;
  long tmp___20 ;
  Int here___10 ;
  long tmp___21 ;
  long tmp___22 ;
  Int here___11 ;
  long tmp___23 ;
  long tmp___24 ;
  Int here___12 ;
  long tmp___25 ;
  long tmp___26 ;

  {
  switch (arrghs->arg2) {
  case 1032UL: 
  case 1025UL: 
  case 11UL: 
  case 9UL: 
  case 3UL: 
  case 1UL: 
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_fcntl ( %ld, %ld )", arrghs->arg1, arrghs->arg2);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3893,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3893,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fcntl(fd)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3893,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3893,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fcntl(cmd)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
  } else {

  }
  break;
  case 1031UL: 
  case 10UL: 
  case 8UL: 
  case 1026UL: 
  case 1024UL: 
  case 4UL: 
  case 2UL: 
  case 1030UL: 
  case 0UL: 
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_fcntl[ARG3==\'arg\'] ( %ld, %ld, %ld )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___1 = layout->o_arg1;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3908,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3908,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fcntl(fd)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
    while (1) {
      here___2 = layout->o_arg2;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3908,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3908,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fcntl(cmd)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
    while (1) {
      here___3 = layout->o_arg3;
      tmp___7 = __builtin_expect((long )(! (! (sizeof(unsigned long ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___7) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned long) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3908,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl_before",
                            "");
      }
      tmp___8 = __builtin_expect((long )(! (! (here___3 >= 0))), 1L);
      if (tmp___8) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3908,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fcntl(arg)",
                                            (PtrdiffT )here___3,
                                            (SizeT )sizeof(unsigned long ));
      break;
    }
  } else {

  }
  break;
  case 14UL: 
  case 13UL: 
  case 12UL: 
  case 7UL: 
  case 6UL: 
  case 5UL: 
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_fcntl[ARG3==\'lock\'] ( %ld, %ld, %#lx )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___4 = layout->o_arg1;
      tmp___9 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___9) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3923,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl_before",
                            "");
      }
      tmp___10 = __builtin_expect((long )(! (! (here___4 >= 0))), 1L);
      if (tmp___10) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3923,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fcntl(fd)",
                                            (PtrdiffT )here___4,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
    while (1) {
      here___5 = layout->o_arg2;
      tmp___11 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___11) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3923,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl_before",
                            "");
      }
      tmp___12 = __builtin_expect((long )(! (! (here___5 >= 0))), 1L);
      if (tmp___12) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3923,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fcntl(cmd)",
                                            (PtrdiffT )here___5,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
    while (1) {
      here___6 = layout->o_arg3;
      tmp___13 = __builtin_expect((long )(! (! (sizeof(struct flock64 *) <= sizeof(UWord )))),
                                  1L);
      if (tmp___13) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct flock64 *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3923,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl_before",
                            "");
      }
      tmp___14 = __builtin_expect((long )(! (! (here___6 >= 0))), 1L);
      if (tmp___14) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3923,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fcntl(lock)",
                                            (PtrdiffT )here___6,
                                            (SizeT )sizeof(struct flock64 *));
      break;
    }
  } else {

  }
  break;
  case 15UL: 
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_fcntl[F_SETOWN_EX] ( %ld, %ld, %ld )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___7 = layout->o_arg1;
      tmp___15 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___15) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3930,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl_before",
                            "");
      }
      tmp___16 = __builtin_expect((long )(! (! (here___7 >= 0))), 1L);
      if (tmp___16) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3930,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fcntl(fd)",
                                            (PtrdiffT )here___7,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
    while (1) {
      here___8 = layout->o_arg2;
      tmp___17 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___17) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3930,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl_before",
                            "");
      }
      tmp___18 = __builtin_expect((long )(! (! (here___8 >= 0))), 1L);
      if (tmp___18) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3930,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fcntl(cmd)",
                                            (PtrdiffT )here___8,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
    while (1) {
      here___9 = layout->o_arg3;
      tmp___19 = __builtin_expect((long )(! (! (sizeof(struct vki_f_owner_ex *) <= sizeof(UWord )))),
                                  1L);
      if (tmp___19) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct vki_f_owner_ex *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3930,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl_before",
                            "");
      }
      tmp___20 = __builtin_expect((long )(! (! (here___9 >= 0))), 1L);
      if (tmp___20) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3930,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fcntl(arg)",
                                            (PtrdiffT )here___9,
                                            (SizeT )sizeof(struct vki_f_owner_ex *));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"fcntl(F_SETOWN_EX)",
                                            arrghs->arg3,
                                            (SizeT )sizeof(struct vki_f_owner_ex ));
    } else {

    }
    break;
  }
  break;
  case 16UL: 
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_fcntl[F_GETOWN_EX] ( %ld, %ld, %ld )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___10 = layout->o_arg1;
      tmp___21 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___21) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3938,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl_before",
                            "");
      }
      tmp___22 = __builtin_expect((long )(! (! (here___10 >= 0))), 1L);
      if (tmp___22) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3938,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fcntl(fd)",
                                            (PtrdiffT )here___10,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
    while (1) {
      here___11 = layout->o_arg2;
      tmp___23 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___23) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3938,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl_before",
                            "");
      }
      tmp___24 = __builtin_expect((long )(! (! (here___11 >= 0))), 1L);
      if (tmp___24) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3938,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fcntl(cmd)",
                                            (PtrdiffT )here___11,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
    while (1) {
      here___12 = layout->o_arg3;
      tmp___25 = __builtin_expect((long )(! (! (sizeof(struct vki_f_owner_ex *) <= sizeof(UWord )))),
                                  1L);
      if (tmp___25) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct vki_f_owner_ex *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3938,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl_before",
                            "");
      }
      tmp___26 = __builtin_expect((long )(! (! (here___12 >= 0))), 1L);
      if (tmp___26) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3938,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fcntl(arg)",
                                            (PtrdiffT )here___12,
                                            (SizeT )sizeof(struct vki_f_owner_ex *));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"fcntl(F_GETOWN_EX)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(struct vki_f_owner_ex ));
    } else {

    }
    break;
  }
  break;
  default: 
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_fcntl[UNKNOWN] ( %ld, %ld, %ld )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3);
  } else {

  }
  vgPlain_assert_fail((Bool )1, (Char const   *)"Unimplemented functionality",
                      (Char const   *)"m_syswrap/syswrap-linux.c", 3944,
                      (Char const   *)"vgSysWrap_linux_sys_fcntl_before",
                      "valgrind", "www.valgrind.org", "");
  break;
  }
  if (arrghs->arg2 == 7UL) {
    *flags |= (unsigned long )(1 << 1);
  } else
  if (arrghs->arg2 == 14UL) {
    *flags |= (unsigned long )(1 << 1);
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_fcntl_after(ThreadId tid , SyscallArgs *arrghs ,
                                     SyscallStatus *status ) 
{ 
  Bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  UWord tmp___2 ;
  Word wzz ;
  int tmp___3 ;
  long tmp___4 ;
  UWord tmp___5 ;
  UWord tmp___6 ;
  Bool tmp___7 ;
  UWord tmp___8 ;
  Word wzz___0 ;
  int tmp___9 ;
  long tmp___10 ;
  UWord tmp___11 ;
  UWord tmp___12 ;
  Bool tmp___13 ;

  {
  if ((unsigned int )status->what == 1U) {
    tmp = sr_isError(status->sres);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
  } else {
    tmp___0 = 0;
  }
  tmp___1 = __builtin_expect((long )tmp___0, 1L);
  if (tmp___1) {

  } else {
    vgPlain_assert_fail((Bool )1, (Char const   *)"SUCCESS",
                        (Char const   *)"m_syswrap/syswrap-linux.c", 3958,
                        (Char const   *)"vgSysWrap_linux_sys_fcntl_after", "");
  }
  if (arrghs->arg2 == 0UL) {
    tmp___6 = getRES(status);
    tmp___7 = vgModuleLocal_fd_allowed((Int )tmp___6,
                                       (Char const   *)"fcntl(DUPFD)", tid,
                                       (Bool )1);
    if (tmp___7) {
      if (vgPlain_clo_track_fds) {
        tmp___5 = getRES(status);
        vgModuleLocal_record_fd_open_named(tid, (Int )tmp___5);
      } else {

      }
    } else {
      tmp___2 = getRES(status);
      vgPlain_close((Int )tmp___2);
      while (1) {
        wzz = (Word )24;
        if (wzz >= 0L) {
          if (wzz < 10000L) {
            tmp___3 = 1;
          } else {
            tmp___3 = 0;
          }
        } else {
          tmp___3 = 0;
        }
        tmp___4 = __builtin_expect((long )tmp___3, 1L);
        if (tmp___4) {

        } else {
          vgPlain_assert_fail((Bool )1,
                              (Char const   *)"wzz >= 0 && wzz < 10000",
                              (Char const   *)"m_syswrap/syswrap-linux.c", 3962,
                              (Char const   *)"vgSysWrap_linux_sys_fcntl_after",
                              "");
        }
        status->what = (enum __anonenum_what_129 )1;
        status->sres = vgPlain_mk_SysRes_Error((UWord )wzz);
        break;
      }
    }
  } else
  if (arrghs->arg2 == 1030UL) {
    tmp___12 = getRES(status);
    tmp___13 = vgModuleLocal_fd_allowed((Int )tmp___12,
                                        (Char const   *)"fcntl(DUPFD_CLOEXEC)",
                                        tid, (Bool )1);
    if (tmp___13) {
      if (vgPlain_clo_track_fds) {
        tmp___11 = getRES(status);
        vgModuleLocal_record_fd_open_named(tid, (Int )tmp___11);
      } else {

      }
    } else {
      tmp___8 = getRES(status);
      vgPlain_close((Int )tmp___8);
      while (1) {
        wzz___0 = (Word )24;
        if (wzz___0 >= 0L) {
          if (wzz___0 < 10000L) {
            tmp___9 = 1;
          } else {
            tmp___9 = 0;
          }
        } else {
          tmp___9 = 0;
        }
        tmp___10 = __builtin_expect((long )tmp___9, 1L);
        if (tmp___10) {

        } else {
          vgPlain_assert_fail((Bool )1,
                              (Char const   *)"wzz >= 0 && wzz < 10000",
                              (Char const   *)"m_syswrap/syswrap-linux.c", 3971,
                              (Char const   *)"vgSysWrap_linux_sys_fcntl_after",
                              "");
        }
        status->what = (enum __anonenum_what_129 )1;
        status->sres = vgPlain_mk_SysRes_Error((UWord )wzz___0);
        break;
      }
    }
  } else
  if (arrghs->arg2 == 16UL) {
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                                (SizeT )sizeof(struct vki_f_owner_ex ));
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_fcntl64_before(ThreadId tid ,
                                        SyscallArgLayout *layout ,
                                        SyscallArgs *arrghs ,
                                        SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;
  Int here___3 ;
  long tmp___7 ;
  long tmp___8 ;
  Int here___4 ;
  long tmp___9 ;
  long tmp___10 ;
  Int here___5 ;
  long tmp___11 ;
  long tmp___12 ;
  Int here___6 ;
  long tmp___13 ;
  long tmp___14 ;
  Int here___7 ;
  long tmp___15 ;
  long tmp___16 ;
  Int here___8 ;
  long tmp___17 ;
  long tmp___18 ;
  Int here___9 ;
  long tmp___19 ;
  long tmp___20 ;
  Int here___10 ;
  long tmp___21 ;
  long tmp___22 ;
  Int here___11 ;
  long tmp___23 ;
  long tmp___24 ;
  Int here___12 ;
  long tmp___25 ;
  long tmp___26 ;

  {
  switch (arrghs->arg2) {
  case 1025UL: 
  case 10UL: 
  case 11UL: 
  case 8UL: 
  case 9UL: 
  case 3UL: 
  case 1UL: 
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_fcntl64 ( %ld, %ld )", arrghs->arg1, arrghs->arg2);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3994,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl64_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3994,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl64_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fcntl64(fd)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3994,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl64_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 3994,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl64_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fcntl64(cmd)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
  } else {

  }
  break;
  case 1026UL: 
  case 1024UL: 
  case 4UL: 
  case 2UL: 
  case 1030UL: 
  case 0UL: 
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_fcntl64[ARG3==\'arg\'] ( %ld, %ld, %ld )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___1 = layout->o_arg1;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 4006,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl64_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 4006,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl64_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fcntl64(fd)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
    while (1) {
      here___2 = layout->o_arg2;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 4006,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl64_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 4006,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl64_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fcntl64(cmd)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
    while (1) {
      here___3 = layout->o_arg3;
      tmp___7 = __builtin_expect((long )(! (! (sizeof(unsigned long ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___7) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned long) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 4006,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl64_before",
                            "");
      }
      tmp___8 = __builtin_expect((long )(! (! (here___3 >= 0))), 1L);
      if (tmp___8) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 4006,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl64_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fcntl64(arg)",
                                            (PtrdiffT )here___3,
                                            (SizeT )sizeof(unsigned long ));
      break;
    }
  } else {

  }
  break;
  case 14UL: 
  case 13UL: 
  case 12UL: 
  case 7UL: 
  case 6UL: 
  case 5UL: 
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_fcntl64[ARG3==\'lock\'] ( %ld, %ld, %#lx )",
                   arrghs->arg1, arrghs->arg2, arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___4 = layout->o_arg1;
      tmp___9 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___9) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 4021,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl64_before",
                            "");
      }
      tmp___10 = __builtin_expect((long )(! (! (here___4 >= 0))), 1L);
      if (tmp___10) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 4021,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl64_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fcntl64(fd)",
                                            (PtrdiffT )here___4,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
    while (1) {
      here___5 = layout->o_arg2;
      tmp___11 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___11) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 4021,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl64_before",
                            "");
      }
      tmp___12 = __builtin_expect((long )(! (! (here___5 >= 0))), 1L);
      if (tmp___12) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 4021,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl64_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fcntl64(cmd)",
                                            (PtrdiffT )here___5,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
    while (1) {
      here___6 = layout->o_arg3;
      tmp___13 = __builtin_expect((long )(! (! (sizeof(struct flock64 *) <= sizeof(UWord )))),
                                  1L);
      if (tmp___13) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct flock64 *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 4021,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl64_before",
                            "");
      }
      tmp___14 = __builtin_expect((long )(! (! (here___6 >= 0))), 1L);
      if (tmp___14) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 4021,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl64_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fcntl64(lock)",
                                            (PtrdiffT )here___6,
                                            (SizeT )sizeof(struct flock64 *));
      break;
    }
  } else {

  }
  break;
  case 15UL: 
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_fcntl[F_SETOWN_EX] ( %ld, %ld, %ld )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___7 = layout->o_arg1;
      tmp___15 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___15) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 4028,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl64_before",
                            "");
      }
      tmp___16 = __builtin_expect((long )(! (! (here___7 >= 0))), 1L);
      if (tmp___16) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 4028,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl64_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fcntl(fd)",
                                            (PtrdiffT )here___7,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
    while (1) {
      here___8 = layout->o_arg2;
      tmp___17 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___17) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 4028,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl64_before",
                            "");
      }
      tmp___18 = __builtin_expect((long )(! (! (here___8 >= 0))), 1L);
      if (tmp___18) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 4028,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl64_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fcntl(cmd)",
                                            (PtrdiffT )here___8,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
    while (1) {
      here___9 = layout->o_arg3;
      tmp___19 = __builtin_expect((long )(! (! (sizeof(struct vki_f_owner_ex *) <= sizeof(UWord )))),
                                  1L);
      if (tmp___19) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct vki_f_owner_ex *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 4028,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl64_before",
                            "");
      }
      tmp___20 = __builtin_expect((long )(! (! (here___9 >= 0))), 1L);
      if (tmp___20) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 4028,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl64_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fcntl(arg)",
                                            (PtrdiffT )here___9,
                                            (SizeT )sizeof(struct vki_f_owner_ex *));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"fcntl(F_SETOWN_EX)",
                                            arrghs->arg3,
                                            (SizeT )sizeof(struct vki_f_owner_ex ));
    } else {

    }
    break;
  }
  break;
  case 16UL: 
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_fcntl[F_GETOWN_EX] ( %ld, %ld, %ld )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___10 = layout->o_arg1;
      tmp___21 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___21) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 4036,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl64_before",
                            "");
      }
      tmp___22 = __builtin_expect((long )(! (! (here___10 >= 0))), 1L);
      if (tmp___22) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 4036,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl64_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fcntl(fd)",
                                            (PtrdiffT )here___10,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
    while (1) {
      here___11 = layout->o_arg2;
      tmp___23 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                  1L);
      if (tmp___23) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 4036,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl64_before",
                            "");
      }
      tmp___24 = __builtin_expect((long )(! (! (here___11 >= 0))), 1L);
      if (tmp___24) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 4036,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl64_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fcntl(cmd)",
                                            (PtrdiffT )here___11,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
    while (1) {
      here___12 = layout->o_arg3;
      tmp___25 = __builtin_expect((long )(! (! (sizeof(struct vki_f_owner_ex *) <= sizeof(UWord )))),
                                  1L);
      if (tmp___25) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(struct vki_f_owner_ex *) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 4036,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl64_before",
                            "");
      }
      tmp___26 = __builtin_expect((long )(! (! (here___12 >= 0))), 1L);
      if (tmp___26) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 4036,
                            (Char const   *)"vgSysWrap_linux_sys_fcntl64_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"fcntl(arg)",
                                            (PtrdiffT )here___12,
                                            (SizeT )sizeof(struct vki_f_owner_ex *));
      break;
    }
  } else {

  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"fcntl(F_GETOWN_EX)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(struct vki_f_owner_ex ));
    } else {

    }
    break;
  }
  break;
  }
  if (arrghs->arg2 == 7UL) {
    *flags |= (unsigned long )(1 << 1);
  } else
  if (arrghs->arg2 == 14UL) {
    *flags |= (unsigned long )(1 << 1);
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_fcntl64_after(ThreadId tid , SyscallArgs *arrghs ,
                                       SyscallStatus *status ) 
{ 
  Bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  UWord tmp___2 ;
  Word wzz ;
  int tmp___3 ;
  long tmp___4 ;
  UWord tmp___5 ;
  UWord tmp___6 ;
  Bool tmp___7 ;
  UWord tmp___8 ;
  Word wzz___0 ;
  int tmp___9 ;
  long tmp___10 ;
  UWord tmp___11 ;
  UWord tmp___12 ;
  Bool tmp___13 ;

  {
  if ((unsigned int )status->what == 1U) {
    tmp = sr_isError(status->sres);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
  } else {
    tmp___0 = 0;
  }
  tmp___1 = __builtin_expect((long )tmp___0, 1L);
  if (tmp___1) {

  } else {
    vgPlain_assert_fail((Bool )1, (Char const   *)"SUCCESS",
                        (Char const   *)"m_syswrap/syswrap-linux.c", 4051,
                        (Char const   *)"vgSysWrap_linux_sys_fcntl64_after", "");
  }
  if (arrghs->arg2 == 0UL) {
    tmp___6 = getRES(status);
    tmp___7 = vgModuleLocal_fd_allowed((Int )tmp___6,
                                       (Char const   *)"fcntl64(DUPFD)", tid,
                                       (Bool )1);
    if (tmp___7) {
      if (vgPlain_clo_track_fds) {
        tmp___5 = getRES(status);
        vgModuleLocal_record_fd_open_named(tid, (Int )tmp___5);
      } else {

      }
    } else {
      tmp___2 = getRES(status);
      vgPlain_close((Int )tmp___2);
      while (1) {
        wzz = (Word )24;
        if (wzz >= 0L) {
          if (wzz < 10000L) {
            tmp___3 = 1;
          } else {
            tmp___3 = 0;
          }
        } else {
          tmp___3 = 0;
        }
        tmp___4 = __builtin_expect((long )tmp___3, 1L);
        if (tmp___4) {

        } else {
          vgPlain_assert_fail((Bool )1,
                              (Char const   *)"wzz >= 0 && wzz < 10000",
                              (Char const   *)"m_syswrap/syswrap-linux.c", 4055,
                              (Char const   *)"vgSysWrap_linux_sys_fcntl64_after",
                              "");
        }
        status->what = (enum __anonenum_what_129 )1;
        status->sres = vgPlain_mk_SysRes_Error((UWord )wzz);
        break;
      }
    }
  } else
  if (arrghs->arg2 == 1030UL) {
    tmp___12 = getRES(status);
    tmp___13 = vgModuleLocal_fd_allowed((Int )tmp___12,
                                        (Char const   *)"fcntl64(DUPFD_CLOEXEC)",
                                        tid, (Bool )1);
    if (tmp___13) {
      if (vgPlain_clo_track_fds) {
        tmp___11 = getRES(status);
        vgModuleLocal_record_fd_open_named(tid, (Int )tmp___11);
      } else {

      }
    } else {
      tmp___8 = getRES(status);
      vgPlain_close((Int )tmp___8);
      while (1) {
        wzz___0 = (Word )24;
        if (wzz___0 >= 0L) {
          if (wzz___0 < 10000L) {
            tmp___9 = 1;
          } else {
            tmp___9 = 0;
          }
        } else {
          tmp___9 = 0;
        }
        tmp___10 = __builtin_expect((long )tmp___9, 1L);
        if (tmp___10) {

        } else {
          vgPlain_assert_fail((Bool )1,
                              (Char const   *)"wzz >= 0 && wzz < 10000",
                              (Char const   *)"m_syswrap/syswrap-linux.c", 4064,
                              (Char const   *)"vgSysWrap_linux_sys_fcntl64_after",
                              "");
        }
        status->what = (enum __anonenum_what_129 )1;
        status->sres = vgPlain_mk_SysRes_Error((UWord )wzz___0);
        break;
      }
    }
  } else
  if (arrghs->arg2 == 16UL) {
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                                (SizeT )sizeof(struct vki_f_owner_ex ));
      } else {

      }
      break;
    }
  } else {

  }
  return;
}
}
void vgSysWrap_linux_sys_ioctl_before(ThreadId tid , SyscallArgLayout *layout ,
                                      SyscallArgs *arrghs ,
                                      SyscallStatus *status , UWord *flags ) 
{ 
  Int here ;
  long tmp ;
  long tmp___0 ;
  Int here___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Int here___1 ;
  long tmp___3 ;
  long tmp___4 ;
  Int here___2 ;
  long tmp___5 ;
  long tmp___6 ;
  Int here___3 ;
  long tmp___7 ;
  long tmp___8 ;
  struct vki_ifconf *ifc ;
  struct vki_cdrom_read_audio *cra ;
  struct vki_consolefontdesc *cfd ;
  struct vki_consolefontdesc *cfd___0 ;
  struct vki_unimapdesc *desc ;
  struct vki_unimapdesc *desc___0 ;
  struct vki_console_font_op *op ;
  struct vki_usbdevfs_ctrltransfer *vkuc ;
  struct vki_usbdevfs_bulktransfer *vkub ;
  struct vki_usbdevfs_getdriver *vkugd ;
  struct vki_usbdevfs_urb *vkuu ;
  struct vki_usbdevfs_setuppacket *vkusp ;
  int total_length ;
  int i ;
  struct vki_usbdevfs_ioctl *vkui ;
  UInt dir2 ;
  UInt size2 ;
  struct vki_iw_point *point ;

  {
  *flags |= (unsigned long )(1 << 1);
  switch (arrghs->arg2) {
  case 21377UL: 
  case 21376UL: 
  case 21667UL: 
  case 21666UL: 
  case 21665UL: 
  case 21664UL: 
  case 16737UL: 
  case 16712UL: 
  case 16711UL: 
  case 16708UL: 
  case 16707UL: 
  case 16706UL: 
  case 16705UL: 
  case 16704UL: 
  case 16674UL: 
  case 16658UL: 
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_ioctl ( %ld, 0x%lx )", arrghs->arg1, arrghs->arg2);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here = layout->o_arg1;
      tmp = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                             1L);
      if (tmp) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 4107,
                            (Char const   *)"vgSysWrap_linux_sys_ioctl_before",
                            "");
      }
      tmp___0 = __builtin_expect((long )(! (! (here >= 0))), 1L);
      if (tmp___0) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 4107,
                            (Char const   *)"vgSysWrap_linux_sys_ioctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"ioctl(fd)",
                                            (PtrdiffT )here,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
    while (1) {
      here___0 = layout->o_arg2;
      tmp___1 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___1) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 4107,
                            (Char const   *)"vgSysWrap_linux_sys_ioctl_before",
                            "");
      }
      tmp___2 = __builtin_expect((long )(! (! (here___0 >= 0))), 1L);
      if (tmp___2) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 4107,
                            (Char const   *)"vgSysWrap_linux_sys_ioctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"ioctl(request)",
                                            (PtrdiffT )here___0,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
  } else {

  }
  return;
  default: 
  if (vgPlain_clo_trace_syscalls) {
    vgPlain_printf("sys_ioctl ( %ld, 0x%lx, 0x%lx )", arrghs->arg1,
                   arrghs->arg2, arrghs->arg3);
  } else {

  }
  if (vgPlain_tdict.track_pre_reg_read) {
    (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                          (Char *)"(syscallno)",
                                          (PtrdiffT )layout->o_sysno,
                                          (SizeT )sizeof(UWord ));
    while (1) {
      here___1 = layout->o_arg1;
      tmp___3 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___3) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 4113,
                            (Char const   *)"vgSysWrap_linux_sys_ioctl_before",
                            "");
      }
      tmp___4 = __builtin_expect((long )(! (! (here___1 >= 0))), 1L);
      if (tmp___4) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 4113,
                            (Char const   *)"vgSysWrap_linux_sys_ioctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"ioctl(fd)",
                                            (PtrdiffT )here___1,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
    while (1) {
      here___2 = layout->o_arg2;
      tmp___5 = __builtin_expect((long )(! (! (sizeof(unsigned int ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___5) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned int) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 4113,
                            (Char const   *)"vgSysWrap_linux_sys_ioctl_before",
                            "");
      }
      tmp___6 = __builtin_expect((long )(! (! (here___2 >= 0))), 1L);
      if (tmp___6) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 4113,
                            (Char const   *)"vgSysWrap_linux_sys_ioctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"ioctl(request)",
                                            (PtrdiffT )here___2,
                                            (SizeT )sizeof(unsigned int ));
      break;
    }
    while (1) {
      here___3 = layout->o_arg3;
      tmp___7 = __builtin_expect((long )(! (! (sizeof(unsigned long ) <= sizeof(UWord )))),
                                 1L);
      if (tmp___7) {

      } else {
        vgPlain_assert_fail((Bool )1,
                            (Char const   *)"sizeof(unsigned long) <= sizeof(UWord)",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 4113,
                            (Char const   *)"vgSysWrap_linux_sys_ioctl_before",
                            "");
      }
      tmp___8 = __builtin_expect((long )(! (! (here___3 >= 0))), 1L);
      if (tmp___8) {

      } else {
        vgPlain_assert_fail((Bool )1, (Char const   *)"here >= 0",
                            (Char const   *)"m_syswrap/syswrap-linux.c", 4113,
                            (Char const   *)"vgSysWrap_linux_sys_ioctl_before",
                            "");
      }
      (*(vgPlain_tdict.track_pre_reg_read))((CorePart )3, tid,
                                            (Char *)"ioctl(arg)",
                                            (PtrdiffT )here___3,
                                            (SizeT )sizeof(unsigned long ));
      break;
    }
  } else {

  }
  break;
  }
  switch (arrghs->arg2) {
  case 21508UL: 
  case 21507UL: 
  case 21506UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(TCSET{S,SW,SF})",
                                            arrghs->arg3,
                                            (SizeT )sizeof(struct vki_termios ));
    } else {

    }
    break;
  }
  break;
  case 21505UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(TCGETS)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(struct vki_termios ));
    } else {

    }
    break;
  }
  break;
  case 21512UL: 
  case 21511UL: 
  case 21510UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(TCSET{A,AW,AF})",
                                            arrghs->arg3,
                                            (SizeT )sizeof(struct vki_termio ));
    } else {

    }
    break;
  }
  break;
  case 21509UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(TCGETA)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(struct vki_termio ));
    } else {

    }
    break;
  }
  break;
  case 21515UL: 
  case 21541UL: 
  case 21514UL: 
  case 21513UL: 
  break;
  case 21523UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(TIOCGWINSZ)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(struct vki_winsize ));
    } else {

    }
    break;
  }
  break;
  case 21524UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(TIOCSWINSZ)",
                                            arrghs->arg3,
                                            (SizeT )sizeof(struct vki_winsize ));
    } else {

    }
    break;
  }
  break;
  case 21526UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(TIOCMBIS)",
                                            arrghs->arg3,
                                            (SizeT )sizeof(unsigned int ));
    } else {

    }
    break;
  }
  break;
  case 21527UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(TIOCMBIC)",
                                            arrghs->arg3,
                                            (SizeT )sizeof(unsigned int ));
    } else {

    }
    break;
  }
  break;
  case 21528UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(TIOCMSET)",
                                            arrghs->arg3,
                                            (SizeT )sizeof(unsigned int ));
    } else {

    }
    break;
  }
  break;
  case 21525UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(TIOCMGET)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(unsigned int ));
    } else {

    }
    break;
  }
  break;
  case 21532UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(TIOCLINUX)",
                                            arrghs->arg3, (SizeT )sizeof(char *));
    } else {

    }
    break;
  }
  if ((int )*((char *)arrghs->arg3) == 11) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"ioctl(TIOCLINUX, 11)",
                                              arrghs->arg3,
                                              (SizeT )(2U * sizeof(char *)));
      } else {

      }
      break;
    }
  } else {

  }
  break;
  case 21519UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(TIOCGPGRP)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(vki_pid_t ));
    } else {

    }
    break;
  }
  break;
  case 21520UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(TIOCGPGRP)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(vki_pid_t ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((((2U << 30) | (unsigned int )(84 << 8)) | 48U) | ((sizeof(struct __anonstruct_132 ) + sizeof(unsigned int )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(TIOCGPTN)",
                                             arrghs->arg3, (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case 21518UL: 
  break;
  case (UWord )((((1U << 30) | (unsigned int )(84 << 8)) | 49U) | ((sizeof(struct __anonstruct_133 ) + sizeof(int )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(TIOCSPTLCK)",
                                            arrghs->arg3, (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case 21537UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(FIONBIO)",
                                            arrghs->arg3, (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case 21586UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(FIOASYNC)",
                                            arrghs->arg3, (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case 21531UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(FIONREAD)",
                                             arrghs->arg3, (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case 21600UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(FIOQSIZE)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(vki_loff_t ));
    } else {

    }
    break;
  }
  break;
  case 21593UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(TIOCSERGETLSR)",
                                             arrghs->arg3, (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case 21597UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(TIOCGICOUNT)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(struct vki_serial_icounter_struct ));
    } else {

    }
    break;
  }
  break;
  case 8817UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(SG_SET_COMMAND_Q)",
                                            arrghs->arg3, (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case 8837UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(SG_IO)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(vki_sg_io_hdr_t ));
    } else {

    }
    break;
  }
  break;
  case 8822UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(SG_GET_SCSI_ID)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(vki_sg_scsi_id_t ));
    } else {

    }
    break;
  }
  break;
  case 8821UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(SG_SET_RESERVED_SIZE)",
                                            arrghs->arg3, (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case 8705UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(SG_SET_TIMEOUT)",
                                            arrghs->arg3, (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case 8818UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(SG_GET_RESERVED_SIZE)",
                                             arrghs->arg3, (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case 8706UL: 
  break;
  case 8834UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(SG_GET_VERSION_NUM)",
                                             arrghs->arg3, (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case 8707UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(SG_EMULATED_HOST)",
                                             arrghs->arg3, (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case 8831UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(SG_GET_SG_TABLESIZE)",
                                             arrghs->arg3, (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((unsigned int )(73 << 8) | 21U): 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(IIOCGETCPS)",
                                             arrghs->arg3,
                                             (SizeT )(128U * sizeof(unsigned long )));
    } else {

    }
    break;
  }
  break;
  case (UWord )((unsigned int )(73 << 8) | 34U): 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(IIOCNETGPN)",
                                            (Addr )(& ((vki_isdn_net_ioctl_phone *)arrghs->arg3)->name),
                                            (SizeT )sizeof(((vki_isdn_net_ioctl_phone *)arrghs->arg3)->name));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(IIOCNETGPN)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(vki_isdn_net_ioctl_phone ));
    } else {

    }
    break;
  }
  break;
  case 35123UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"ioctl(SIOCGIFINDEX)",
                                                   (Addr )(((struct vki_ifreq *)arrghs->arg3)->ifr_ifrn.ifrn_name));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(SIOCGIFINDEX)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(struct vki_ifreq ));
    } else {

    }
    break;
  }
  break;
  case 35091UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"ioctl(SIOCGIFFLAGS)",
                                                   (Addr )(((struct vki_ifreq *)arrghs->arg3)->ifr_ifrn.ifrn_name));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(SIOCGIFFLAGS)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(struct vki_ifreq ));
    } else {

    }
    break;
  }
  break;
  case 35111UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"ioctl(SIOCGIFHWADDR)",
                                                   (Addr )(((struct vki_ifreq *)arrghs->arg3)->ifr_ifrn.ifrn_name));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(SIOCGIFHWADDR)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(struct vki_ifreq ));
    } else {

    }
    break;
  }
  break;
  case 35105UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"ioctl(SIOCGIFMTU)",
                                                   (Addr )(((struct vki_ifreq *)arrghs->arg3)->ifr_ifrn.ifrn_name));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(SIOCGIFMTU)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(struct vki_ifreq ));
    } else {

    }
    break;
  }
  break;
  case 35093UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"ioctl(SIOCGIFADDR)",
                                                   (Addr )(((struct vki_ifreq *)arrghs->arg3)->ifr_ifrn.ifrn_name));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(SIOCGIFADDR)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(struct vki_ifreq ));
    } else {

    }
    break;
  }
  break;
  case 35099UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"ioctl(SIOCGIFNETMASK)",
                                                   (Addr )(((struct vki_ifreq *)arrghs->arg3)->ifr_ifrn.ifrn_name));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(SIOCGIFNETMASK)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(struct vki_ifreq ));
    } else {

    }
    break;
  }
  break;
  case 35101UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"ioctl(SIOCGIFMETRIC)",
                                                   (Addr )(((struct vki_ifreq *)arrghs->arg3)->ifr_ifrn.ifrn_name));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(SIOCGIFMETRIC)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(struct vki_ifreq ));
    } else {

    }
    break;
  }
  break;
  case 35184UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"ioctl(SIOCGIFMAP)",
                                                   (Addr )(((struct vki_ifreq *)arrghs->arg3)->ifr_ifrn.ifrn_name));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(SIOCGIFMAP)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(struct vki_ifreq ));
    } else {

    }
    break;
  }
  break;
  case 35138UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"ioctl(SIOCGIFTXQLEN)",
                                                   (Addr )(((struct vki_ifreq *)arrghs->arg3)->ifr_ifrn.ifrn_name));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(SIOCGIFTXQLEN)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(struct vki_ifreq ));
    } else {

    }
    break;
  }
  break;
  case 35095UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"ioctl(SIOCGIFDSTADDR)",
                                                   (Addr )(((struct vki_ifreq *)arrghs->arg3)->ifr_ifrn.ifrn_name));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(SIOCGIFDSTADDR)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(struct vki_ifreq ));
    } else {

    }
    break;
  }
  break;
  case 35097UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"ioctl(SIOCGIFBRDADDR)",
                                                   (Addr )(((struct vki_ifreq *)arrghs->arg3)->ifr_ifrn.ifrn_name));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(SIOCGIFBRDADDR)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(struct vki_ifreq ));
    } else {

    }
    break;
  }
  break;
  case 35088UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(SIOCGIFNAME)",
                                            (Addr )(& ((struct vki_ifreq *)arrghs->arg3)->ifr_ifru.ifru_ivalue),
                                            (SizeT )sizeof(((struct vki_ifreq *)arrghs->arg3)->ifr_ifru.ifru_ivalue));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(SIOCGIFNAME)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(struct vki_ifreq ));
    } else {

    }
    break;
  }
  break;
  case 35143UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"ioctl(SIOCGIFMIIPHY)",
                                                   (Addr )(((struct vki_ifreq *)arrghs->arg3)->ifr_ifrn.ifrn_name));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(SIOCGIFMIIPHY)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(struct vki_ifreq ));
    } else {

    }
    break;
  }
  break;
  case 35144UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"ioctl(SIOCGIFMIIREG)",
                                                   (Addr )(((struct vki_ifreq *)arrghs->arg3)->ifr_ifrn.ifrn_name));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(SIOCGIFMIIREG)",
                                            (Addr )(& ((struct vki_mii_ioctl_data *)(& ((struct vki_ifreq *)arrghs->arg3)->ifr_ifru.ifru_data))->phy_id),
                                            (SizeT )sizeof(((struct vki_mii_ioctl_data *)(& ((struct vki_ifreq *)arrghs->arg3)->ifr_ifru.ifru_data))->phy_id));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(SIOCGIFMIIREG)",
                                            (Addr )(& ((struct vki_mii_ioctl_data *)(& ((struct vki_ifreq *)arrghs->arg3)->ifr_ifru.ifru_data))->reg_num),
                                            (SizeT )sizeof(((struct vki_mii_ioctl_data *)(& ((struct vki_ifreq *)arrghs->arg3)->ifr_ifru.ifru_data))->reg_num));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(SIOCGIFMIIREG)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(struct vki_ifreq ));
    } else {

    }
    break;
  }
  break;
  case 35090UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(SIOCGIFCONF)",
                                            (Addr )(& ((struct vki_ifconf *)arrghs->arg3)->ifc_len),
                                            (SizeT )sizeof(((struct vki_ifconf *)arrghs->arg3)->ifc_len));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(SIOCGIFCONF)",
                                            (Addr )(& ((struct vki_ifconf *)arrghs->arg3)->ifc_ifcu.ifcu_buf),
                                            (SizeT )sizeof(((struct vki_ifconf *)arrghs->arg3)->ifc_ifcu.ifcu_buf));
    } else {

    }
    break;
  }
  if (arrghs->arg3) {
    ifc = (struct vki_ifconf *)arrghs->arg3;
    while (1) {
      if (vgPlain_tdict.track_pre_mem_write) {
        (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                               (Char *)"ioctl(SIOCGIFCONF).ifc_buf",
                                               (Addr )ifc->ifc_ifcu.ifcu_buf,
                                               (SizeT )ifc->ifc_len);
      } else {

      }
      break;
    }
  } else {

  }
  break;
  case 35078UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(SIOCGSTAMP)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(struct vki_timeval ));
    } else {

    }
    break;
  }
  break;
  case 35079UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(SIOCGSTAMPNS)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(struct vki_timespec ));
    } else {

    }
    break;
  }
  break;
  case 21521UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(SIOCOUTQ)",
                                             arrghs->arg3, (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case 35156UL: 
  case 35169UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(SIOCGARP)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(struct vki_arpreq ));
    } else {

    }
    break;
  }
  break;
  case 35092UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"ioctl(SIOCSIFFLAGS)",
                                                   (Addr )(((struct vki_ifreq *)arrghs->arg3)->ifr_ifrn.ifrn_name));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(SIOCSIFFLAGS)",
                                            (Addr )(& ((struct vki_ifreq *)arrghs->arg3)->ifr_ifru.ifru_flags),
                                            (SizeT )sizeof(((struct vki_ifreq *)arrghs->arg3)->ifr_ifru.ifru_flags));
    } else {

    }
    break;
  }
  break;
  case 35185UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"ioctl(SIOCSIFMAP)",
                                                   (Addr )(((struct vki_ifreq *)arrghs->arg3)->ifr_ifrn.ifrn_name));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(SIOCSIFMAP)",
                                            (Addr )(& ((struct vki_ifreq *)arrghs->arg3)->ifr_ifru.ifru_map),
                                            (SizeT )sizeof(((struct vki_ifreq *)arrghs->arg3)->ifr_ifru.ifru_map));
    } else {

    }
    break;
  }
  break;
  case 35139UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"ioctl(SIOCSIFTXQLEN)",
                                                   (Addr )(((struct vki_ifreq *)arrghs->arg3)->ifr_ifrn.ifrn_name));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(SIOCSIFTXQLEN)",
                                            (Addr )(& ((struct vki_ifreq *)arrghs->arg3)->ifr_ifru.ifru_ivalue),
                                            (SizeT )sizeof(((struct vki_ifreq *)arrghs->arg3)->ifr_ifru.ifru_ivalue));
    } else {

    }
    break;
  }
  break;
  case 35100UL: 
  case 35098UL: 
  case 35096UL: 
  case 35094UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"ioctl(SIOCSIF*ADDR)",
                                                   (Addr )(((struct vki_ifreq *)arrghs->arg3)->ifr_ifrn.ifrn_name));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(SIOCSIF*ADDR)",
                                            (Addr )(& ((struct vki_ifreq *)arrghs->arg3)->ifr_ifru.ifru_addr),
                                            (SizeT )sizeof(((struct vki_ifreq *)arrghs->arg3)->ifr_ifru.ifru_addr));
    } else {

    }
    break;
  }
  break;
  case 35102UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"ioctl(SIOCSIFMETRIC)",
                                                   (Addr )(((struct vki_ifreq *)arrghs->arg3)->ifr_ifrn.ifrn_name));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(SIOCSIFMETRIC)",
                                            (Addr )(& ((struct vki_ifreq *)arrghs->arg3)->ifr_ifru.ifru_ivalue),
                                            (SizeT )sizeof(((struct vki_ifreq *)arrghs->arg3)->ifr_ifru.ifru_ivalue));
    } else {

    }
    break;
  }
  break;
  case 35106UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"ioctl(SIOCSIFMTU)",
                                                   (Addr )(((struct vki_ifreq *)arrghs->arg3)->ifr_ifrn.ifrn_name));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(SIOCSIFMTU)",
                                            (Addr )(& ((struct vki_ifreq *)arrghs->arg3)->ifr_ifru.ifru_mtu),
                                            (SizeT )sizeof(((struct vki_ifreq *)arrghs->arg3)->ifr_ifru.ifru_mtu));
    } else {

    }
    break;
  }
  break;
  case 35108UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"ioctl(SIOCSIFHWADDR)",
                                                   (Addr )(((struct vki_ifreq *)arrghs->arg3)->ifr_ifrn.ifrn_name));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(SIOCSIFHWADDR)",
                                            (Addr )(& ((struct vki_ifreq *)arrghs->arg3)->ifr_ifru.ifru_hwaddr),
                                            (SizeT )sizeof(((struct vki_ifreq *)arrghs->arg3)->ifr_ifru.ifru_hwaddr));
    } else {

    }
    break;
  }
  break;
  case 35145UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"ioctl(SIOCSMIIREG)",
                                                   (Addr )(((struct vki_ifreq *)arrghs->arg3)->ifr_ifrn.ifrn_name));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(SIOCSMIIREG)",
                                            (Addr )(& ((struct vki_mii_ioctl_data *)(& ((struct vki_ifreq *)arrghs->arg3)->ifr_ifru.ifru_data))->phy_id),
                                            (SizeT )sizeof(((struct vki_mii_ioctl_data *)(& ((struct vki_ifreq *)arrghs->arg3)->ifr_ifru.ifru_data))->phy_id));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(SIOCSMIIREG)",
                                            (Addr )(& ((struct vki_mii_ioctl_data *)(& ((struct vki_ifreq *)arrghs->arg3)->ifr_ifru.ifru_data))->reg_num),
                                            (SizeT )sizeof(((struct vki_mii_ioctl_data *)(& ((struct vki_ifreq *)arrghs->arg3)->ifr_ifru.ifru_data))->reg_num));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(SIOCSMIIREG)",
                                            (Addr )(& ((struct vki_mii_ioctl_data *)(& ((struct vki_ifreq *)arrghs->arg3)->ifr_ifru.ifru_data))->val_in),
                                            (SizeT )sizeof(((struct vki_mii_ioctl_data *)(& ((struct vki_ifreq *)arrghs->arg3)->ifr_ifru.ifru_data))->val_in));
    } else {

    }
    break;
  }
  break;
  case 35084UL: 
  case 35083UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(SIOCADDRT/DELRT)",
                                            arrghs->arg3,
                                            (SizeT )sizeof(struct vki_rtentry ));
    } else {

    }
    break;
  }
  break;
  case 35155UL: 
  case 35157UL: 
  case 35170UL: 
  case 35168UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(SIOCSIFFLAGS)",
                                            arrghs->arg3,
                                            (SizeT )sizeof(struct vki_ifreq ));
    } else {

    }
    break;
  }
  break;
  case 35076UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(SIOCGPGRP)",
                                             arrghs->arg3, (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case 35074UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(SIOCSPGRP)",
                                            arrghs->arg3, (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((((2U << 30) | (unsigned int )(80 << 8)) | 7U) | ((sizeof(struct __anonstruct_151 ) + sizeof(int )) << 16)): 
  case (UWord )((((2U << 30) | (unsigned int )(80 << 8)) | 5U) | ((sizeof(struct __anonstruct_150 ) + sizeof(int )) << 16)): 
  case (UWord )((((2U << 30) | (unsigned int )(80 << 8)) | 6U) | ((sizeof(struct __anonstruct_149 ) + sizeof(int )) << 16)): 
  case (UWord )((((2U << 30) | (unsigned int )(80 << 8)) | 2U) | ((sizeof(struct __anonstruct_148 ) + sizeof(int )) << 16)): 
  case (UWord )((((2U << 30) | (unsigned int )(80 << 8)) | 15U) | ((sizeof(struct __anonstruct_147 ) + sizeof(int )) << 16)): 
  case (UWord )((((2U << 30) | (unsigned int )(80 << 8)) | 67U) | ((sizeof(struct __anonstruct_146 ) + sizeof(int )) << 16)): 
  case (UWord )((((2U << 30) | (unsigned int )(80 << 8)) | 23U) | ((sizeof(struct __anonstruct_145 ) + sizeof(int )) << 16)): 
  case (UWord )((((2U << 30) | (unsigned int )(80 << 8)) | 16U) | ((sizeof(struct __anonstruct_144 ) + sizeof(int )) << 16)): 
  case (UWord )((((2U << 30) | (unsigned int )(80 << 8)) | 11U) | ((sizeof(struct __anonstruct_143 ) + sizeof(int )) << 16)): 
  case (UWord )((((3U << 30) | (unsigned int )(80 << 8)) | 4U) | ((sizeof(struct __anonstruct_142 ) + sizeof(int )) << 16)): 
  case (UWord )((((2U << 30) | (unsigned int )(81 << 8)) | 19U) | ((sizeof(struct __anonstruct_141 ) + sizeof(int )) << 16)): 
  case (UWord )((((2U << 30) | (unsigned int )(81 << 8)) | 11U) | ((sizeof(struct __anonstruct_140 ) + sizeof(int )) << 16)): 
  case (UWord )((((2U << 30) | (unsigned int )(81 << 8)) | 10U) | ((sizeof(struct __anonstruct_139 ) + sizeof(int )) << 16)): 
  case (UWord )((((1U << 30) | (unsigned int )(81 << 8)) | 9U) | ((sizeof(struct __anonstruct_138 ) + sizeof(int )) << 16)): 
  case (UWord )((((1U << 30) | (unsigned int )(81 << 8)) | 8U) | ((sizeof(struct __anonstruct_137 ) + sizeof(int )) << 16)): 
  case (UWord )((((1U << 30) | (unsigned int )(81 << 8)) | 6U) | ((sizeof(struct __anonstruct_136 ) + sizeof(int )) << 16)): 
  case (UWord )((((2U << 30) | (unsigned int )(81 << 8)) | 5U) | ((sizeof(struct __anonstruct_135 ) + sizeof(int )) << 16)): 
  case (UWord )((((2U << 30) | (unsigned int )(81 << 8)) | 4U) | ((sizeof(struct __anonstruct_134 ) + sizeof(int )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(SNDCTL_XXX|SOUND_XXX (SIOR, int))",
                                             arrghs->arg3, (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((((3U << 30) | (unsigned int )(109 << 8)) | 1U) | ((sizeof(struct __anonstruct_166 ) + sizeof(int )) << 16)): 
  case (UWord )(((3U << 30) | (unsigned int )(109 << 8)) | ((sizeof(struct __anonstruct_165 ) + sizeof(int )) << 16)): 
  case (UWord )((((3U << 30) | (unsigned int )(84 << 8)) | 6U) | ((sizeof(struct __anonstruct_164 ) + sizeof(int )) << 16)): 
  case (UWord )((((3U << 30) | (unsigned int )(84 << 8)) | 5U) | ((sizeof(struct __anonstruct_163 ) + sizeof(int )) << 16)): 
  case (UWord )((((3U << 30) | (unsigned int )(84 << 8)) | 1U) | ((sizeof(struct __anonstruct_162 ) + sizeof(int )) << 16)): 
  case (UWord )((((3U << 30) | (unsigned int )(80 << 8)) | 65U) | ((sizeof(struct __anonstruct_161 ) + sizeof(int )) << 16)): 
  case (UWord )((((3U << 30) | (unsigned int )(80 << 8)) | 64U) | ((sizeof(struct __anonstruct_160 ) + sizeof(int )) << 16)): 
  case (UWord )((((3U << 30) | (unsigned int )(80 << 8)) | 5U) | ((sizeof(struct __anonstruct_159 ) + sizeof(int )) << 16)): 
  case (UWord )((((3U << 30) | (unsigned int )(80 << 8)) | 10U) | ((sizeof(struct __anonstruct_158 ) + sizeof(int )) << 16)): 
  case (UWord )((((3U << 30) | (unsigned int )(80 << 8)) | 9U) | ((sizeof(struct __anonstruct_157 ) + sizeof(int )) << 16)): 
  case (UWord )((((3U << 30) | (unsigned int )(80 << 8)) | 7U) | ((sizeof(struct __anonstruct_156 ) + sizeof(int )) << 16)): 
  case (UWord )((((3U << 30) | (unsigned int )(80 << 8)) | 6U) | ((sizeof(struct __anonstruct_155 ) + sizeof(int )) << 16)): 
  case (UWord )((((3U << 30) | (unsigned int )(80 << 8)) | 3U) | ((sizeof(struct __anonstruct_154 ) + sizeof(int )) << 16)): 
  case (UWord )((((3U << 30) | (unsigned int )(80 << 8)) | 2U) | ((sizeof(struct __anonstruct_153 ) + sizeof(int )) << 16)): 
  case (UWord )((((3U << 30) | (unsigned int )(81 << 8)) | 3U) | ((sizeof(struct __anonstruct_152 ) + sizeof(int )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(SNDCTL_XXX|SOUND_XXX (SIOWR, int))",
                                            arrghs->arg3, (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(SNDCTL_XXX|SOUND_XXX (SIOWR, int))",
                                             arrghs->arg3, (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((((2U << 30) | (unsigned int )(80 << 8)) | 13U) | ((sizeof(struct __anonstruct_168 ) + sizeof(vki_audio_buf_info )) << 16)): 
  case (UWord )((((2U << 30) | (unsigned int )(80 << 8)) | 12U) | ((sizeof(struct __anonstruct_167 ) + sizeof(vki_audio_buf_info )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(SNDCTL_XXX|SOUND_XXX (SIOR, audio_buf_info))",
                                             arrghs->arg3,
                                             (SizeT )sizeof(vki_audio_buf_info ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((unsigned int )(80 << 8) | 14U): 
  break;
  case (UWord )((((1U << 30) | (unsigned int )(80 << 8)) | 16U) | ((sizeof(struct __anonstruct_169 ) + sizeof(int )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(SNDCTL_XXX|SOUND_XXX (SIOW, int))",
                                            arrghs->arg3, (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((unsigned int )(80 << 8) | 22U): 
  case (UWord )((unsigned int )(80 << 8) | 21U): 
  case (UWord )((unsigned int )(80 << 8) | 1U): 
  case (UWord )((unsigned int )(80 << 8)): 
  case (UWord )((unsigned int )(80 << 8) | 8U): 
  break;
  case 1074020704UL: 
  case 1074020677UL: 
  break;
  case (UWord )((((1U << 30) | (unsigned int )(112 << 8)) | 12U) | ((sizeof(struct __anonstruct_170 ) + sizeof(unsigned long )) << 16)): 
  case (UWord )((unsigned int )(112 << 8) | 6U): 
  case (UWord )((unsigned int )(112 << 8) | 5U): 
  case (UWord )((unsigned int )(112 << 8) | 2U): 
  case (UWord )((unsigned int )(112 << 8) | 1U): 
  case (UWord )((unsigned int )(112 << 8) | 4U): 
  case (UWord )((unsigned int )(112 << 8) | 3U): 
  break;
  case (UWord )((((2U << 30) | (unsigned int )(112 << 8)) | 8U) | ((sizeof(struct __anonstruct_172 ) + sizeof(struct vki_rtc_time )) << 16)): 
  case (UWord )((((2U << 30) | (unsigned int )(112 << 8)) | 9U) | ((sizeof(struct __anonstruct_171 ) + sizeof(struct vki_rtc_time )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(RTC_RD_TIME/ALM_READ)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(struct vki_rtc_time ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((((1U << 30) | (unsigned int )(112 << 8)) | 7U) | ((sizeof(struct __anonstruct_173 ) + sizeof(struct vki_rtc_time )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(RTC_ALM_SET)",
                                            arrghs->arg3,
                                            (SizeT )sizeof(struct vki_rtc_time ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((((2U << 30) | (unsigned int )(112 << 8)) | 11U) | ((sizeof(struct __anonstruct_174 ) + sizeof(unsigned long )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(RTC_IRQP_READ)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(unsigned long ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((unsigned int )(18 << 8) | 93U): 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(BLKROSET)",
                                            arrghs->arg3, (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((unsigned int )(18 << 8) | 94U): 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(BLKROGET)",
                                             arrghs->arg3, (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((unsigned int )(18 << 8) | 96U): 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(BLKGETSIZE)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(unsigned long ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((unsigned int )(18 << 8) | 98U): 
  break;
  case (UWord )((unsigned int )(18 << 8) | 99U): 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(BLKRAGET)",
                                             arrghs->arg3, (SizeT )sizeof(long ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((unsigned int )(18 << 8) | 100U): 
  break;
  case (UWord )((unsigned int )(18 << 8) | 101U): 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(BLKFRAGET)",
                                             arrghs->arg3, (SizeT )sizeof(long ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((unsigned int )(18 << 8) | 103U): 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(BLKSECTGET)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(unsigned short ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((unsigned int )(18 << 8) | 104U): 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(BLKSSZGET)",
                                             arrghs->arg3, (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((((2U << 30) | (unsigned int )(18 << 8)) | 112U) | ((sizeof(struct __anonstruct_175 ) + sizeof(vki_size_t )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(BLKBSZGET)",
                                             arrghs->arg3, (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((((1U << 30) | (unsigned int )(18 << 8)) | 113U) | ((sizeof(struct __anonstruct_176 ) + sizeof(vki_size_t )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(BLKBSZSET)",
                                            arrghs->arg3, (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((((2U << 30) | (unsigned int )(18 << 8)) | 114U) | ((sizeof(struct __anonstruct_177 ) + sizeof(vki_size_t )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(BLKGETSIZE64)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(unsigned long long ));
    } else {

    }
    break;
  }
  break;
  case 769UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(HDIO_GETGEO)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(struct vki_hd_geometry ));
    } else {

    }
    break;
  }
  break;
  case 779UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(HDIO_GET_DMA)",
                                             arrghs->arg3, (SizeT )sizeof(long ));
    } else {

    }
    break;
  }
  break;
  case 781UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(HDIO_GET_IDENTITY)",
                                             arrghs->arg3, (SizeT )512);
    } else {

    }
    break;
  }
  break;
  case 21378UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(SCSI_IOCTL_GET_IDLUN)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(struct vki_scsi_idlun ));
    } else {

    }
    break;
  }
  break;
  case 21382UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(SCSI_IOCTL_GET_BUS_NUMBER)",
                                             arrghs->arg3, (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case 21265UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(CDROM_GET_MCN)",
                                            arrghs->arg3,
                                            (SizeT )sizeof(struct vki_cdrom_mcn ));
    } else {

    }
    break;
  }
  break;
  case 21395UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(CDROM_SEND_PACKET)",
                                            arrghs->arg3,
                                            (SizeT )sizeof(struct vki_cdrom_generic_command ));
    } else {

    }
    break;
  }
  break;
  case 21259UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(CDROMSUBCHNL (cdsc_format, char))",
                                            (Addr )(& ((struct vki_cdrom_subchnl *)arrghs->arg3)->cdsc_format),
                                            (SizeT )sizeof(((struct vki_cdrom_subchnl *)arrghs->arg3)->cdsc_format));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(CDROMSUBCHNL)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(struct vki_cdrom_subchnl ));
    } else {

    }
    break;
  }
  break;
  case 21260UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(CDROMREADMODE2)",
                                            arrghs->arg3, (SizeT )2336);
    } else {

    }
    break;
  }
  break;
  case 21253UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(CDROMREADTOCHDR)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(struct vki_cdrom_tochdr ));
    } else {

    }
    break;
  }
  break;
  case 21254UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(CDROMREADTOCENTRY (cdte_format, char))",
                                            (Addr )(& ((struct vki_cdrom_tocentry *)arrghs->arg3)->cdte_format),
                                            (SizeT )sizeof(((struct vki_cdrom_tocentry *)arrghs->arg3)->cdte_format));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(CDROMREADTOCENTRY (cdte_track, char))",
                                            (Addr )(& ((struct vki_cdrom_tocentry *)arrghs->arg3)->cdte_track),
                                            (SizeT )sizeof(((struct vki_cdrom_tocentry *)arrghs->arg3)->cdte_track));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(CDROMREADTOCENTRY)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(struct vki_cdrom_tocentry ));
    } else {

    }
    break;
  }
  break;
  case 21264UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(CDROMMULTISESSION)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(struct vki_cdrom_multisession ));
    } else {

    }
    break;
  }
  break;
  case 21267UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(CDROMVOLREAD)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(struct vki_cdrom_volctrl ));
    } else {

    }
    break;
  }
  break;
  case 21268UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(CDROMREADRAW)",
                                            arrghs->arg3,
                                            (SizeT )sizeof(struct vki_cdrom_msf ));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(CDROMREADRAW)",
                                             arrghs->arg3, (SizeT )2352);
    } else {

    }
    break;
  }
  break;
  case 21262UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(CDROMREADAUDIO)",
                                            arrghs->arg3,
                                            (SizeT )sizeof(struct vki_cdrom_read_audio ));
    } else {

    }
    break;
  }
  if (arrghs->arg3) {
    cra = (struct vki_cdrom_read_audio *)arrghs->arg3;
    while (1) {
      if (vgPlain_tdict.track_pre_mem_write) {
        (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                               (Char *)"ioctl(CDROMREADAUDIO).buf",
                                               (Addr )cra->buf,
                                               (SizeT )(cra->nframes * 2352));
      } else {

      }
      break;
    }
  } else {

  }
  break;
  case 21251UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(CDROMPLAYMSF)",
                                            arrghs->arg3,
                                            (SizeT )sizeof(struct vki_cdrom_msf ));
    } else {

    }
    break;
  }
  break;
  case 21281UL: 
  case 21286UL: 
  break;
  case 2UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(FIGETBSZ)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(unsigned long ));
    } else {

    }
    break;
  }
  break;
  case 1UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(FIBMAP)",
                                            arrghs->arg3, (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case 17920UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(FBIOGET_VSCREENINFO)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(struct vki_fb_var_screeninfo ));
    } else {

    }
    break;
  }
  break;
  case 17921UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(FBIOPUT_VSCREENINFO)",
                                            arrghs->arg3,
                                            (SizeT )sizeof(struct vki_fb_var_screeninfo ));
    } else {

    }
    break;
  }
  break;
  case 17922UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(FBIOGET_FSCREENINFO)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(struct vki_fb_fix_screeninfo ));
    } else {

    }
    break;
  }
  break;
  case 17926UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(FBIOPAN_DISPLAY)",
                                            arrghs->arg3,
                                            (SizeT )sizeof(struct vki_fb_var_screeninfo ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((unsigned int )(112 << 8) | 140U): 
  case (UWord )((unsigned int )(112 << 8) | 141U): 
  case (UWord )((unsigned int )(112 << 8) | 143U): 
  case (UWord )((unsigned int )(112 << 8) | 139U): 
  break;
  case (UWord )((((1U << 30) | (unsigned int )(112 << 8)) | 128U) | ((sizeof(struct __anonstruct_178 ) + sizeof(int )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(PPSETMODE)",
                                            arrghs->arg3, (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((((2U << 30) | (unsigned int )(112 << 8)) | 152U) | ((sizeof(struct __anonstruct_179 ) + sizeof(int )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(PPGETMODE)",
                                             arrghs->arg3, (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((((1U << 30) | (unsigned int )(112 << 8)) | 148U) | ((sizeof(struct __anonstruct_180 ) + sizeof(int )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(PPSETPHASE)",
                                            arrghs->arg3, (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((((2U << 30) | (unsigned int )(112 << 8)) | 153U) | ((sizeof(struct __anonstruct_181 ) + sizeof(int )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(PPGETPHASE)",
                                             arrghs->arg3, (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((((2U << 30) | (unsigned int )(112 << 8)) | 151U) | ((sizeof(struct __anonstruct_182 ) + sizeof(unsigned int )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(PPGETMODES)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(unsigned int ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((((1U << 30) | (unsigned int )(112 << 8)) | 155U) | ((sizeof(struct __anonstruct_183 ) + sizeof(int )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(PPSETFLAGS)",
                                            arrghs->arg3, (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((((2U << 30) | (unsigned int )(112 << 8)) | 154U) | ((sizeof(struct __anonstruct_184 ) + sizeof(int )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(PPGETFLAGS)",
                                             arrghs->arg3, (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((((2U << 30) | (unsigned int )(112 << 8)) | 129U) | ((sizeof(struct __anonstruct_185 ) + sizeof(unsigned char )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(PPRSTATUS)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(unsigned char ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((((2U << 30) | (unsigned int )(112 << 8)) | 133U) | ((sizeof(struct __anonstruct_186 ) + sizeof(unsigned char )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(PPRDATA)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(unsigned char ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((((2U << 30) | (unsigned int )(112 << 8)) | 131U) | ((sizeof(struct __anonstruct_187 ) + sizeof(unsigned char )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(PPRCONTROL)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(unsigned char ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((((1U << 30) | (unsigned int )(112 << 8)) | 134U) | ((sizeof(struct __anonstruct_188 ) + sizeof(unsigned char )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(PPWDATA)",
                                            arrghs->arg3,
                                            (SizeT )sizeof(unsigned char ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((((1U << 30) | (unsigned int )(112 << 8)) | 132U) | ((sizeof(struct __anonstruct_189 ) + sizeof(unsigned char )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(PPWCONTROL)",
                                            arrghs->arg3,
                                            (SizeT )sizeof(unsigned char ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((((1U << 30) | (unsigned int )(112 << 8)) | 142U) | ((sizeof(struct __anonstruct_190 ) + sizeof(struct vki_ppdev_frob_struct )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(PPFCONTROL)",
                                            arrghs->arg3,
                                            (SizeT )(2U * sizeof(unsigned char )));
    } else {

    }
    break;
  }
  break;
  case (UWord )((((1U << 30) | (unsigned int )(112 << 8)) | 144U) | ((sizeof(struct __anonstruct_191 ) + sizeof(int )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(PPDATADIR)",
                                            arrghs->arg3, (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((((1U << 30) | (unsigned int )(112 << 8)) | 145U) | ((sizeof(struct __anonstruct_192 ) + sizeof(int )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(PPNEGOT)",
                                            arrghs->arg3, (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((((1U << 30) | (unsigned int )(112 << 8)) | 146U) | ((sizeof(struct __anonstruct_193 ) + sizeof(unsigned char )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(PPWCTLONIRQ)",
                                            arrghs->arg3,
                                            (SizeT )sizeof(unsigned char ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((((2U << 30) | (unsigned int )(112 << 8)) | 147U) | ((sizeof(struct __anonstruct_194 ) + sizeof(int )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(PPCLRIRQ)",
                                             arrghs->arg3, (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((((1U << 30) | (unsigned int )(112 << 8)) | 150U) | ((sizeof(struct __anonstruct_195 ) + sizeof(struct vki_timeval )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(PPSETTIME)",
                                            arrghs->arg3,
                                            (SizeT )sizeof(struct vki_timeval ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((((2U << 30) | (unsigned int )(112 << 8)) | 149U) | ((sizeof(struct __anonstruct_196 ) + sizeof(struct vki_timeval )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(PPGETTIME)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(struct vki_timeval ));
    } else {

    }
    break;
  }
  break;
  case 19296UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(GIO_FONT)",
                                             arrghs->arg3, (SizeT )8192);
    } else {

    }
    break;
  }
  break;
  case 19297UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(PIO_FONT)",
                                            arrghs->arg3, (SizeT )8192);
    } else {

    }
    break;
  }
  break;
  case 19307UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(GIO_FONTX)",
                                            arrghs->arg3,
                                            (SizeT )sizeof(struct vki_consolefontdesc ));
    } else {

    }
    break;
  }
  if (arrghs->arg3) {
    cfd = (struct vki_consolefontdesc *)arrghs->arg3;
    while (1) {
      if (vgPlain_tdict.track_pre_mem_write) {
        (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                               (Char *)"ioctl(GIO_FONTX).chardata",
                                               (Addr )cfd->chardata,
                                               (SizeT )(32 * (int )cfd->charcount));
      } else {

      }
      break;
    }
  } else {

  }
  break;
  case 19308UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(PIO_FONTX)",
                                            arrghs->arg3,
                                            (SizeT )sizeof(struct vki_consolefontdesc ));
    } else {

    }
    break;
  }
  if (arrghs->arg3) {
    cfd___0 = (struct vki_consolefontdesc *)arrghs->arg3;
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"ioctl(PIO_FONTX).chardata",
                                              (Addr )cfd___0->chardata,
                                              (SizeT )(32 * (int )cfd___0->charcount));
      } else {

      }
      break;
    }
  } else {

  }
  break;
  case 19309UL: 
  break;
  case 19312UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(GIO_CMAP)",
                                             arrghs->arg3, (SizeT )48);
    } else {

    }
    break;
  }
  break;
  case 19313UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(PIO_CMAP)",
                                            arrghs->arg3, (SizeT )48);
    } else {

    }
    break;
  }
  break;
  case 19248UL: 
  case 19247UL: 
  break;
  case 19249UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(KDGETLED)",
                                             arrghs->arg3, (SizeT )sizeof(char ));
    } else {

    }
    break;
  }
  break;
  case 19250UL: 
  break;
  case 19251UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(KDGKBTYPE)",
                                             arrghs->arg3, (SizeT )sizeof(char ));
    } else {

    }
    break;
  }
  break;
  case 19255UL: 
  case 19254UL: 
  case 19253UL: 
  case 19252UL: 
  break;
  case 19258UL: 
  break;
  case 19259UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(KDGETMODE)",
                                             arrghs->arg3, (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case 19261UL: 
  case 19260UL: 
  break;
  case 19264UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(GIO_SCRNMAP)",
                                             arrghs->arg3, (SizeT )256);
    } else {

    }
    break;
  }
  break;
  case 19265UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(PIO_SCRNMAP)",
                                            arrghs->arg3, (SizeT )256);
    } else {

    }
    break;
  }
  break;
  case 19305UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(GIO_UNISCRNMAP)",
                                             arrghs->arg3,
                                             (SizeT )(256U * sizeof(unsigned short )));
    } else {

    }
    break;
  }
  break;
  case 19306UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(PIO_UNISCRNMAP)",
                                            arrghs->arg3,
                                            (SizeT )(256U * sizeof(unsigned short )));
    } else {

    }
    break;
  }
  break;
  case 19302UL: 
  if (arrghs->arg3) {
    desc = (struct vki_unimapdesc *)arrghs->arg3;
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"ioctl(GIO_UNIMAP)",
                                              (Addr )(& desc->entry_ct),
                                              (SizeT )sizeof(unsigned short ));
      } else {

      }
      break;
    }
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"ioctl(GIO_UNIMAP)",
                                              (Addr )(& desc->entries),
                                              (SizeT )sizeof(struct vki_unipair *));
      } else {

      }
      break;
    }
    while (1) {
      if (vgPlain_tdict.track_pre_mem_write) {
        (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                               (Char *)"ioctl(GIO_UNIMAP).entries",
                                               (Addr )desc->entries,
                                               (SizeT )((unsigned int )desc->entry_ct * sizeof(struct vki_unipair )));
      } else {

      }
      break;
    }
  } else {

  }
  break;
  case 19303UL: 
  if (arrghs->arg3) {
    desc___0 = (struct vki_unimapdesc *)arrghs->arg3;
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"ioctl(GIO_UNIMAP)",
                                              (Addr )(& desc___0->entry_ct),
                                              (SizeT )sizeof(unsigned short ));
      } else {

      }
      break;
    }
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"ioctl(GIO_UNIMAP)",
                                              (Addr )(& desc___0->entries),
                                              (SizeT )sizeof(struct vki_unipair *));
      } else {

      }
      break;
    }
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"ioctl(PIO_UNIMAP).entries",
                                              (Addr )desc___0->entries,
                                              (SizeT )((unsigned int )desc___0->entry_ct * sizeof(struct vki_unipair )));
      } else {

      }
      break;
    }
  } else {

  }
  break;
  case 19304UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(GIO_UNIMAP)",
                                            arrghs->arg3,
                                            (SizeT )sizeof(struct vki_unimapinit ));
    } else {

    }
    break;
  }
  break;
  case 19268UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(KDGKBMODE)",
                                             arrghs->arg3, (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case 19269UL: 
  break;
  case 19298UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(KDGKBMETA)",
                                             arrghs->arg3, (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case 19299UL: 
  break;
  case 19300UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(KDGKBLED)",
                                             arrghs->arg3, (SizeT )sizeof(char ));
    } else {

    }
    break;
  }
  break;
  case 19301UL: 
  break;
  case 19270UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(KDGKBENT).kb_table",
                                            (Addr )(& ((struct vki_kbentry *)arrghs->arg3)->kb_table),
                                            (SizeT )sizeof(((struct vki_kbentry *)arrghs->arg3)->kb_table));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(KDGKBENT).kb_index",
                                            (Addr )(& ((struct vki_kbentry *)arrghs->arg3)->kb_index),
                                            (SizeT )sizeof(((struct vki_kbentry *)arrghs->arg3)->kb_index));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(KDGKBENT).kb_value",
                                             (Addr )(& ((struct vki_kbentry *)arrghs->arg3)->kb_value),
                                             (SizeT )sizeof(((struct vki_kbentry *)arrghs->arg3)->kb_value));
    } else {

    }
    break;
  }
  break;
  case 19271UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(KDSKBENT).kb_table",
                                            (Addr )(& ((struct vki_kbentry *)arrghs->arg3)->kb_table),
                                            (SizeT )sizeof(((struct vki_kbentry *)arrghs->arg3)->kb_table));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(KDSKBENT).kb_index",
                                            (Addr )(& ((struct vki_kbentry *)arrghs->arg3)->kb_index),
                                            (SizeT )sizeof(((struct vki_kbentry *)arrghs->arg3)->kb_index));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(KDSKBENT).kb_value",
                                            (Addr )(& ((struct vki_kbentry *)arrghs->arg3)->kb_value),
                                            (SizeT )sizeof(((struct vki_kbentry *)arrghs->arg3)->kb_value));
    } else {

    }
    break;
  }
  break;
  case 19272UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(KDGKBSENT).kb_func",
                                            (Addr )(& ((struct vki_kbsentry *)arrghs->arg3)->kb_func),
                                            (SizeT )sizeof(((struct vki_kbsentry *)arrghs->arg3)->kb_func));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(KDGKSENT).kb_string",
                                             (Addr )(((struct vki_kbsentry *)arrghs->arg3)->kb_string),
                                             (SizeT )sizeof(((struct vki_kbsentry *)arrghs->arg3)->kb_string));
    } else {

    }
    break;
  }
  break;
  case 19273UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(KDSKBSENT).kb_func",
                                            (Addr )(& ((struct vki_kbsentry *)arrghs->arg3)->kb_func),
                                            (SizeT )sizeof(((struct vki_kbsentry *)arrghs->arg3)->kb_func));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read_asciiz) {
      (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                   (Char *)"ioctl(KDSKBSENT).kb_string",
                                                   (Addr )(((struct vki_kbsentry *)arrghs->arg3)->kb_string));
    } else {

    }
    break;
  }
  break;
  case 19274UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(KDGKBDIACR)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(struct vki_kbdiacrs ));
    } else {

    }
    break;
  }
  break;
  case 19275UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(KDSKBDIACR)",
                                            arrghs->arg3,
                                            (SizeT )sizeof(struct vki_kbdiacrs ));
    } else {

    }
    break;
  }
  break;
  case 19276UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(KDGETKEYCODE).scancode",
                                            (Addr )(& ((struct vki_kbkeycode *)arrghs->arg3)->scancode),
                                            (SizeT )sizeof(((struct vki_kbkeycode *)arrghs->arg3)->scancode));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(KDGETKEYCODE).keycode",
                                             (Addr )((struct vki_kbkeycode *)arrghs->arg3)->keycode,
                                             (SizeT )sizeof(((struct vki_kbkeycode *)arrghs->arg3)->keycode));
    } else {

    }
    break;
  }
  break;
  case 19277UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(KDSETKEYCODE).scancode",
                                            (Addr )(& ((struct vki_kbkeycode *)arrghs->arg3)->scancode),
                                            (SizeT )sizeof(((struct vki_kbkeycode *)arrghs->arg3)->scancode));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(KDSETKEYCODE).keycode",
                                            (Addr )((struct vki_kbkeycode *)arrghs->arg3)->keycode,
                                            (SizeT )sizeof(((struct vki_kbkeycode *)arrghs->arg3)->keycode));
    } else {

    }
    break;
  }
  break;
  case 19278UL: 
  break;
  case 19282UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(KBKBDREP)",
                                            arrghs->arg3,
                                            (SizeT )sizeof(struct vki_kbd_repeat ));
    } else {

    }
    break;
  }
  break;
  case 19314UL: 
  if (arrghs->arg3) {
    op = (struct vki_console_font_op *)arrghs->arg3;
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"ioctl(KDFONTOP)",
                                              (Addr )op,
                                              (SizeT )sizeof(struct vki_console_font_op ));
      } else {

      }
      break;
    }
    switch (op->op) {
    case 0U: 
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"ioctl(KDFONTOP,KD_FONT_OP_SET).data",
                                              (Addr )op->data,
                                              (SizeT )((((op->width + 7U) / 8U) * 32U) * op->charcount));
      } else {

      }
      break;
    }
    break;
    case 1U: 
    if (op->data) {
      while (1) {
        if (vgPlain_tdict.track_pre_mem_write) {
          (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                                 (Char *)"ioctl(KDFONTOP,KD_FONT_OP_GET).data",
                                                 (Addr )op->data,
                                                 (SizeT )((((op->width + 7U) / 8U) * 32U) * op->charcount));
        } else {

        }
        break;
      }
    } else {

    }
    break;
    case 2U: 
    if (op->data) {
      while (1) {
        if (vgPlain_tdict.track_pre_mem_read_asciiz) {
          (*(vgPlain_tdict.track_pre_mem_read_asciiz))((CorePart )3, tid,
                                                       (Char *)"ioctl(KDFONTOP,KD_FONT_OP_SET_DEFAULT).data",
                                                       (Addr )op->data);
        } else {

        }
        break;
      }
    } else {

    }
    break;
    case 3U: 
    break;
    }
  } else {

  }
  break;
  case 22016UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(VT_OPENQRY)",
                                             arrghs->arg3, (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case 22017UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(VT_GETMODE)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(struct vki_vt_mode ));
    } else {

    }
    break;
  }
  break;
  case 22018UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(VT_SETMODE)",
                                            arrghs->arg3,
                                            (SizeT )sizeof(struct vki_vt_mode ));
    } else {

    }
    break;
  }
  break;
  case 22019UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(VT_GETSTATE).v_active",
                                             (Addr )(& ((struct vki_vt_stat *)arrghs->arg3)->v_active),
                                             (SizeT )sizeof(((struct vki_vt_stat *)arrghs->arg3)->v_active));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(VT_GETSTATE).v_state",
                                             (Addr )(& ((struct vki_vt_stat *)arrghs->arg3)->v_state),
                                             (SizeT )sizeof(((struct vki_vt_stat *)arrghs->arg3)->v_state));
    } else {

    }
    break;
  }
  break;
  case 22024UL: 
  case 22023UL: 
  case 22022UL: 
  case 22021UL: 
  break;
  case 22025UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(VT_RESIZE)",
                                            arrghs->arg3,
                                            (SizeT )sizeof(struct vki_vt_sizes ));
    } else {

    }
    break;
  }
  break;
  case 22026UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_read) {
      (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                            (Char *)"ioctl(VT_RESIZEX)",
                                            arrghs->arg3,
                                            (SizeT )sizeof(struct vki_vt_consize ));
    } else {

    }
    break;
  }
  break;
  case 22028UL: 
  case 22027UL: 
  break;
  case (UWord )(((3U << 30) | (unsigned int )(85 << 8)) | ((sizeof(struct __anonstruct_197 ) + sizeof(struct vki_usbdevfs_ctrltransfer )) << 16)): 
  if (arrghs->arg3) {
    vkuc = (struct vki_usbdevfs_ctrltransfer *)arrghs->arg3;
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"ioctl(USBDEVFS_CONTROL).bRequestType",
                                              (Addr )(& vkuc->bRequestType),
                                              (SizeT )sizeof(vkuc->bRequestType));
      } else {

      }
      break;
    }
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"ioctl(USBDEVFS_CONTROL).bRequest",
                                              (Addr )(& vkuc->bRequest),
                                              (SizeT )sizeof(vkuc->bRequest));
      } else {

      }
      break;
    }
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"ioctl(USBDEVFS_CONTROL).wValue",
                                              (Addr )(& vkuc->wValue),
                                              (SizeT )sizeof(vkuc->wValue));
      } else {

      }
      break;
    }
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"ioctl(USBDEVFS_CONTROL).wIndex",
                                              (Addr )(& vkuc->wIndex),
                                              (SizeT )sizeof(vkuc->wIndex));
      } else {

      }
      break;
    }
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"ioctl(USBDEVFS_CONTROL).wLength",
                                              (Addr )(& vkuc->wLength),
                                              (SizeT )sizeof(vkuc->wLength));
      } else {

      }
      break;
    }
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"ioctl(USBDEVFS_CONTROL).timeout",
                                              (Addr )(& vkuc->timeout),
                                              (SizeT )sizeof(vkuc->timeout));
      } else {

      }
      break;
    }
    if ((int )vkuc->bRequestType & 128) {
      while (1) {
        if (vgPlain_tdict.track_pre_mem_write) {
          (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                                 (Char *)"ioctl(USBDEVFS_CONTROL).data",
                                                 (Addr )vkuc->data,
                                                 (SizeT )vkuc->wLength);
        } else {

        }
        break;
      }
    } else {
      while (1) {
        if (vgPlain_tdict.track_pre_mem_read) {
          (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                                (Char *)"ioctl(USBDEVFS_CONTROL).data",
                                                (Addr )vkuc->data,
                                                (SizeT )vkuc->wLength);
        } else {

        }
        break;
      }
    }
  } else {

  }
  break;
  case (UWord )((((3U << 30) | (unsigned int )(85 << 8)) | 2U) | ((sizeof(struct __anonstruct_198 ) + sizeof(struct vki_usbdevfs_bulktransfer )) << 16)): 
  if (arrghs->arg3) {
    vkub = (struct vki_usbdevfs_bulktransfer *)arrghs->arg3;
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"ioctl(USBDEVFS_BULK)",
                                              arrghs->arg3,
                                              (SizeT )sizeof(struct vki_usbdevfs_bulktransfer ));
      } else {

      }
      break;
    }
    if (vkub->ep & 128U) {
      while (1) {
        if (vgPlain_tdict.track_pre_mem_write) {
          (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                                 (Char *)"ioctl(USBDEVFS_BULK).data",
                                                 (Addr )vkub->data,
                                                 (SizeT )vkub->len);
        } else {

        }
        break;
      }
    } else {
      while (1) {
        if (vgPlain_tdict.track_pre_mem_read) {
          (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                                (Char *)"ioctl(USBDEVFS_BULK).data",
                                                (Addr )vkub->data,
                                                (SizeT )vkub->len);
        } else {

        }
        break;
      }
    }
  } else {

  }
  break;
  case (UWord )((((1U << 30) | (unsigned int )(85 << 8)) | 8U) | ((sizeof(struct __anonstruct_199 ) + sizeof(struct vki_usbdevfs_getdriver )) << 16)): 
  if (arrghs->arg3) {
    vkugd = (struct vki_usbdevfs_getdriver *)arrghs->arg3;
    while (1) {
      if (vgPlain_tdict.track_pre_mem_write) {
        (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                               (Char *)"ioctl(USBDEVFS_GETDRIVER)",
                                               (Addr )(& vkugd->driver),
                                               (SizeT )sizeof(vkugd->driver));
      } else {

      }
      break;
    }
  } else {

  }
  break;
  case (UWord )((((2U << 30) | (unsigned int )(85 << 8)) | 10U) | ((sizeof(struct __anonstruct_200 ) + sizeof(struct vki_usbdevfs_urb )) << 16)): 
  if (arrghs->arg3) {
    vkuu = (struct vki_usbdevfs_urb *)arrghs->arg3;
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"ioctl(USBDEVFS_SUBMITURB).endpoint",
                                              (Addr )(& vkuu->endpoint),
                                              (SizeT )sizeof(vkuu->endpoint));
      } else {

      }
      break;
    }
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"ioctl(USBDEVFS_SUBMITURB).type",
                                              (Addr )(& vkuu->type),
                                              (SizeT )sizeof(vkuu->type));
      } else {

      }
      break;
    }
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"ioctl(USBDEVFS_SUBMITURB).flags",
                                              (Addr )(& vkuu->flags),
                                              (SizeT )sizeof(vkuu->flags));
      } else {

      }
      break;
    }
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"ioctl(USBDEVFS_SUBMITURB).buffer",
                                              (Addr )(& vkuu->buffer),
                                              (SizeT )sizeof(vkuu->buffer));
      } else {

      }
      break;
    }
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"ioctl(USBDEVFS_SUBMITURB).signr",
                                              (Addr )(& vkuu->signr),
                                              (SizeT )sizeof(vkuu->signr));
      } else {

      }
      break;
    }
    while (1) {
      if (vgPlain_tdict.track_pre_mem_write) {
        (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                               (Char *)"ioctl(USBDEVFS_SUBMITURB).status",
                                               (Addr )(& vkuu->status),
                                               (SizeT )sizeof(vkuu->status));
      } else {

      }
      break;
    }
    if ((int )vkuu->type == 2) {
      vkusp = (struct vki_usbdevfs_setuppacket *)vkuu->buffer;
      while (1) {
        if (vgPlain_tdict.track_pre_mem_read) {
          (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                                (Char *)"ioctl(USBDEVFS_SUBMITURB).buffer_length",
                                                (Addr )(& vkuu->buffer_length),
                                                (SizeT )sizeof(vkuu->buffer_length));
        } else {

        }
        break;
      }
      while (1) {
        if (vgPlain_tdict.track_pre_mem_read) {
          (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                                (Char *)"ioctl(USBDEVFS_SUBMITURB).buffer.setup_packet",
                                                (Addr )vkusp,
                                                (SizeT )sizeof(*vkusp));
        } else {

        }
        break;
      }
      if ((int )vkusp->bRequestType & 128) {
        while (1) {
          if (vgPlain_tdict.track_pre_mem_write) {
            (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                                   (Char *)"ioctl(USBDEVFS_SUBMITURB).buffer.data",
                                                   (Addr )(vkusp + 1),
                                                   (SizeT )((unsigned int )vkuu->buffer_length - sizeof(*vkusp)));
          } else {

          }
          break;
        }
      } else {
        while (1) {
          if (vgPlain_tdict.track_pre_mem_read) {
            (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                                  (Char *)"ioctl(USBDEVFS_SUBMITURB).buffer.data",
                                                  (Addr )(vkusp + 1),
                                                  (SizeT )((unsigned int )vkuu->buffer_length - sizeof(*vkusp)));
          } else {

          }
          break;
        }
      }
      while (1) {
        if (vgPlain_tdict.track_pre_mem_write) {
          (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                                 (Char *)"ioctl(USBDEVFS_SUBMITURB).actual_length",
                                                 (Addr )(& vkuu->actual_length),
                                                 (SizeT )sizeof(vkuu->actual_length));
        } else {

        }
        break;
      }
    } else
    if ((int )vkuu->type == 0) {
      total_length = 0;
      while (1) {
        if (vgPlain_tdict.track_pre_mem_read) {
          (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                                (Char *)"ioctl(USBDEVFS_SUBMITURB).number_of_packets",
                                                (Addr )(& vkuu->number_of_packets),
                                                (SizeT )sizeof(vkuu->number_of_packets));
        } else {

        }
        break;
      }
      i = 0;
      while (i < vkuu->number_of_packets) {
        while (1) {
          if (vgPlain_tdict.track_pre_mem_read) {
            (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                                  (Char *)"ioctl(USBDEVFS_SUBMITURB).iso_frame_desc[].length",
                                                  (Addr )(& vkuu->iso_frame_desc[i].length),
                                                  (SizeT )sizeof(vkuu->iso_frame_desc[i].length));
          } else {

          }
          break;
        }
        while (1) {
          if (vgPlain_tdict.track_pre_mem_write) {
            (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                                   (Char *)"ioctl(USBDEVFS_SUBMITURB).iso_frame_desc[].actual_length",
                                                   (Addr )(& vkuu->iso_frame_desc[i].actual_length),
                                                   (SizeT )sizeof(vkuu->iso_frame_desc[i].actual_length));
          } else {

          }
          break;
        }
        while (1) {
          if (vgPlain_tdict.track_pre_mem_write) {
            (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                                   (Char *)"ioctl(USBDEVFS_SUBMITURB).iso_frame_desc[].status",
                                                   (Addr )(& vkuu->iso_frame_desc[i].status),
                                                   (SizeT )sizeof(vkuu->iso_frame_desc[i].status));
          } else {

          }
          break;
        }
        total_length = (int )((unsigned int )total_length + vkuu->iso_frame_desc[i].length);
        i ++;
      }
      if ((int )vkuu->endpoint & 128) {
        while (1) {
          if (vgPlain_tdict.track_pre_mem_write) {
            (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                                   (Char *)"ioctl(USBDEVFS_SUBMITURB).buffer",
                                                   (Addr )vkuu->buffer,
                                                   (SizeT )total_length);
          } else {

          }
          break;
        }
      } else {
        while (1) {
          if (vgPlain_tdict.track_pre_mem_read) {
            (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                                  (Char *)"ioctl(USBDEVFS_SUBMITURB).buffer",
                                                  (Addr )vkuu->buffer,
                                                  (SizeT )total_length);
          } else {

          }
          break;
        }
      }
      while (1) {
        if (vgPlain_tdict.track_pre_mem_write) {
          (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                                 (Char *)"ioctl(USBDEVFS_SUBMITURB).error_count",
                                                 (Addr )(& vkuu->error_count),
                                                 (SizeT )sizeof(vkuu->error_count));
        } else {

        }
        break;
      }
    } else {
      while (1) {
        if (vgPlain_tdict.track_pre_mem_read) {
          (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                                (Char *)"ioctl(USBDEVFS_SUBMITURB).buffer_length",
                                                (Addr )(& vkuu->buffer_length),
                                                (SizeT )sizeof(vkuu->buffer_length));
        } else {

        }
        break;
      }
      if ((int )vkuu->endpoint & 128) {
        while (1) {
          if (vgPlain_tdict.track_pre_mem_write) {
            (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                                   (Char *)"ioctl(USBDEVFS_SUBMITURB).buffer",
                                                   (Addr )vkuu->buffer,
                                                   (SizeT )vkuu->buffer_length);
          } else {

          }
          break;
        }
      } else {
        while (1) {
          if (vgPlain_tdict.track_pre_mem_read) {
            (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                                  (Char *)"ioctl(USBDEVFS_SUBMITURB).buffer",
                                                  (Addr )vkuu->buffer,
                                                  (SizeT )vkuu->buffer_length);
          } else {

          }
          break;
        }
      }
      while (1) {
        if (vgPlain_tdict.track_pre_mem_write) {
          (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                                 (Char *)"ioctl(USBDEVFS_SUBMITURB).actual_length",
                                                 (Addr )(& vkuu->actual_length),
                                                 (SizeT )sizeof(vkuu->actual_length));
        } else {

        }
        break;
      }
    }
  } else {

  }
  break;
  case (UWord )((unsigned int )(85 << 8) | 11U): 
  break;
  case (UWord )((((1U << 30) | (unsigned int )(85 << 8)) | 12U) | ((sizeof(struct __anonstruct_201 ) + sizeof(void *)) << 16)): 
  if (arrghs->arg3) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_write) {
        (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                               (Char *)"ioctl(USBDEVFS_REAPURB)",
                                               arrghs->arg3,
                                               (SizeT )sizeof(struct vki_usbdevfs_urb **));
      } else {

      }
      break;
    }
  } else {

  }
  break;
  case (UWord )((((1U << 30) | (unsigned int )(85 << 8)) | 13U) | ((sizeof(struct __anonstruct_202 ) + sizeof(void *)) << 16)): 
  if (arrghs->arg3) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_write) {
        (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                               (Char *)"ioctl(USBDEVFS_REAPURBNDELAY)",
                                               arrghs->arg3,
                                               (SizeT )sizeof(struct vki_usbdevfs_urb **));
      } else {

      }
      break;
    }
  } else {

  }
  break;
  case (UWord )((((1U << 30) | (unsigned int )(85 << 8)) | 17U) | ((sizeof(struct __anonstruct_203 ) + sizeof(struct vki_usbdevfs_connectinfo )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(USBDEVFS_CONNECTINFO)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(struct vki_usbdevfs_connectinfo ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((((3U << 30) | (unsigned int )(85 << 8)) | 18U) | ((sizeof(struct __anonstruct_204 ) + sizeof(struct vki_usbdevfs_ioctl )) << 16)): 
  if (arrghs->arg3) {
    vkui = (struct vki_usbdevfs_ioctl *)arrghs->arg3;
    while (1) {
      if (vgPlain_tdict.track_pre_mem_read) {
        (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                              (Char *)"ioctl(USBDEVFS_IOCTL)",
                                              (Addr )vkui,
                                              (SizeT )sizeof(struct vki_usbdevfs_ioctl ));
      } else {

      }
      break;
    }
    dir2 = (UInt )((vkui->ioctl_code >> 30) & ((1 << 2) - 1));
    size2 = (UInt )((vkui->ioctl_code >> 16) & ((1 << 14) - 1));
    if (size2 > 0U) {
      if (dir2 & 1U) {
        while (1) {
          if (vgPlain_tdict.track_pre_mem_read) {
            (*(vgPlain_tdict.track_pre_mem_read))((CorePart )3, tid,
                                                  (Char *)"ioctl(USBDEVFS_IOCTL).dataWrite",
                                                  (Addr )vkui->data,
                                                  (SizeT )size2);
          } else {

          }
          break;
        }
      } else
      if (dir2 & 2U) {
        while (1) {
          if (vgPlain_tdict.track_pre_mem_write) {
            (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                                   (Char *)"ioctl(USBDEVFS_IOCTL).dataRead",
                                                   (Addr )vkui->data,
                                                   (SizeT )size2);
          } else {

          }
          break;
        }
      } else {

      }
    } else {

    }
  } else {

  }
  break;
  case (UWord )((unsigned int )(85 << 8) | 20U): 
  break;
  case 1800UL: 
  case 1796UL: 
  case 1798UL: 
  case 1795UL: 
  break;
  case 1797UL: 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(I2C_FUNCS)",
                                             arrghs->arg3,
                                             (SizeT )sizeof(unsigned long ));
    } else {

    }
    break;
  }
  break;
  case 35638UL: 
  case 35636UL: 
  case 35634UL: 
  case 35606UL: 
  case 35632UL: 
  case 35628UL: 
  case 35626UL: 
  case 35624UL: 
  case 35622UL: 
  case 35620UL: 
  case 35618UL: 
  case 35612UL: 
  case 35616UL: 
  case 35610UL: 
  case 35608UL: 
  case 35604UL: 
  case 35602UL: 
  case 35600UL: 
  case 35598UL: 
  case 35596UL: 
  case 35594UL: 
  case 35592UL: 
  case 35590UL: 
  case 35588UL: 
  case 35586UL: 
  case 35584UL: 
  break;
  case 35585UL: 
  if (arrghs->arg3) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_write) {
        (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                               (Char *)"ioctl(SIOCGIWNAME)",
                                               (Addr )(((struct vki_iwreq *)arrghs->arg3)->u.name),
                                               (SizeT )sizeof(((struct vki_iwreq *)arrghs->arg3)->u.name));
      } else {

      }
      break;
    }
  } else {

  }
  break;
  case 35635UL: 
  case 35629UL: 
  case 35625UL: 
  case 35623UL: 
  case 35621UL: 
  case 35619UL: 
  case 35617UL: 
  case 35593UL: 
  case 35587UL: 
  if (arrghs->arg3) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_write) {
        (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                               (Char *)"ioctl(SIOCGIW[NWID|SENS|RATE|RTS|FRAG|TXPOW|RETRY|PARAM|AUTH])",
                                               (Addr )(& ((struct vki_iwreq *)arrghs->arg3)->u.nwid),
                                               (SizeT )sizeof(struct vki_iw_param ));
      } else {

      }
      break;
    }
  } else {

  }
  break;
  case 35589UL: 
  if (arrghs->arg3) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_write) {
        (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                               (Char *)"ioctl(SIOCGIWFREQ",
                                               (Addr )(& ((struct vki_iwreq *)arrghs->arg3)->u.freq),
                                               (SizeT )sizeof(struct vki_iw_freq ));
      } else {

      }
      break;
    }
  } else {

  }
  break;
  case 35591UL: 
  if (arrghs->arg3) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_write) {
        (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                               (Char *)"ioctl(SIOCGIWMODE",
                                               (Addr )(& ((struct vki_iwreq *)arrghs->arg3)->u.mode),
                                               (SizeT )sizeof(__vki_u32 ));
      } else {

      }
      break;
    }
  } else {

  }
  break;
  case 35637UL: 
  case 35633UL: 
  case 35627UL: 
  case 35613UL: 
  case 35611UL: 
  case 35609UL: 
  case 35607UL: 
  case 35603UL: 
  case 35601UL: 
  case 35599UL: 
  case 35597UL: 
  case 35595UL: 
  if (arrghs->arg3) {
    point = & ((struct vki_iwreq *)arrghs->arg3)->u.data;
    while (1) {
      if (vgPlain_tdict.track_pre_mem_write) {
        (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                               (Char *)"ioctl(SIOCGIW[RANGE|PRIV|STATS|SPY|THRSPY|APLIST|SCAN|ESSID|NICKN|ENCODE|GENIE|ENCODEEXT])",
                                               (Addr )point->pointer,
                                               (SizeT )point->length);
      } else {

      }
      break;
    }
  } else {

  }
  break;
  case 35605UL: 
  if (arrghs->arg3) {
    while (1) {
      if (vgPlain_tdict.track_pre_mem_write) {
        (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                               (Char *)"ioctl(SIOCGIWAP)",
                                               (Addr )(& ((struct vki_iwreq *)arrghs->arg3)->u.ap_addr),
                                               (SizeT )sizeof(struct vki_sockaddr ));
      } else {

      }
      break;
    }
  } else {

  }
  break;
  default: 
  switch (arrghs->arg2 & (unsigned long )(~ (((1 << 14) - 1) << 16))) {
  case (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | 55U): 
  case (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | 54U): 
  case (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | 53U): 
  case (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | 52U): 
  case (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | 50U): 
  case (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | 49U): 
  case (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | 37U): 
  case (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | 36U): 
  case (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | 35U): 
  case (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | 34U): 
  case (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | 33U): 
  case (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | 32U): 
  case (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | 27U): 
  case (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | 26U): 
  case (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | 25U): 
  case (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | 24U): 
  case (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | 8U): 
  case (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | 7U): 
  case (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | 6U): 
  while (1) {
    if (vgPlain_tdict.track_pre_mem_write) {
      {
      if (1 << 14 < 2) {
        return;
      }
      (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                             (Char *)"ioctl(EVIO*)",
                                             arrghs->arg3,
                                             (arrghs->arg2 >> 16) & (unsigned long )((1 << 14) - 1));
      }
    } else {

    }
    break;
  }
  break;
  default: 
  vgModuleLocal_PRE_unknown_ioctl(tid, arrghs->arg2, arrghs->arg3);
  break;
  }
  break;
  }
  return;
}
}
void vgSysWrap_linux_sys_ioctl_after(ThreadId tid , SyscallArgs *arrghs ,
                                     SyscallStatus *status ) 
{ 
  Bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  struct vki_ifconf *ifc ;
  UWord tmp___2 ;
  struct vki_cdrom_read_audio *cra ;
  struct vki_unimapdesc *desc ;
  struct vki_console_font_op *op ;
  struct vki_usbdevfs_ctrltransfer *vkuc ;
  UWord tmp___3 ;
  struct vki_usbdevfs_bulktransfer *vkub ;
  UWord tmp___4 ;
  struct vki_usbdevfs_getdriver *vkugd ;
  struct vki_usbdevfs_urb **vkuu ;
  struct vki_usbdevfs_setuppacket *vkusp ;
  char *bp ;
  int i ;
  struct vki_usbdevfs_ioctl *vkui ;
  UInt dir2 ;
  UInt size2 ;
  struct vki_iw_point *point ;
  UWord tmp___5 ;
  UWord tmp___6 ;
  UWord tmp___7 ;

  {
  if ((unsigned int )status->what == 1U) {
    tmp = sr_isError(status->sres);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
  } else {
    tmp___0 = 0;
  }
  tmp___1 = __builtin_expect((long )tmp___0, 1L);
  if (tmp___1) {

  } else {
    vgPlain_assert_fail((Bool )1, (Char const   *)"SUCCESS",
                        (Char const   *)"m_syswrap/syswrap-linux.c", 5318,
                        (Char const   *)"vgSysWrap_linux_sys_ioctl_after", "");
  }
  switch (arrghs->arg2) {
  case 21508UL: 
  case 21507UL: 
  case 21506UL: 
  break;
  case 21505UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(struct vki_termios ));
    } else {

    }
    break;
  }
  break;
  case 21512UL: 
  case 21511UL: 
  case 21510UL: 
  break;
  case 21509UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(struct vki_termio ));
    } else {

    }
    break;
  }
  break;
  case 21515UL: 
  case 21541UL: 
  case 21514UL: 
  case 21513UL: 
  break;
  case 21523UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(struct vki_winsize ));
    } else {

    }
    break;
  }
  break;
  case 21528UL: 
  case 21527UL: 
  case 21526UL: 
  case 21524UL: 
  break;
  case 21525UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(unsigned int ));
    } else {

    }
    break;
  }
  break;
  case 21532UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(char *));
    } else {

    }
    break;
  }
  break;
  case 21519UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(vki_pid_t ));
    } else {

    }
    break;
  }
  break;
  case 21520UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(vki_pid_t ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((((2U << 30) | (unsigned int )(84 << 8)) | 48U) | ((sizeof(struct __anonstruct_205 ) + sizeof(unsigned int )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case 21518UL: 
  break;
  case (UWord )((((1U << 30) | (unsigned int )(84 << 8)) | 49U) | ((sizeof(struct __anonstruct_206 ) + sizeof(int )) << 16)): 
  break;
  case 21537UL: 
  break;
  case 21586UL: 
  break;
  case 21531UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case 21600UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(vki_loff_t ));
    } else {

    }
    break;
  }
  break;
  case 21593UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case 21597UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(struct vki_serial_icounter_struct ));
    } else {

    }
    break;
  }
  break;
  case 8817UL: 
  break;
  case 8837UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(vki_sg_io_hdr_t ));
    } else {

    }
    break;
  }
  break;
  case 8822UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(vki_sg_scsi_id_t ));
    } else {

    }
    break;
  }
  break;
  case 8821UL: 
  break;
  case 8705UL: 
  break;
  case 8818UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case 8706UL: 
  break;
  case 8834UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case 8707UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case 8831UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((unsigned int )(73 << 8) | 21U): 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )(128U * sizeof(unsigned long )));
    } else {

    }
    break;
  }
  break;
  case (UWord )((unsigned int )(73 << 8) | 34U): 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(vki_isdn_net_ioctl_phone ));
    } else {

    }
    break;
  }
  break;
  case 35123UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                              (Addr )(& ((struct vki_ifreq *)arrghs->arg3)->ifr_ifru.ifru_ivalue),
                                              (SizeT )sizeof(((struct vki_ifreq *)arrghs->arg3)->ifr_ifru.ifru_ivalue));
    } else {

    }
    break;
  }
  break;
  case 35091UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                              (Addr )(& ((struct vki_ifreq *)arrghs->arg3)->ifr_ifru.ifru_flags),
                                              (SizeT )sizeof(((struct vki_ifreq *)arrghs->arg3)->ifr_ifru.ifru_flags));
    } else {

    }
    break;
  }
  break;
  case 35111UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                              (Addr )(& ((struct vki_ifreq *)arrghs->arg3)->ifr_ifru.ifru_hwaddr),
                                              (SizeT )sizeof(((struct vki_ifreq *)arrghs->arg3)->ifr_ifru.ifru_hwaddr));
    } else {

    }
    break;
  }
  break;
  case 35105UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                              (Addr )(& ((struct vki_ifreq *)arrghs->arg3)->ifr_ifru.ifru_mtu),
                                              (SizeT )sizeof(((struct vki_ifreq *)arrghs->arg3)->ifr_ifru.ifru_mtu));
    } else {

    }
    break;
  }
  break;
  case 35099UL: 
  case 35097UL: 
  case 35095UL: 
  case 35093UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                              (Addr )(& ((struct vki_ifreq *)arrghs->arg3)->ifr_ifru.ifru_addr),
                                              (SizeT )sizeof(((struct vki_ifreq *)arrghs->arg3)->ifr_ifru.ifru_addr));
    } else {

    }
    break;
  }
  break;
  case 35101UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                              (Addr )(& ((struct vki_ifreq *)arrghs->arg3)->ifr_ifru.ifru_ivalue),
                                              (SizeT )sizeof(((struct vki_ifreq *)arrghs->arg3)->ifr_ifru.ifru_ivalue));
    } else {

    }
    break;
  }
  break;
  case 35184UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                              (Addr )(& ((struct vki_ifreq *)arrghs->arg3)->ifr_ifru.ifru_map),
                                              (SizeT )sizeof(((struct vki_ifreq *)arrghs->arg3)->ifr_ifru.ifru_map));
    } else {

    }
    break;
  }
  break;
  break;
  case 35138UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                              (Addr )(& ((struct vki_ifreq *)arrghs->arg3)->ifr_ifru.ifru_ivalue),
                                              (SizeT )sizeof(((struct vki_ifreq *)arrghs->arg3)->ifr_ifru.ifru_ivalue));
    } else {

    }
    break;
  }
  break;
  case 35088UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                              (Addr )(& ((struct vki_ifreq *)arrghs->arg3)->ifr_ifrn.ifrn_name),
                                              (SizeT )sizeof(((struct vki_ifreq *)arrghs->arg3)->ifr_ifrn.ifrn_name));
    } else {

    }
    break;
  }
  break;
  case 35143UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                              (Addr )(& ((struct vki_mii_ioctl_data *)(& ((struct vki_ifreq *)arrghs->arg3)->ifr_ifru.ifru_data))->phy_id),
                                              (SizeT )sizeof(((struct vki_mii_ioctl_data *)(& ((struct vki_ifreq *)arrghs->arg3)->ifr_ifru.ifru_data))->phy_id));
    } else {

    }
    break;
  }
  break;
  case 35144UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                              (Addr )(& ((struct vki_mii_ioctl_data *)(& ((struct vki_ifreq *)arrghs->arg3)->ifr_ifru.ifru_data))->val_out),
                                              (SizeT )sizeof(((struct vki_mii_ioctl_data *)(& ((struct vki_ifreq *)arrghs->arg3)->ifr_ifru.ifru_data))->val_out));
    } else {

    }
    break;
  }
  break;
  case 35090UL: 
  tmp___2 = getRES(status);
  if (tmp___2 == 0UL) {
    if (arrghs->arg3) {
      ifc = (struct vki_ifconf *)arrghs->arg3;
      if ((unsigned int )ifc->ifc_ifcu.ifcu_buf != (unsigned int )((void *)0)) {
        while (1) {
          if (vgPlain_tdict.track_post_mem_write) {
            (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                    (Addr )ifc->ifc_ifcu.ifcu_buf,
                                                    (SizeT )ifc->ifc_len);
          } else {

          }
          break;
        }
      } else {

      }
    } else {

    }
  } else {

  }
  break;
  case 35078UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(struct vki_timeval ));
    } else {

    }
    break;
  }
  break;
  case 35079UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(struct vki_timespec ));
    } else {

    }
    break;
  }
  break;
  case 21521UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case 35156UL: 
  case 35169UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(struct vki_arpreq ));
    } else {

    }
    break;
  }
  break;
  case 35145UL: 
  case 35108UL: 
  case 35106UL: 
  case 35094UL: 
  case 35102UL: 
  case 35100UL: 
  case 35098UL: 
  case 35096UL: 
  case 35139UL: 
  case 35185UL: 
  case 35092UL: 
  break;
  case 35084UL: 
  case 35083UL: 
  break;
  case 35155UL: 
  case 35157UL: 
  case 35170UL: 
  case 35168UL: 
  break;
  case 35076UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case 35074UL: 
  break;
  case (UWord )((((2U << 30) | (unsigned int )(80 << 8)) | 7U) | ((sizeof(struct __anonstruct_225 ) + sizeof(int )) << 16)): 
  case (UWord )((((2U << 30) | (unsigned int )(80 << 8)) | 5U) | ((sizeof(struct __anonstruct_224 ) + sizeof(int )) << 16)): 
  case (UWord )((((2U << 30) | (unsigned int )(80 << 8)) | 6U) | ((sizeof(struct __anonstruct_223 ) + sizeof(int )) << 16)): 
  case (UWord )((((2U << 30) | (unsigned int )(80 << 8)) | 2U) | ((sizeof(struct __anonstruct_222 ) + sizeof(int )) << 16)): 
  case (UWord )((((2U << 30) | (unsigned int )(80 << 8)) | 15U) | ((sizeof(struct __anonstruct_221 ) + sizeof(int )) << 16)): 
  case (UWord )((((2U << 30) | (unsigned int )(80 << 8)) | 67U) | ((sizeof(struct __anonstruct_220 ) + sizeof(int )) << 16)): 
  case (UWord )((((2U << 30) | (unsigned int )(80 << 8)) | 23U) | ((sizeof(struct __anonstruct_219 ) + sizeof(int )) << 16)): 
  case (UWord )((((2U << 30) | (unsigned int )(80 << 8)) | 16U) | ((sizeof(struct __anonstruct_218 ) + sizeof(int )) << 16)): 
  case (UWord )((((3U << 30) | (unsigned int )(80 << 8)) | 5U) | ((sizeof(struct __anonstruct_217 ) + sizeof(int )) << 16)): 
  case (UWord )((((2U << 30) | (unsigned int )(80 << 8)) | 11U) | ((sizeof(struct __anonstruct_216 ) + sizeof(int )) << 16)): 
  case (UWord )((((3U << 30) | (unsigned int )(80 << 8)) | 4U) | ((sizeof(struct __anonstruct_215 ) + sizeof(int )) << 16)): 
  case (UWord )((((2U << 30) | (unsigned int )(81 << 8)) | 19U) | ((sizeof(struct __anonstruct_214 ) + sizeof(int )) << 16)): 
  case (UWord )((((2U << 30) | (unsigned int )(81 << 8)) | 11U) | ((sizeof(struct __anonstruct_213 ) + sizeof(int )) << 16)): 
  case (UWord )((((2U << 30) | (unsigned int )(81 << 8)) | 10U) | ((sizeof(struct __anonstruct_212 ) + sizeof(int )) << 16)): 
  case (UWord )((((1U << 30) | (unsigned int )(81 << 8)) | 9U) | ((sizeof(struct __anonstruct_211 ) + sizeof(int )) << 16)): 
  case (UWord )((((1U << 30) | (unsigned int )(81 << 8)) | 8U) | ((sizeof(struct __anonstruct_210 ) + sizeof(int )) << 16)): 
  case (UWord )((((1U << 30) | (unsigned int )(81 << 8)) | 6U) | ((sizeof(struct __anonstruct_209 ) + sizeof(int )) << 16)): 
  case (UWord )((((2U << 30) | (unsigned int )(81 << 8)) | 5U) | ((sizeof(struct __anonstruct_208 ) + sizeof(int )) << 16)): 
  case (UWord )((((2U << 30) | (unsigned int )(81 << 8)) | 4U) | ((sizeof(struct __anonstruct_207 ) + sizeof(int )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((((3U << 30) | (unsigned int )(109 << 8)) | 1U) | ((sizeof(struct __anonstruct_239 ) + sizeof(int )) << 16)): 
  case (UWord )(((3U << 30) | (unsigned int )(109 << 8)) | ((sizeof(struct __anonstruct_238 ) + sizeof(int )) << 16)): 
  case (UWord )((((3U << 30) | (unsigned int )(84 << 8)) | 6U) | ((sizeof(struct __anonstruct_237 ) + sizeof(int )) << 16)): 
  case (UWord )((((3U << 30) | (unsigned int )(84 << 8)) | 5U) | ((sizeof(struct __anonstruct_236 ) + sizeof(int )) << 16)): 
  case (UWord )((((3U << 30) | (unsigned int )(84 << 8)) | 1U) | ((sizeof(struct __anonstruct_235 ) + sizeof(int )) << 16)): 
  case (UWord )((((3U << 30) | (unsigned int )(80 << 8)) | 65U) | ((sizeof(struct __anonstruct_234 ) + sizeof(int )) << 16)): 
  case (UWord )((((3U << 30) | (unsigned int )(80 << 8)) | 64U) | ((sizeof(struct __anonstruct_233 ) + sizeof(int )) << 16)): 
  case (UWord )((((3U << 30) | (unsigned int )(80 << 8)) | 10U) | ((sizeof(struct __anonstruct_232 ) + sizeof(int )) << 16)): 
  case (UWord )((((3U << 30) | (unsigned int )(80 << 8)) | 9U) | ((sizeof(struct __anonstruct_231 ) + sizeof(int )) << 16)): 
  case (UWord )((((3U << 30) | (unsigned int )(80 << 8)) | 7U) | ((sizeof(struct __anonstruct_230 ) + sizeof(int )) << 16)): 
  case (UWord )((((3U << 30) | (unsigned int )(80 << 8)) | 6U) | ((sizeof(struct __anonstruct_229 ) + sizeof(int )) << 16)): 
  case (UWord )((((3U << 30) | (unsigned int )(80 << 8)) | 3U) | ((sizeof(struct __anonstruct_228 ) + sizeof(int )) << 16)): 
  case (UWord )((((3U << 30) | (unsigned int )(80 << 8)) | 2U) | ((sizeof(struct __anonstruct_227 ) + sizeof(int )) << 16)): 
  case (UWord )((((3U << 30) | (unsigned int )(81 << 8)) | 3U) | ((sizeof(struct __anonstruct_226 ) + sizeof(int )) << 16)): 
  break;
  case (UWord )((((2U << 30) | (unsigned int )(80 << 8)) | 13U) | ((sizeof(struct __anonstruct_241 ) + sizeof(vki_audio_buf_info )) << 16)): 
  case (UWord )((((2U << 30) | (unsigned int )(80 << 8)) | 12U) | ((sizeof(struct __anonstruct_240 ) + sizeof(vki_audio_buf_info )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(vki_audio_buf_info ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((unsigned int )(80 << 8) | 14U): 
  break;
  case (UWord )((((1U << 30) | (unsigned int )(80 << 8)) | 16U) | ((sizeof(struct __anonstruct_242 ) + sizeof(int )) << 16)): 
  break;
  case (UWord )((unsigned int )(80 << 8) | 22U): 
  case (UWord )((unsigned int )(80 << 8) | 21U): 
  case (UWord )((unsigned int )(80 << 8) | 1U): 
  case (UWord )((unsigned int )(80 << 8)): 
  case (UWord )((unsigned int )(80 << 8) | 8U): 
  break;
  case 21377UL: 
  case 21376UL: 
  case 21667UL: 
  case 21666UL: 
  case 21665UL: 
  case 21664UL: 
  case 16737UL: 
  case 16712UL: 
  case 16711UL: 
  case 16708UL: 
  case 16707UL: 
  case 16706UL: 
  case 16705UL: 
  case 16704UL: 
  case 16674UL: 
  case 16658UL: 
  break;
  case (UWord )((((1U << 30) | (unsigned int )(112 << 8)) | 12U) | ((sizeof(struct __anonstruct_243 ) + sizeof(unsigned long )) << 16)): 
  case (UWord )((unsigned int )(112 << 8) | 6U): 
  case (UWord )((unsigned int )(112 << 8) | 5U): 
  case (UWord )((unsigned int )(112 << 8) | 2U): 
  case (UWord )((unsigned int )(112 << 8) | 1U): 
  case (UWord )((unsigned int )(112 << 8) | 4U): 
  case (UWord )((unsigned int )(112 << 8) | 3U): 
  break;
  case (UWord )((((2U << 30) | (unsigned int )(112 << 8)) | 8U) | ((sizeof(struct __anonstruct_245 ) + sizeof(struct vki_rtc_time )) << 16)): 
  case (UWord )((((2U << 30) | (unsigned int )(112 << 8)) | 9U) | ((sizeof(struct __anonstruct_244 ) + sizeof(struct vki_rtc_time )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(struct vki_rtc_time ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((((1U << 30) | (unsigned int )(112 << 8)) | 7U) | ((sizeof(struct __anonstruct_246 ) + sizeof(struct vki_rtc_time )) << 16)): 
  break;
  case (UWord )((((2U << 30) | (unsigned int )(112 << 8)) | 11U) | ((sizeof(struct __anonstruct_247 ) + sizeof(unsigned long )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(unsigned long ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((unsigned int )(18 << 8) | 93U): 
  break;
  case (UWord )((unsigned int )(18 << 8) | 94U): 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((unsigned int )(18 << 8) | 96U): 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(unsigned long ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((unsigned int )(18 << 8) | 98U): 
  break;
  case (UWord )((unsigned int )(18 << 8) | 99U): 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(long ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((unsigned int )(18 << 8) | 100U): 
  break;
  case (UWord )((unsigned int )(18 << 8) | 101U): 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(long ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((unsigned int )(18 << 8) | 103U): 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(unsigned short ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((unsigned int )(18 << 8) | 104U): 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((((2U << 30) | (unsigned int )(18 << 8)) | 112U) | ((sizeof(struct __anonstruct_248 ) + sizeof(vki_size_t )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((((1U << 30) | (unsigned int )(18 << 8)) | 113U) | ((sizeof(struct __anonstruct_249 ) + sizeof(vki_size_t )) << 16)): 
  break;
  case (UWord )((((2U << 30) | (unsigned int )(18 << 8)) | 114U) | ((sizeof(struct __anonstruct_250 ) + sizeof(vki_size_t )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(unsigned long long ));
    } else {

    }
    break;
  }
  break;
  case 769UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(struct vki_hd_geometry ));
    } else {

    }
    break;
  }
  break;
  case 779UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(long ));
    } else {

    }
    break;
  }
  break;
  case 781UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )512);
    } else {

    }
    break;
  }
  break;
  case 21378UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(struct vki_scsi_idlun ));
    } else {

    }
    break;
  }
  break;
  case 21382UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case 21259UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(struct vki_cdrom_subchnl ));
    } else {

    }
    break;
  }
  break;
  case 21253UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(struct vki_cdrom_tochdr ));
    } else {

    }
    break;
  }
  break;
  case 21254UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(struct vki_cdrom_tocentry ));
    } else {

    }
    break;
  }
  break;
  case 21264UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(struct vki_cdrom_multisession ));
    } else {

    }
    break;
  }
  break;
  case 21267UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(struct vki_cdrom_volctrl ));
    } else {

    }
    break;
  }
  break;
  case 21268UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )2352);
    } else {

    }
    break;
  }
  break;
  case 21262UL: 
  cra = (struct vki_cdrom_read_audio *)arrghs->arg3;
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                              (Addr )cra->buf,
                                              (SizeT )(cra->nframes * 2352));
    } else {

    }
    break;
  }
  break;
  case 21251UL: 
  break;
  case 21281UL: 
  case 21286UL: 
  break;
  case 2UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(unsigned long ));
    } else {

    }
    break;
  }
  break;
  case 1UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case 17920UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(struct vki_fb_var_screeninfo ));
    } else {

    }
    break;
  }
  break;
  case 17922UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(struct vki_fb_fix_screeninfo ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((((1U << 30) | (unsigned int )(112 << 8)) | 150U) | ((sizeof(struct __anonstruct_260 ) + sizeof(struct vki_timeval )) << 16)): 
  case (UWord )((((1U << 30) | (unsigned int )(112 << 8)) | 146U) | ((sizeof(struct __anonstruct_259 ) + sizeof(unsigned char )) << 16)): 
  case (UWord )((((1U << 30) | (unsigned int )(112 << 8)) | 145U) | ((sizeof(struct __anonstruct_258 ) + sizeof(int )) << 16)): 
  case (UWord )((((1U << 30) | (unsigned int )(112 << 8)) | 144U) | ((sizeof(struct __anonstruct_257 ) + sizeof(int )) << 16)): 
  case (UWord )((((1U << 30) | (unsigned int )(112 << 8)) | 142U) | ((sizeof(struct __anonstruct_256 ) + sizeof(struct vki_ppdev_frob_struct )) << 16)): 
  case (UWord )((((1U << 30) | (unsigned int )(112 << 8)) | 132U) | ((sizeof(struct __anonstruct_255 ) + sizeof(unsigned char )) << 16)): 
  case (UWord )((((1U << 30) | (unsigned int )(112 << 8)) | 134U) | ((sizeof(struct __anonstruct_254 ) + sizeof(unsigned char )) << 16)): 
  case (UWord )((((1U << 30) | (unsigned int )(112 << 8)) | 155U) | ((sizeof(struct __anonstruct_253 ) + sizeof(int )) << 16)): 
  case (UWord )((((1U << 30) | (unsigned int )(112 << 8)) | 148U) | ((sizeof(struct __anonstruct_252 ) + sizeof(int )) << 16)): 
  case (UWord )((((1U << 30) | (unsigned int )(112 << 8)) | 128U) | ((sizeof(struct __anonstruct_251 ) + sizeof(int )) << 16)): 
  case (UWord )((unsigned int )(112 << 8) | 140U): 
  case (UWord )((unsigned int )(112 << 8) | 141U): 
  case (UWord )((unsigned int )(112 << 8) | 143U): 
  case (UWord )((unsigned int )(112 << 8) | 139U): 
  break;
  case (UWord )((((2U << 30) | (unsigned int )(112 << 8)) | 152U) | ((sizeof(struct __anonstruct_261 ) + sizeof(int )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((((2U << 30) | (unsigned int )(112 << 8)) | 153U) | ((sizeof(struct __anonstruct_262 ) + sizeof(int )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((((2U << 30) | (unsigned int )(112 << 8)) | 151U) | ((sizeof(struct __anonstruct_263 ) + sizeof(unsigned int )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(unsigned int ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((((2U << 30) | (unsigned int )(112 << 8)) | 154U) | ((sizeof(struct __anonstruct_264 ) + sizeof(int )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((((2U << 30) | (unsigned int )(112 << 8)) | 129U) | ((sizeof(struct __anonstruct_265 ) + sizeof(unsigned char )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(unsigned char ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((((2U << 30) | (unsigned int )(112 << 8)) | 133U) | ((sizeof(struct __anonstruct_266 ) + sizeof(unsigned char )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(unsigned char ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((((2U << 30) | (unsigned int )(112 << 8)) | 131U) | ((sizeof(struct __anonstruct_267 ) + sizeof(unsigned char )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(unsigned char ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((((2U << 30) | (unsigned int )(112 << 8)) | 147U) | ((sizeof(struct __anonstruct_268 ) + sizeof(int )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((((2U << 30) | (unsigned int )(112 << 8)) | 149U) | ((sizeof(struct __anonstruct_269 ) + sizeof(struct vki_timeval )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(struct vki_timeval ));
    } else {

    }
    break;
  }
  break;
  case 19296UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )8192);
    } else {

    }
    break;
  }
  break;
  case 19297UL: 
  break;
  case 19307UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                              (Addr )((struct vki_consolefontdesc *)arrghs->arg3)->chardata,
                                              (SizeT )(32 * (int )((struct vki_consolefontdesc *)arrghs->arg3)->charcount));
    } else {

    }
    break;
  }
  break;
  case 19308UL: 
  break;
  case 19309UL: 
  break;
  case 19312UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )48);
    } else {

    }
    break;
  }
  break;
  case 19313UL: 
  break;
  case 19248UL: 
  case 19247UL: 
  break;
  case 19249UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(char ));
    } else {

    }
    break;
  }
  break;
  case 19250UL: 
  break;
  case 19251UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(char ));
    } else {

    }
    break;
  }
  break;
  case 19255UL: 
  case 19254UL: 
  case 19253UL: 
  case 19252UL: 
  break;
  case 19258UL: 
  break;
  case 19259UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case 19261UL: 
  case 19260UL: 
  break;
  case 19264UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )256);
    } else {

    }
    break;
  }
  break;
  case 19265UL: 
  break;
  case 19305UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )(256U * sizeof(unsigned short )));
    } else {

    }
    break;
  }
  break;
  case 19306UL: 
  break;
  case 19302UL: 
  if (arrghs->arg3) {
    desc = (struct vki_unimapdesc *)arrghs->arg3;
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                (Addr )(& desc->entry_ct),
                                                (SizeT )sizeof(desc->entry_ct));
      } else {

      }
      break;
    }
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                (Addr )desc->entries,
                                                (SizeT )((unsigned int )desc->entry_ct * sizeof(struct vki_unipair )));
      } else {

      }
      break;
    }
  } else {

  }
  break;
  case 19303UL: 
  break;
  case 19304UL: 
  break;
  case 19268UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case 19269UL: 
  break;
  case 19298UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case 19299UL: 
  break;
  case 19300UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(char ));
    } else {

    }
    break;
  }
  break;
  case 19301UL: 
  break;
  case 19270UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                              (Addr )(& ((struct vki_kbentry *)arrghs->arg3)->kb_value),
                                              (SizeT )sizeof(((struct vki_kbentry *)arrghs->arg3)->kb_value));
    } else {

    }
    break;
  }
  break;
  case 19271UL: 
  break;
  case 19272UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                              (Addr )(((struct vki_kbsentry *)arrghs->arg3)->kb_string),
                                              (SizeT )sizeof(((struct vki_kbsentry *)arrghs->arg3)->kb_string));
    } else {

    }
    break;
  }
  break;
  case 19273UL: 
  break;
  case 19274UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(struct vki_kbdiacrs ));
    } else {

    }
    break;
  }
  break;
  case 19275UL: 
  break;
  case 19276UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                              (Addr )((struct vki_kbkeycode *)arrghs->arg3)->keycode,
                                              (SizeT )sizeof(((struct vki_kbkeycode *)arrghs->arg3)->keycode));
    } else {

    }
    break;
  }
  break;
  case 19277UL: 
  break;
  case 19278UL: 
  break;
  case 19282UL: 
  break;
  case 19314UL: 
  if (arrghs->arg3) {
    op = (struct vki_console_font_op *)arrghs->arg3;
    switch (op->op) {
    case 0U: 
    break;
    case 1U: 
    if (op->data) {
      while (1) {
        if (vgPlain_tdict.track_post_mem_write) {
          (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                  (Addr )op->data,
                                                  (SizeT )((((op->width + 7U) / 8U) * 32U) * op->charcount));
        } else {

        }
        break;
      }
    } else {

    }
    break;
    case 2U: 
    break;
    case 3U: 
    break;
    }
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, (Addr )op,
                                                (SizeT )sizeof(*op));
      } else {

      }
      break;
    }
  } else {

  }
  break;
  case 22016UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(int ));
    } else {

    }
    break;
  }
  break;
  case 22017UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(struct vki_vt_mode ));
    } else {

    }
    break;
  }
  break;
  case 22018UL: 
  break;
  case 22019UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                              (Addr )(& ((struct vki_vt_stat *)arrghs->arg3)->v_active),
                                              (SizeT )sizeof(((struct vki_vt_stat *)arrghs->arg3)->v_active));
    } else {

    }
    break;
  }
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                              (Addr )(& ((struct vki_vt_stat *)arrghs->arg3)->v_state),
                                              (SizeT )sizeof(((struct vki_vt_stat *)arrghs->arg3)->v_state));
    } else {

    }
    break;
  }
  break;
  case 22024UL: 
  case 22023UL: 
  case 22022UL: 
  case 22021UL: 
  break;
  case 22025UL: 
  break;
  case 22026UL: 
  break;
  case 22028UL: 
  case 22027UL: 
  break;
  case (UWord )(((3U << 30) | (unsigned int )(85 << 8)) | ((sizeof(struct __anonstruct_270 ) + sizeof(struct vki_usbdevfs_ctrltransfer )) << 16)): 
  if (arrghs->arg3) {
    vkuc = (struct vki_usbdevfs_ctrltransfer *)arrghs->arg3;
    if ((int )vkuc->bRequestType & 128) {
      while (1) {
        if (vgPlain_tdict.track_post_mem_write) {
          tmp___3 = getRES(status);
          (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                  (Addr )vkuc->data, tmp___3);
        } else {

        }
        break;
      }
    } else {

    }
  } else {

  }
  break;
  case (UWord )((((3U << 30) | (unsigned int )(85 << 8)) | 2U) | ((sizeof(struct __anonstruct_271 ) + sizeof(struct vki_usbdevfs_bulktransfer )) << 16)): 
  if (arrghs->arg3) {
    vkub = (struct vki_usbdevfs_bulktransfer *)arrghs->arg3;
    if (vkub->ep & 128U) {
      while (1) {
        if (vgPlain_tdict.track_post_mem_write) {
          tmp___4 = getRES(status);
          (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                  (Addr )vkub->data, tmp___4);
        } else {

        }
        break;
      }
    } else {

    }
  } else {

  }
  break;
  case (UWord )((((1U << 30) | (unsigned int )(85 << 8)) | 8U) | ((sizeof(struct __anonstruct_272 ) + sizeof(struct vki_usbdevfs_getdriver )) << 16)): 
  if (arrghs->arg3) {
    vkugd = (struct vki_usbdevfs_getdriver *)arrghs->arg3;
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                (Addr )(& vkugd->driver),
                                                (SizeT )sizeof(vkugd->driver));
      } else {

      }
      break;
    }
  } else {

  }
  break;
  case (UWord )((((1U << 30) | (unsigned int )(85 << 8)) | 13U) | ((sizeof(struct __anonstruct_274 ) + sizeof(void *)) << 16)): 
  case (UWord )((((1U << 30) | (unsigned int )(85 << 8)) | 12U) | ((sizeof(struct __anonstruct_273 ) + sizeof(void *)) << 16)): 
  if (arrghs->arg3) {
    vkuu = (struct vki_usbdevfs_urb **)arrghs->arg3;
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, (Addr )vkuu,
                                                (SizeT )sizeof(*vkuu));
      } else {

      }
      break;
    }
    if (! *vkuu) {
      break;
    } else {

    }
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                (Addr )(& (*vkuu)->status),
                                                (SizeT )sizeof((*vkuu)->status));
      } else {

      }
      break;
    }
    if ((int )(*vkuu)->type == 2) {
      vkusp = (struct vki_usbdevfs_setuppacket *)(*vkuu)->buffer;
      if ((int )vkusp->bRequestType & 128) {
        while (1) {
          if (vgPlain_tdict.track_post_mem_write) {
            (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                    (Addr )(vkusp + 1),
                                                    (SizeT )((unsigned int )(*vkuu)->buffer_length - sizeof(*vkusp)));
          } else {

          }
          break;
        }
      } else {

      }
      while (1) {
        if (vgPlain_tdict.track_post_mem_write) {
          (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                  (Addr )(& (*vkuu)->actual_length),
                                                  (SizeT )sizeof((*vkuu)->actual_length));
        } else {

        }
        break;
      }
    } else
    if ((int )(*vkuu)->type == 0) {
      bp = (char *)(*vkuu)->buffer;
      i = 0;
      while (i < (*vkuu)->number_of_packets) {
        while (1) {
          if (vgPlain_tdict.track_post_mem_write) {
            (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                    (Addr )(& (*vkuu)->iso_frame_desc[i].actual_length),
                                                    (SizeT )sizeof((*vkuu)->iso_frame_desc[i].actual_length));
          } else {

          }
          break;
        }
        while (1) {
          if (vgPlain_tdict.track_post_mem_write) {
            (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                    (Addr )(& (*vkuu)->iso_frame_desc[i].status),
                                                    (SizeT )sizeof((*vkuu)->iso_frame_desc[i].status));
          } else {

          }
          break;
        }
        if ((int )(*vkuu)->endpoint & 128) {
          while (1) {
            if (vgPlain_tdict.track_post_mem_write) {
              (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                      (Addr )bp,
                                                      (SizeT )(*vkuu)->iso_frame_desc[i].actual_length);
            } else {

            }
            break;
          }
        } else {

        }
        bp += (*vkuu)->iso_frame_desc[i].length;
        i ++;
      }
      while (1) {
        if (vgPlain_tdict.track_post_mem_write) {
          (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                  (Addr )(& (*vkuu)->error_count),
                                                  (SizeT )sizeof((*vkuu)->error_count));
        } else {

        }
        break;
      }
    } else {
      if ((int )(*vkuu)->endpoint & 128) {
        while (1) {
          if (vgPlain_tdict.track_post_mem_write) {
            (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                    (Addr )(*vkuu)->buffer,
                                                    (SizeT )(*vkuu)->actual_length);
          } else {

          }
          break;
        }
      } else {

      }
      while (1) {
        if (vgPlain_tdict.track_post_mem_write) {
          (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                  (Addr )(& (*vkuu)->actual_length),
                                                  (SizeT )sizeof((*vkuu)->actual_length));
        } else {

        }
        break;
      }
    }
  } else {

  }
  break;
  case (UWord )((((1U << 30) | (unsigned int )(85 << 8)) | 17U) | ((sizeof(struct __anonstruct_275 ) + sizeof(struct vki_usbdevfs_connectinfo )) << 16)): 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(struct vki_usbdevfs_connectinfo ));
    } else {

    }
    break;
  }
  break;
  case (UWord )((((3U << 30) | (unsigned int )(85 << 8)) | 18U) | ((sizeof(struct __anonstruct_276 ) + sizeof(struct vki_usbdevfs_ioctl )) << 16)): 
  if (arrghs->arg3) {
    vkui = (struct vki_usbdevfs_ioctl *)arrghs->arg3;
    dir2 = (UInt )((vkui->ioctl_code >> 30) & ((1 << 2) - 1));
    size2 = (UInt )((vkui->ioctl_code >> 16) & ((1 << 14) - 1));
    if (size2 > 0U) {
      if (dir2 & 2U) {
        while (1) {
          if (vgPlain_tdict.track_post_mem_write) {
            (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                    (Addr )vkui->data,
                                                    (SizeT )size2);
          } else {

          }
          break;
        }
      } else {

      }
    } else {

    }
  } else {

  }
  break;
  case 1800UL: 
  case 1796UL: 
  case 1798UL: 
  case 1795UL: 
  break;
  case 1797UL: 
  while (1) {
    if (vgPlain_tdict.track_post_mem_write) {
      (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                              (SizeT )sizeof(unsigned long ));
    } else {

    }
    break;
  }
  break;
  case 35638UL: 
  case 35636UL: 
  case 35634UL: 
  case 35606UL: 
  case 35632UL: 
  case 35628UL: 
  case 35626UL: 
  case 35624UL: 
  case 35622UL: 
  case 35620UL: 
  case 35618UL: 
  case 35612UL: 
  case 35616UL: 
  case 35610UL: 
  case 35608UL: 
  case 35604UL: 
  case 35602UL: 
  case 35600UL: 
  case 35598UL: 
  case 35596UL: 
  case 35594UL: 
  case 35592UL: 
  case 35590UL: 
  case 35588UL: 
  case 35586UL: 
  case 35584UL: 
  break;
  case 35585UL: 
  if (arrghs->arg3) {
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                (Addr )(((struct vki_iwreq *)arrghs->arg3)->u.name),
                                                (SizeT )sizeof(((struct vki_iwreq *)arrghs->arg3)->u.name));
      } else {

      }
      break;
    }
  } else {

  }
  break;
  case 35635UL: 
  case 35629UL: 
  case 35625UL: 
  case 35623UL: 
  case 35621UL: 
  case 35619UL: 
  case 35617UL: 
  case 35593UL: 
  case 35587UL: 
  if (arrghs->arg3) {
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                (Addr )(& ((struct vki_iwreq *)arrghs->arg3)->u.param),
                                                (SizeT )sizeof(struct vki_iw_param ));
      } else {

      }
      break;
    }
  } else {

  }
  break;
  case 35589UL: 
  if (arrghs->arg3) {
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                (Addr )(& ((struct vki_iwreq *)arrghs->arg3)->u.freq),
                                                (SizeT )sizeof(struct vki_iw_freq ));
      } else {

      }
      break;
    }
  } else {

  }
  break;
  case 35591UL: 
  if (arrghs->arg3) {
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                (Addr )(& ((struct vki_iwreq *)arrghs->arg3)->u.mode),
                                                (SizeT )sizeof(__vki_u32 ));
      } else {

      }
      break;
    }
  } else {

  }
  break;
  case 35637UL: 
  case 35633UL: 
  case 35627UL: 
  case 35613UL: 
  case 35611UL: 
  case 35609UL: 
  case 35607UL: 
  case 35603UL: 
  case 35601UL: 
  case 35599UL: 
  case 35597UL: 
  case 35595UL: 
  if (arrghs->arg3) {
    point = & ((struct vki_iwreq *)arrghs->arg3)->u.data;
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                (Addr )point->pointer,
                                                (SizeT )point->length);
      } else {

      }
      break;
    }
  } else {

  }
  break;
  case 35605UL: 
  if (arrghs->arg3) {
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                (Addr )(& ((struct vki_iwreq *)arrghs->arg3)->u.ap_addr),
                                                (SizeT )sizeof(struct vki_sockaddr ));
      } else {

      }
      break;
    }
  } else {

  }
  break;
  default: 
  switch (arrghs->arg2 & (unsigned long )(~ (((1 << 14) - 1) << 16))) {
  case (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | 55U): 
  case (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | 54U): 
  case (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | 53U): 
  case (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | 52U): 
  case (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | 50U): 
  case (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | 49U): 
  case (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | 37U): 
  case (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | 36U): 
  case (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | 35U): 
  case (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | 34U): 
  case (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | 33U): 
  case (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | 32U): 
  case (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | 27U): 
  case (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | 26U): 
  case (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | 25U): 
  case (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | 24U): 
  case (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | 8U): 
  case (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | 7U): 
  case (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | 6U): 
  tmp___6 = getRES(status);
  if (tmp___6 > 0UL) {
    while (1) {
      if (vgPlain_tdict.track_post_mem_write) {
        tmp___5 = getRES(status);
        (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid, arrghs->arg3,
                                                tmp___5);
      } else {

      }
      break;
    }
  } else {

  }
  break;
  default: 
  tmp___7 = getRES(status);
  vgModuleLocal_POST_unknown_ioctl(tid, (UInt )tmp___7, arrghs->arg2,
                                   arrghs->arg3);
  break;
  }
  break;
  }
  return;
}
}
void vgModuleLocal_linux_PRE_sys_getsockopt(ThreadId tid , UWord arg0 ,
                                            UWord arg1 , UWord arg2 ,
                                            UWord arg3 , UWord arg4 ) 
{ 
  Addr optval_p ;
  Addr optlen_p ;
  struct vki_sctp_getaddrs *ga ;
  int address_bytes ;

  {
  optval_p = arg3;
  optlen_p = arg4;
  if (optval_p != (Addr )((void *)0)) {
    vgModuleLocal_buf_and_len_pre_check(tid, optval_p, optlen_p,
                                        (Char *)"socketcall.getsockopt(optval)",
                                        (Char *)"socketcall.getsockopt(optlen)");
    if (arg1 == 132UL) {
      if (arg2 == 104UL) {
        goto _L;
      } else
      if (arg2 == 106UL) {
        _L: /* CIL Label */ 
        ga = (struct vki_sctp_getaddrs *)arg3;
        address_bytes = (int )(sizeof(struct vki_sockaddr_in6 ) * (unsigned int )ga->addr_num);
        while (1) {
          if (vgPlain_tdict.track_pre_mem_write) {
            (*(vgPlain_tdict.track_pre_mem_write))((CorePart )3, tid,
                                                   (Char *)"socketcall.getsockopt(optval.addrs)",
                                                   (Addr )ga->addrs,
                                                   (SizeT )address_bytes);
          } else {

          }
          break;
        }
      } else {

      }
    } else {

    }
  } else {

  }
  return;
}
}
void vgModuleLocal_linux_POST_sys_getsockopt(ThreadId tid , SysRes res ,
                                             UWord arg0 , UWord arg1 ,
                                             UWord arg2 , UWord arg3 ,
                                             UWord arg4 ) 
{ 
  Addr optval_p ;
  Addr optlen_p ;
  Bool tmp ;
  int tmp___0 ;
  long tmp___1 ;
  struct vki_sctp_getaddrs *ga ;
  struct vki_sockaddr *a ;
  int i ;
  int sl ;

  {
  optval_p = arg3;
  optlen_p = arg4;
  tmp = sr_isError(res);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  tmp___1 = __builtin_expect((long )tmp___0, 1L);
  if (tmp___1) {

  } else {
    vgPlain_assert_fail((Bool )1, (Char const   *)"!sr_isError(res)",
                        (Char const   *)"m_syswrap/syswrap-linux.c", 6318,
                        (Char const   *)"vgModuleLocal_linux_POST_sys_getsockopt",
                        "");
  }
  if (optval_p != (Addr )((void *)0)) {
    vgModuleLocal_buf_and_len_post_check(tid, res, optval_p, optlen_p,
                                         (Char *)"socketcall.getsockopt(optlen_out)");
    if (arg1 == 132UL) {
      if (arg2 == 104UL) {
        goto _L;
      } else
      if (arg2 == 106UL) {
        _L: /* CIL Label */ 
        ga = (struct vki_sctp_getaddrs *)arg3;
        a = ga->addrs;
        i = 0;
        while (i < ga->addr_num) {
          sl = 0;
          if ((int )a->sa_family == 2) {
            sl = (int )sizeof(struct vki_sockaddr_in );
          } else
          if ((int )a->sa_family == 10) {
            sl = (int )sizeof(struct vki_sockaddr_in6 );
          } else {
            vgPlain_message((VgMsgKind )1,
                            "Warning: getsockopt: unhandled address type %d\n",
                            (int )a->sa_family);
          }
          a = (struct vki_sockaddr *)((char *)a + sl);
          i ++;
        }
        while (1) {
          if (vgPlain_tdict.track_post_mem_write) {
            (*(vgPlain_tdict.track_post_mem_write))((CorePart )3, tid,
                                                    (Addr )ga->addrs,
                                                    (SizeT )((char *)a - (char *)ga->addrs));
          } else {

          }
          break;
        }
      } else {

      }
    } else {

    }
  } else {

  }
  return;
}
}
